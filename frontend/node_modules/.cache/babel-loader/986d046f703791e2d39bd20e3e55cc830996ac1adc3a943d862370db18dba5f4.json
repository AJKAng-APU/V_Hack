{"ast":null,"code":"import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n\n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n\n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   */\n  initialize(userId, callbacks = {}) {\n    console.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Set up callbacks\n    this.onLocalStream = callbacks.onLocalStream || (() => {});\n    this.onRemoteStream = callbacks.onRemoteStream || (() => {});\n    this.onCallStarted = callbacks.onCallStarted || (() => {});\n    this.onCallEnded = callbacks.onCallEnded || (() => {});\n    this.onCallConnecting = callbacks.onCallConnecting || (() => {});\n    this.onIncomingCall = callbacks.onIncomingCall || (() => {});\n    this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange || (() => {});\n\n    // Connect to the signaling server\n    // In production, use your deployed signaling server URL\n    this.socket = io('http://localhost:3001');\n\n    // Register user ID with the signaling server\n    this.socket.emit('register', userId);\n\n    // Set up event listeners for signaling messages\n    this.setupSocketListeners();\n  }\n\n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({\n      callerUserId,\n      offerSDP\n    }) => {\n      console.log('Incoming call from:', callerUserId);\n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n\n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n\n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n\n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({\n      answerSDP\n    }) => {\n      console.log('Call was answered, setting remote description');\n      try {\n        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answerSDP));\n      } catch (error) {\n        console.error('Error setting remote description:', error);\n      }\n    });\n\n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({\n      candidate\n    }) => {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log('Added ICE candidate');\n        }\n      } catch (error) {\n        console.error('Error adding ICE candidate:', error);\n      }\n    });\n\n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      console.log('Call ended remotely');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n\n    // Handle call failure\n    this.socket.on('call-failed', ({\n      message,\n      targetUserId\n    }) => {\n      console.error('Call failed:', message);\n      this.onCallEnded();\n      this.resetCallState();\n    });\n  }\n\n  /**\n   * Initialize the WebRTC peer connection with STUN/TURN servers\n   * STUN servers help discover your public IP address\n   * TURN servers relay traffic when direct connection fails\n   */\n  initializePeerConnection() {\n    // ICE servers configuration (STUN/TURN)\n    const configuration = {\n      iceServers: [\n      // Google's public STUN server\n      {\n        urls: 'stun:stun.l.google.com:19302'\n      }\n      // You should add your TURN server here for production\n      /*\n      {\n        urls: 'turn:your-turn-server.com',\n        username: 'username',\n        credential: 'password'\n      }\n      */]\n    };\n    console.log('Initializing peer connection with configuration:', configuration);\n\n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        console.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n\n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = event => {\n      console.log('Received remote track:', event.track.kind);\n\n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n\n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        console.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n\n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('Generated ICE candidate for type:', event.candidate.type);\n\n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state changes\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      console.log('ICE connection state changed to:', state);\n      this.onICEConnectionStateChange(state);\n\n      // Handle connection establishment\n      if (state === 'connected') {\n        console.log('Call connected successfully!');\n        this.onCallStarted();\n      }\n      // Handle connection failures\n      else if (state === 'disconnected' || state === 'failed' || state === 'closed') {\n        console.log('Connection lost or failed');\n        this.endCall(true);\n      }\n    };\n  }\n\n  /**\n   * Get access to the user's camera and microphone\n   * @param {boolean|object} videoConstraints - Video constraints or false to disable video\n   * @param {boolean|object} audioConstraints - Audio constraints or false to disable audio\n   * @returns {Promise<MediaStream>} The local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      console.log('Requesting access to local media with constraints:', {\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n\n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      console.log('Access to local media granted');\n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      console.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.onCallConnecting();\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n\n      // Create an offer (SDP)\n      console.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n\n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n\n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      console.log('Call offer sent');\n    } catch (error) {\n      console.error('Error making call:', error);\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      console.log('Accepting incoming call from:', this.targetUserId);\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n\n      // Set the remote description from the stored offer\n      console.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(new RTCSessionDescription(this.pendingOffer));\n\n      // Create an answer\n      console.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n\n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n\n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      console.log('Call accepted, answer sent');\n      this.onCallConnecting();\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Reject an incoming call\n   */\n  rejectCall() {\n    console.log('Rejecting call from:', this.targetUserId);\n    this.socket.emit('end-call', {\n      targetUserId: this.targetUserId\n    });\n    this.resetCallState();\n  }\n\n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    console.log('Ending call, notify peer:', notifyPeer);\n\n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      this.socket.emit('end-call', {\n        targetUserId: this.targetUserId\n      });\n    }\n\n    // Close peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        console.log('Stopping track:', track.kind);\n        track.stop();\n      });\n    }\n\n    // Trigger callback\n    this.onCallEnded();\n\n    // Reset state\n    this.resetCallState();\n  }\n\n  /**\n   * Toggle the mute state of the audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        console.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle the camera on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        console.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n\n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    console.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n  }\n\n  /**\n   * Disconnect from signaling server and clean up\n   */\n  disconnect() {\n    console.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["io","WebRTCService","constructor","socket","peerConnection","localStream","remoteStream","userId","targetUserId","isCallInitiator","pendingOffer","onLocalStream","onRemoteStream","onCallStarted","onCallEnded","onCallConnecting","onIncomingCall","onICEConnectionStateChange","initialize","callbacks","console","log","emit","setupSocketListeners","on","callerUserId","offerSDP","answerSDP","setRemoteDescription","RTCSessionDescription","error","candidate","addIceCandidate","RTCIceCandidate","endCall","message","resetCallState","initializePeerConnection","configuration","iceServers","urls","RTCPeerConnection","getTracks","forEach","track","kind","addTrack","ontrack","event","MediaStream","streams","onicecandidate","type","oniceconnectionstatechange","state","iceConnectionState","getLocalMedia","videoConstraints","audioConstraints","video","audio","stream","navigator","mediaDevices","getUserMedia","makeCall","offer","createOffer","setLocalDescription","acceptCall","answer","createAnswer","rejectCall","notifyPeer","close","stop","toggleAudio","muted","getAudioTracks","enabled","toggleVideo","videoOff","getVideoTracks","disconnect","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n    \n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    \n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   */\n  initialize(userId, callbacks = {}) {\n    console.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Set up callbacks\n    this.onLocalStream = callbacks.onLocalStream || (() => {});\n    this.onRemoteStream = callbacks.onRemoteStream || (() => {});\n    this.onCallStarted = callbacks.onCallStarted || (() => {});\n    this.onCallEnded = callbacks.onCallEnded || (() => {});\n    this.onCallConnecting = callbacks.onCallConnecting || (() => {});\n    this.onIncomingCall = callbacks.onIncomingCall || (() => {});\n    this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange || (() => {});\n    \n    // Connect to the signaling server\n    // In production, use your deployed signaling server URL\n    this.socket = io('http://localhost:3001');\n    \n    // Register user ID with the signaling server\n    this.socket.emit('register', userId);\n    \n    // Set up event listeners for signaling messages\n    this.setupSocketListeners();\n  }\n  \n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({ callerUserId, offerSDP }) => {\n      console.log('Incoming call from:', callerUserId);\n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n      \n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n      \n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n    \n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({ answerSDP }) => {\n      console.log('Call was answered, setting remote description');\n      try {\n        await this.peerConnection.setRemoteDescription(\n          new RTCSessionDescription(answerSDP)\n        );\n      } catch (error) {\n        console.error('Error setting remote description:', error);\n      }\n    });\n    \n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({ candidate }) => {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.addIceCandidate(\n            new RTCIceCandidate(candidate)\n          );\n          console.log('Added ICE candidate');\n        }\n      } catch (error) {\n        console.error('Error adding ICE candidate:', error);\n      }\n    });\n    \n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      console.log('Call ended remotely');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n    \n    // Handle call failure\n    this.socket.on('call-failed', ({ message, targetUserId }) => {\n      console.error('Call failed:', message);\n      this.onCallEnded();\n      this.resetCallState();\n    });\n  }\n  \n  /**\n   * Initialize the WebRTC peer connection with STUN/TURN servers\n   * STUN servers help discover your public IP address\n   * TURN servers relay traffic when direct connection fails\n   */\n  initializePeerConnection() {\n    // ICE servers configuration (STUN/TURN)\n    const configuration = {\n      iceServers: [\n        // Google's public STUN server\n        { urls: 'stun:stun.l.google.com:19302' },\n        // You should add your TURN server here for production\n        /*\n        {\n          urls: 'turn:your-turn-server.com',\n          username: 'username',\n          credential: 'password'\n        }\n        */\n      ]\n    };\n    \n    console.log('Initializing peer connection with configuration:', configuration);\n    \n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n    \n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        console.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n    \n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = (event) => {\n      console.log('Received remote track:', event.track.kind);\n      \n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n      \n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        console.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n    \n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('Generated ICE candidate for type:', event.candidate.type);\n        \n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n    \n    // Monitor connection state changes\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      console.log('ICE connection state changed to:', state);\n      \n      this.onICEConnectionStateChange(state);\n      \n      // Handle connection establishment\n      if (state === 'connected') {\n        console.log('Call connected successfully!');\n        this.onCallStarted();\n      } \n      // Handle connection failures\n      else if (\n        state === 'disconnected' || \n        state === 'failed' ||\n        state === 'closed'\n      ) {\n        console.log('Connection lost or failed');\n        this.endCall(true);\n      }\n    };\n  }\n  \n  /**\n   * Get access to the user's camera and microphone\n   * @param {boolean|object} videoConstraints - Video constraints or false to disable video\n   * @param {boolean|object} audioConstraints - Audio constraints or false to disable audio\n   * @returns {Promise<MediaStream>} The local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      console.log('Requesting access to local media with constraints:', {\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      \n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      \n      console.log('Access to local media granted');\n      \n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      console.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.onCallConnecting();\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      // Create an offer (SDP)\n      console.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      \n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      \n      console.log('Call offer sent');\n    } catch (error) {\n      console.error('Error making call:', error);\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      console.log('Accepting incoming call from:', this.targetUserId);\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      // Set the remote description from the stored offer\n      console.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(\n        new RTCSessionDescription(this.pendingOffer)\n      );\n      \n      // Create an answer\n      console.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n      \n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n      \n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      \n      console.log('Call accepted, answer sent');\n      this.onCallConnecting();\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Reject an incoming call\n   */\n  rejectCall() {\n    console.log('Rejecting call from:', this.targetUserId);\n    this.socket.emit('end-call', { targetUserId: this.targetUserId });\n    this.resetCallState();\n  }\n  \n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    console.log('Ending call, notify peer:', notifyPeer);\n    \n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      this.socket.emit('end-call', { targetUserId: this.targetUserId });\n    }\n    \n    // Close peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    \n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        console.log('Stopping track:', track.kind);\n        track.stop();\n      });\n    }\n    \n    // Trigger callback\n    this.onCallEnded();\n    \n    // Reset state\n    this.resetCallState();\n  }\n  \n  /**\n   * Toggle the mute state of the audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        console.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Toggle the camera on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        console.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n  \n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    console.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n  }\n  \n  /**\n   * Disconnect from signaling server and clean up\n   */\n  disconnect() {\n    console.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    \n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}