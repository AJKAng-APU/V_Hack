{"ast":null,"code":"// File: services/WebRTC/SignalingService.js\nimport io from 'socket.io-client';\n\n/**\n * Creates a signaling service instance with enhanced reliability and transport fallback\n * @param {string} serverUrl - Signaling server URL\n * @param {string} userId - Current user ID\n * @param {function} eventHandler - Event handler function\n * @returns {Object} - Signaling service instance\n */\nexport function createSignalingService(serverUrl, userId, eventHandler) {\n  console.log(`Creating signaling service for ${userId} to ${serverUrl}`);\n\n  // CRITICAL CHANGE: Enhanced Socket.io configuration with transport fallback\n  const socket = io(serverUrl, {\n    reconnection: true,\n    reconnectionAttempts: Infinity,\n    // Never stop trying to reconnect\n    reconnectionDelay: 1000,\n    // Initial delay\n    reconnectionDelayMax: 5000,\n    // Maximum delay\n    randomizationFactor: 0.5,\n    // Randomization factor for reconnection attempts\n    timeout: 20000,\n    // Longer timeout\n    transports: ['websocket', 'polling'],\n    // Try both transport methods\n    upgrade: true,\n    // Attempt to upgrade to WebSocket if possible\n    rememberUpgrade: true,\n    // Remember if websocket was successful\n    autoConnect: true,\n    // Connect on creation\n    forceNew: false // Reuse connection if possible\n  });\n  let connected = false;\n  let reconnecting = false;\n  let pendingMessages = [];\n  let reconnectAttempts = 0;\n  let forceClosing = false; // Flag to track intentional disconnects\n\n  // Create a better logging system for the signaling service\n  const log = (message, level = 'info') => {\n    const timestamp = new Date().toISOString().split('T')[1].substring(0, 8);\n    const prefix = `[Signaling ${timestamp}]`;\n    if (level === 'error') {\n      console.error(prefix, message);\n    } else if (level === 'warn') {\n      console.warn(prefix, message);\n    } else {\n      console.log(prefix, message);\n    }\n\n    // Store logs in localStorage for debugging (limited to last 100 entries)\n    try {\n      const logs = JSON.parse(localStorage.getItem('signaling_logs') || '[]');\n      logs.push({\n        timestamp: new Date().toISOString(),\n        level,\n        message\n      });\n\n      // Keep only the last 100 logs\n      if (logs.length > 100) {\n        logs.splice(0, logs.length - 100);\n      }\n      localStorage.setItem('signaling_logs', JSON.stringify(logs));\n    } catch (e) {\n      // Ignore storage errors\n    }\n  };\n\n  // Handle connection events with better logging\n  socket.on('connect', () => {\n    log(`Connected to signaling server (Socket ID: ${socket.id})`);\n    connected = true;\n    reconnecting = false;\n    reconnectAttempts = 0;\n\n    // Register user ID with the signaling server\n    socket.emit('register', userId);\n    log(`Registered as user: ${userId}`);\n\n    // Process any pending messages\n    if (pendingMessages.length > 0) {\n      log(`Processing ${pendingMessages.length} pending messages`);\n\n      // Create a copy of the pending messages to avoid modification during iteration\n      const messagesToSend = [...pendingMessages];\n      pendingMessages = [];\n\n      // Send messages with a small delay between them\n      messagesToSend.forEach((msg, index) => {\n        setTimeout(() => {\n          try {\n            socket.emit(msg.event, msg.data);\n            log(`Sent pending message: ${msg.event}`);\n          } catch (err) {\n            log(`Error sending pending message: ${err.message}`, 'error');\n            pendingMessages.push(msg); // Re-queue if sending fails\n          }\n        }, index * 100); // 100ms between messages to avoid flooding\n      });\n    }\n\n    // Dispatch a connection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-connected'));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  socket.on('connect_error', error => {\n    log(`Connection error: ${error.message}`, 'error');\n\n    // Check if we should switch to polling if websocket fails\n    if (socket.io.opts.transports[0] === 'websocket' && reconnectAttempts >= 2) {\n      log('WebSocket connection failed, forcing polling transport', 'warn');\n      // Force the socket to use polling temporarily\n      socket.io.opts.transports = ['polling', 'websocket'];\n    }\n  });\n  socket.on('disconnect', reason => {\n    log(`Disconnected from signaling server, reason: ${reason}`, 'warn');\n    connected = false;\n\n    // Only set reconnecting flag if this wasn't an intentional disconnect\n    if (!forceClosing) {\n      reconnecting = true;\n\n      // If the disconnection was not intended, attempt to reconnect immediately\n      if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n        log('Unexpected disconnection, attempting immediate reconnection');\n        setTimeout(() => {\n          if (!connected && !forceClosing) {\n            log('Forcing reconnection after unexpected disconnect');\n            socket.connect();\n          }\n        }, 1000);\n      }\n    }\n\n    // Dispatch a disconnection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-disconnected', {\n        detail: {\n          reason\n        }\n      }));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  socket.on('reconnect_attempt', attemptNumber => {\n    reconnectAttempts = attemptNumber;\n    log(`Attempting to reconnect (attempt ${attemptNumber})`);\n    reconnecting = true;\n\n    // After several failed websocket attempts, try polling\n    if (attemptNumber > 3 && socket.io.opts.transports[0] === 'websocket') {\n      log('Multiple websocket reconnect attempts failed, trying polling', 'warn');\n      socket.io.opts.transports = ['polling', 'websocket'];\n    }\n\n    // After even more failures, try a completely new connection\n    if (attemptNumber > 5) {\n      log('Multiple reconnect attempts failed, trying new connection', 'warn');\n      socket.io.opts.forceNew = true;\n    }\n  });\n  socket.on('reconnect', attemptNumber => {\n    log(`Reconnected after ${attemptNumber} attempts`);\n    reconnecting = false;\n    connected = true;\n\n    // Re-register after reconnection\n    socket.emit('register', userId);\n    log(`Re-registered as user: ${userId}`);\n\n    // Reset transports after successful reconnection\n    socket.io.opts.transports = ['websocket', 'polling'];\n    socket.io.opts.forceNew = false;\n\n    // Dispatch a reconnection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-reconnected'));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  socket.on('reconnect_error', error => {\n    log(`Reconnection error: ${error.message}`, 'error');\n\n    // After multiple reconnection errors, try a more aggressive approach\n    if (reconnectAttempts > 3) {\n      log('Multiple reconnection errors, trying alternative connection method', 'warn');\n\n      // Try a completely new connection with forced polling\n      setTimeout(() => {\n        if (!connected && !forceClosing) {\n          socket.io.opts.transports = ['polling'];\n          socket.io.opts.forceNew = true;\n          socket.connect();\n        }\n      }, 2000);\n    }\n  });\n  socket.on('reconnect_failed', () => {\n    log('Failed to reconnect after all attempts', 'error');\n    reconnecting = false;\n\n    // One last desperate attempt after complete failure\n    setTimeout(() => {\n      if (!connected && !forceClosing) {\n        log('Making last-ditch reconnection attempt', 'warn');\n        socket.io.opts = {\n          ...socket.io.opts,\n          transports: ['polling'],\n          forceNew: true,\n          timeout: 30000\n        };\n        socket.connect();\n      }\n    }, 5000);\n  });\n  socket.on('error', error => {\n    log(`Socket error: ${error.message || error}`, 'error');\n  });\n\n  // Set up event listeners for signaling messages\n  socket.on('incoming-call', data => {\n    eventHandler('incoming-call', data);\n  });\n  socket.on('call-answered', data => {\n    eventHandler('call-answered', data);\n  });\n  socket.on('call-declined', () => {\n    eventHandler('call-declined');\n  });\n  socket.on('call-in-progress', data => {\n    eventHandler('call-in-progress', data);\n  });\n  socket.on('ice-candidate', data => {\n    eventHandler('ice-candidate', data);\n  });\n  socket.on('call-ended', () => {\n    eventHandler('call-ended');\n  });\n  socket.on('direct-call-ended', data => {\n    eventHandler('direct-call-ended', data);\n  });\n  socket.on('call-failed', data => {\n    eventHandler('call-failed', data);\n  });\n  socket.on('media-connected', () => {\n    eventHandler('media-connected');\n  });\n\n  // Return the signaling service interface with enhanced functionality\n  return {\n    socket,\n    // Expose the socket object for direct access if needed\n\n    /**\n     * Send a message to the signaling server with improved error handling and queuing\n     * @param {string} event - Event name\n     * @param {Object} data - Event data\n     * @returns {boolean} - Whether the message was sent or queued successfully\n     */\n    send: (event, data) => {\n      // Special handling for critical messages like call-ended\n      const isCriticalMessage = event === 'end-call' || event === 'direct-call-ended' || event === 'call-declined' || event === 'register';\n      if (connected) {\n        try {\n          socket.emit(event, data);\n          log(`Sent ${event} message`);\n\n          // For critical messages, add redundancy\n          if (isCriticalMessage) {\n            // Send again after a short delay for reliability\n            setTimeout(() => {\n              if (connected) {\n                socket.emit(event, data);\n                log(`Sent redundant ${event} message`);\n              } else {\n                pendingMessages.unshift({\n                  event,\n                  data\n                }); // Add to front of queue\n              }\n            }, 500);\n          }\n          return true;\n        } catch (error) {\n          log(`Error sending ${event}: ${error.message}`, 'error');\n\n          // Queue the message in case of error\n          pendingMessages.push({\n            event,\n            data\n          });\n\n          // Try to reconnect immediately\n          if (!reconnecting) {\n            socket.connect();\n          }\n          return false;\n        }\n      } else if (reconnecting || !connected) {\n        // Queue the message to be sent after reconnection\n        log(`Queueing ${event} message to be sent after reconnection`);\n\n        // Critical messages go to the front of the queue\n        if (isCriticalMessage) {\n          pendingMessages.unshift({\n            event,\n            data\n          });\n        } else {\n          pendingMessages.push({\n            event,\n            data\n          });\n        }\n\n        // Try to reconnect immediately if not already reconnecting\n        if (!reconnecting) {\n          log('Triggering reconnection for queued message');\n          socket.connect();\n        }\n        return false;\n      }\n    },\n    /**\n     * Check if a user is online with improved reliability\n     * @param {string} userId - User ID to check\n     * @returns {Promise<boolean>} - Whether the user is online\n     */\n    checkUserOnline: userId => {\n      return new Promise(resolve => {\n        if (!connected) {\n          // Try to reconnect first\n          log(`Not connected when checking if ${userId} is online, attempting to reconnect`);\n          socket.connect();\n\n          // Wait a bit for potential connection\n          setTimeout(() => {\n            if (connected) {\n              // Now try the check\n              checkOnlineStatus(userId, resolve);\n            } else {\n              log(`Failed to reconnect when checking if ${userId} is online`, 'warn');\n              resolve(false);\n            }\n          }, 2000);\n        } else {\n          checkOnlineStatus(userId, resolve);\n        }\n      });\n      function checkOnlineStatus(userId, resolve) {\n        // Create a unique request ID\n        const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        log(`Checking if user ${userId} is online (requestId: ${requestId})`);\n        socket.emit('check-user-online', {\n          userId,\n          requestId\n        });\n\n        // Set up a one-time event listener for the response\n        const responseHandler = data => {\n          if (data.responseId === requestId && data.userId === userId) {\n            socket.off('user-online-status', responseHandler);\n            clearTimeout(timeoutId);\n            log(`User ${userId} online status: ${data.isOnline}`);\n            resolve(data.isOnline);\n          }\n        };\n        socket.on('user-online-status', responseHandler);\n\n        // Set a timeout in case we never get a response\n        const timeoutId = setTimeout(() => {\n          socket.off('user-online-status', responseHandler);\n          log(`User online check timed out for ${userId}`, 'warn');\n          resolve(false);\n        }, 5000);\n      }\n    },\n    /**\n     * Check if connected to the signaling server\n     * @returns {boolean} - Whether connected\n     */\n    isConnected: () => connected,\n    /**\n     * Force reconnection to the signaling server\n     * @returns {Promise<boolean>} - Whether reconnection was successful\n     */\n    reconnect: () => {\n      return new Promise(resolve => {\n        if (connected) {\n          resolve(true);\n          return;\n        }\n        log('Forcing reconnection to signaling server');\n\n        // Reset socket.io options to try all transport methods\n        socket.io.opts.transports = ['websocket', 'polling'];\n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n\n          // Re-register after connection\n          socket.emit('register', userId);\n          log(`Re-registered as ${userId} after forced reconnection`);\n          resolve(true);\n        };\n        socket.once('connect', connectHandler);\n        socket.connect();\n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          log('Forced reconnection attempt timed out', 'error');\n\n          // Try one more time with polling transport\n          socket.io.opts.transports = ['polling'];\n          socket.connect();\n\n          // Set another timeout for the second attempt\n          setTimeout(() => {\n            if (connected) {\n              resolve(true);\n            } else {\n              log('Second reconnection attempt failed', 'error');\n              resolve(false);\n            }\n          }, 5000);\n        }, 5000);\n      });\n    },\n    /**\n     * Get connection status and detailed diagnostic information\n     * @returns {Object} - Connection status object\n     */\n    getStatus: () => {\n      return {\n        connected,\n        reconnecting,\n        pendingMessages: pendingMessages.length,\n        socketId: socket.id,\n        reconnectAttempts,\n        currentTransports: socket.io.opts.transports,\n        url: serverUrl,\n        userId\n      };\n    },\n    /**\n     * Flush any pending messages immediately\n     * @returns {number} - Number of messages flushed\n     */\n    flushPendingMessages: () => {\n      if (!connected || pendingMessages.length === 0) {\n        return 0;\n      }\n      const count = pendingMessages.length;\n      log(`Flushing ${count} pending messages`);\n\n      // Create a copy of the messages to avoid modification during sending\n      const messagesToSend = [...pendingMessages];\n      pendingMessages = [];\n\n      // Send messages with a small delay between them\n      messagesToSend.forEach((msg, index) => {\n        setTimeout(() => {\n          try {\n            socket.emit(msg.event, msg.data);\n            log(`Flushed pending message: ${msg.event}`);\n          } catch (err) {\n            log(`Error during flush: ${err.message}`, 'error');\n            pendingMessages.push(msg); // Re-queue if sending fails\n          }\n        }, index * 100); // 100ms between messages\n      });\n      return count;\n    },\n    /**\n     * Force a new socket connection\n     * @returns {Promise<boolean>} - Whether the new connection was successful\n     */\n    forceNewConnection: () => {\n      return new Promise(resolve => {\n        log('Forcing completely new socket connection');\n\n        // Disconnect current socket if connected\n        if (connected) {\n          forceClosing = true;\n          socket.disconnect();\n        }\n\n        // Reset connection options\n        socket.io.opts = {\n          ...socket.io.opts,\n          forceNew: true,\n          transports: ['websocket', 'polling']\n        };\n\n        // Reset flags\n        forceClosing = false;\n        reconnecting = false;\n\n        // Register connect handler\n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n\n          // Re-register after connection\n          socket.emit('register', userId);\n          log(`Re-registered as ${userId} after new connection`);\n          resolve(true);\n        };\n        socket.once('connect', connectHandler);\n\n        // Attempt connection\n        socket.connect();\n\n        // Set timeout for connection attempt\n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          log('New connection attempt timed out', 'error');\n          resolve(false);\n        }, 7000);\n      });\n    },\n    /**\n     * Get the logs for debugging\n     * @returns {Array} - Array of log entries\n     */\n    getLogs: () => {\n      try {\n        return JSON.parse(localStorage.getItem('signaling_logs') || '[]');\n      } catch (e) {\n        return [];\n      }\n    },\n    /**\n     * Disconnect from the signaling server\n     */\n    disconnect: () => {\n      if (connected) {\n        log('Explicitly disconnecting from signaling server');\n        forceClosing = true;\n        socket.disconnect();\n        connected = false;\n      }\n    }\n  };\n}","map":{"version":3,"names":["io","createSignalingService","serverUrl","userId","eventHandler","console","log","socket","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","timeout","transports","upgrade","rememberUpgrade","autoConnect","forceNew","connected","reconnecting","pendingMessages","reconnectAttempts","forceClosing","message","level","timestamp","Date","toISOString","split","substring","prefix","error","warn","logs","JSON","parse","localStorage","getItem","push","length","splice","setItem","stringify","e","on","id","emit","messagesToSend","forEach","msg","index","setTimeout","event","data","err","window","dispatchEvent","CustomEvent","opts","reason","connect","detail","attemptNumber","send","isCriticalMessage","unshift","checkUserOnline","Promise","resolve","checkOnlineStatus","requestId","now","Math","random","toString","responseHandler","responseId","off","clearTimeout","timeoutId","isOnline","isConnected","reconnect","connectHandler","once","getStatus","socketId","currentTransports","url","flushPendingMessages","count","forceNewConnection","disconnect","getLogs"],"sources":["/Users/ang/V_Hack_Ver4_2/frontend2/src/components/services/SignalingService.js"],"sourcesContent":["// File: services/WebRTC/SignalingService.js\nimport io from 'socket.io-client';\n\n/**\n * Creates a signaling service instance with enhanced reliability and transport fallback\n * @param {string} serverUrl - Signaling server URL\n * @param {string} userId - Current user ID\n * @param {function} eventHandler - Event handler function\n * @returns {Object} - Signaling service instance\n */\nexport function createSignalingService(serverUrl, userId, eventHandler) {\n  console.log(`Creating signaling service for ${userId} to ${serverUrl}`);\n  \n  // CRITICAL CHANGE: Enhanced Socket.io configuration with transport fallback\n  const socket = io(serverUrl, {\n    reconnection: true,\n    reconnectionAttempts: Infinity,  // Never stop trying to reconnect\n    reconnectionDelay: 1000,         // Initial delay\n    reconnectionDelayMax: 5000,      // Maximum delay\n    randomizationFactor: 0.5,        // Randomization factor for reconnection attempts\n    timeout: 20000,                  // Longer timeout\n    transports: ['websocket', 'polling'],  // Try both transport methods\n    upgrade: true,                   // Attempt to upgrade to WebSocket if possible\n    rememberUpgrade: true,           // Remember if websocket was successful\n    autoConnect: true,               // Connect on creation\n    forceNew: false                  // Reuse connection if possible\n  });\n  \n  let connected = false;\n  let reconnecting = false;\n  let pendingMessages = [];\n  let reconnectAttempts = 0;\n  let forceClosing = false; // Flag to track intentional disconnects\n  \n  // Create a better logging system for the signaling service\n  const log = (message, level = 'info') => {\n    const timestamp = new Date().toISOString().split('T')[1].substring(0, 8);\n    const prefix = `[Signaling ${timestamp}]`;\n    \n    if (level === 'error') {\n      console.error(prefix, message);\n    } else if (level === 'warn') {\n      console.warn(prefix, message);\n    } else {\n      console.log(prefix, message);\n    }\n    \n    // Store logs in localStorage for debugging (limited to last 100 entries)\n    try {\n      const logs = JSON.parse(localStorage.getItem('signaling_logs') || '[]');\n      logs.push({ timestamp: new Date().toISOString(), level, message });\n      \n      // Keep only the last 100 logs\n      if (logs.length > 100) {\n        logs.splice(0, logs.length - 100);\n      }\n      \n      localStorage.setItem('signaling_logs', JSON.stringify(logs));\n    } catch (e) {\n      // Ignore storage errors\n    }\n  };\n  \n  // Handle connection events with better logging\n  socket.on('connect', () => {\n    log(`Connected to signaling server (Socket ID: ${socket.id})`);\n    connected = true;\n    reconnecting = false;\n    reconnectAttempts = 0;\n    \n    // Register user ID with the signaling server\n    socket.emit('register', userId);\n    log(`Registered as user: ${userId}`);\n    \n    // Process any pending messages\n    if (pendingMessages.length > 0) {\n      log(`Processing ${pendingMessages.length} pending messages`);\n      \n      // Create a copy of the pending messages to avoid modification during iteration\n      const messagesToSend = [...pendingMessages];\n      pendingMessages = [];\n      \n      // Send messages with a small delay between them\n      messagesToSend.forEach((msg, index) => {\n        setTimeout(() => {\n          try {\n            socket.emit(msg.event, msg.data);\n            log(`Sent pending message: ${msg.event}`);\n          } catch (err) {\n            log(`Error sending pending message: ${err.message}`, 'error');\n            pendingMessages.push(msg); // Re-queue if sending fails\n          }\n        }, index * 100); // 100ms between messages to avoid flooding\n      });\n    }\n    \n    // Dispatch a connection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-connected'));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  \n  socket.on('connect_error', (error) => {\n    log(`Connection error: ${error.message}`, 'error');\n    \n    // Check if we should switch to polling if websocket fails\n    if (socket.io.opts.transports[0] === 'websocket' && reconnectAttempts >= 2) {\n      log('WebSocket connection failed, forcing polling transport', 'warn');\n      // Force the socket to use polling temporarily\n      socket.io.opts.transports = ['polling', 'websocket'];\n    }\n  });\n  \n  socket.on('disconnect', (reason) => {\n    log(`Disconnected from signaling server, reason: ${reason}`, 'warn');\n    connected = false;\n    \n    // Only set reconnecting flag if this wasn't an intentional disconnect\n    if (!forceClosing) {\n      reconnecting = true;\n      \n      // If the disconnection was not intended, attempt to reconnect immediately\n      if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n        log('Unexpected disconnection, attempting immediate reconnection');\n        setTimeout(() => {\n          if (!connected && !forceClosing) {\n            log('Forcing reconnection after unexpected disconnect');\n            socket.connect();\n          }\n        }, 1000);\n      }\n    }\n    \n    // Dispatch a disconnection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-disconnected', { detail: { reason } }));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  \n  socket.on('reconnect_attempt', (attemptNumber) => {\n    reconnectAttempts = attemptNumber;\n    log(`Attempting to reconnect (attempt ${attemptNumber})`);\n    reconnecting = true;\n    \n    // After several failed websocket attempts, try polling\n    if (attemptNumber > 3 && socket.io.opts.transports[0] === 'websocket') {\n      log('Multiple websocket reconnect attempts failed, trying polling', 'warn');\n      socket.io.opts.transports = ['polling', 'websocket'];\n    }\n    \n    // After even more failures, try a completely new connection\n    if (attemptNumber > 5) {\n      log('Multiple reconnect attempts failed, trying new connection', 'warn');\n      socket.io.opts.forceNew = true;\n    }\n  });\n  \n  socket.on('reconnect', (attemptNumber) => {\n    log(`Reconnected after ${attemptNumber} attempts`);\n    reconnecting = false;\n    connected = true;\n    \n    // Re-register after reconnection\n    socket.emit('register', userId);\n    log(`Re-registered as user: ${userId}`);\n    \n    // Reset transports after successful reconnection\n    socket.io.opts.transports = ['websocket', 'polling'];\n    socket.io.opts.forceNew = false;\n    \n    // Dispatch a reconnection event that components can listen for\n    try {\n      window.dispatchEvent(new CustomEvent('signaling-reconnected'));\n    } catch (e) {\n      // Ignore event dispatch errors\n    }\n  });\n  \n  socket.on('reconnect_error', (error) => {\n    log(`Reconnection error: ${error.message}`, 'error');\n    \n    // After multiple reconnection errors, try a more aggressive approach\n    if (reconnectAttempts > 3) {\n      log('Multiple reconnection errors, trying alternative connection method', 'warn');\n      \n      // Try a completely new connection with forced polling\n      setTimeout(() => {\n        if (!connected && !forceClosing) {\n          socket.io.opts.transports = ['polling'];\n          socket.io.opts.forceNew = true;\n          socket.connect();\n        }\n      }, 2000);\n    }\n  });\n  \n  socket.on('reconnect_failed', () => {\n    log('Failed to reconnect after all attempts', 'error');\n    reconnecting = false;\n    \n    // One last desperate attempt after complete failure\n    setTimeout(() => {\n      if (!connected && !forceClosing) {\n        log('Making last-ditch reconnection attempt', 'warn');\n        socket.io.opts = {\n          ...socket.io.opts,\n          transports: ['polling'],\n          forceNew: true,\n          timeout: 30000\n        };\n        socket.connect();\n      }\n    }, 5000);\n  });\n  \n  socket.on('error', (error) => {\n    log(`Socket error: ${error.message || error}`, 'error');\n  });\n  \n  // Set up event listeners for signaling messages\n  socket.on('incoming-call', (data) => {\n    eventHandler('incoming-call', data);\n  });\n  \n  socket.on('call-answered', (data) => {\n    eventHandler('call-answered', data);\n  });\n  \n  socket.on('call-declined', () => {\n    eventHandler('call-declined');\n  });\n  \n  socket.on('call-in-progress', (data) => {\n    eventHandler('call-in-progress', data);\n  });\n  \n  socket.on('ice-candidate', (data) => {\n    eventHandler('ice-candidate', data);\n  });\n  \n  socket.on('call-ended', () => {\n    eventHandler('call-ended');\n  });\n  \n  socket.on('direct-call-ended', (data) => {\n    eventHandler('direct-call-ended', data);\n  });\n  \n  socket.on('call-failed', (data) => {\n    eventHandler('call-failed', data);\n  });\n  \n  socket.on('media-connected', () => {\n    eventHandler('media-connected');\n  });\n  \n  // Return the signaling service interface with enhanced functionality\n  return {\n    socket, // Expose the socket object for direct access if needed\n    \n    /**\n     * Send a message to the signaling server with improved error handling and queuing\n     * @param {string} event - Event name\n     * @param {Object} data - Event data\n     * @returns {boolean} - Whether the message was sent or queued successfully\n     */\n    send: (event, data) => {\n      // Special handling for critical messages like call-ended\n      const isCriticalMessage = event === 'end-call' || event === 'direct-call-ended' || \n                               event === 'call-declined' || event === 'register';\n      \n      if (connected) {\n        try {\n          socket.emit(event, data);\n          log(`Sent ${event} message`);\n          \n          // For critical messages, add redundancy\n          if (isCriticalMessage) {\n            // Send again after a short delay for reliability\n            setTimeout(() => {\n              if (connected) {\n                socket.emit(event, data);\n                log(`Sent redundant ${event} message`);\n              } else {\n                pendingMessages.unshift({ event, data }); // Add to front of queue\n              }\n            }, 500);\n          }\n          \n          return true;\n        } catch (error) {\n          log(`Error sending ${event}: ${error.message}`, 'error');\n          \n          // Queue the message in case of error\n          pendingMessages.push({ event, data });\n          \n          // Try to reconnect immediately\n          if (!reconnecting) {\n            socket.connect();\n          }\n          \n          return false;\n        }\n      } else if (reconnecting || !connected) {\n        // Queue the message to be sent after reconnection\n        log(`Queueing ${event} message to be sent after reconnection`);\n        \n        // Critical messages go to the front of the queue\n        if (isCriticalMessage) {\n          pendingMessages.unshift({ event, data });\n        } else {\n          pendingMessages.push({ event, data });\n        }\n        \n        // Try to reconnect immediately if not already reconnecting\n        if (!reconnecting) {\n          log('Triggering reconnection for queued message');\n          socket.connect();\n        }\n        \n        return false;\n      }\n    },\n    \n    /**\n     * Check if a user is online with improved reliability\n     * @param {string} userId - User ID to check\n     * @returns {Promise<boolean>} - Whether the user is online\n     */\n    checkUserOnline: (userId) => {\n      return new Promise((resolve) => {\n        if (!connected) {\n          // Try to reconnect first\n          log(`Not connected when checking if ${userId} is online, attempting to reconnect`);\n          \n          socket.connect();\n          \n          // Wait a bit for potential connection\n          setTimeout(() => {\n            if (connected) {\n              // Now try the check\n              checkOnlineStatus(userId, resolve);\n            } else {\n              log(`Failed to reconnect when checking if ${userId} is online`, 'warn');\n              resolve(false);\n            }\n          }, 2000);\n        } else {\n          checkOnlineStatus(userId, resolve);\n        }\n      });\n      \n      function checkOnlineStatus(userId, resolve) {\n        // Create a unique request ID\n        const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        \n        log(`Checking if user ${userId} is online (requestId: ${requestId})`);\n        socket.emit('check-user-online', { userId, requestId });\n        \n        // Set up a one-time event listener for the response\n        const responseHandler = (data) => {\n          if (data.responseId === requestId && data.userId === userId) {\n            socket.off('user-online-status', responseHandler);\n            clearTimeout(timeoutId);\n            log(`User ${userId} online status: ${data.isOnline}`);\n            resolve(data.isOnline);\n          }\n        };\n        \n        socket.on('user-online-status', responseHandler);\n        \n        // Set a timeout in case we never get a response\n        const timeoutId = setTimeout(() => {\n          socket.off('user-online-status', responseHandler);\n          log(`User online check timed out for ${userId}`, 'warn');\n          resolve(false);\n        }, 5000);\n      }\n    },\n    \n    /**\n     * Check if connected to the signaling server\n     * @returns {boolean} - Whether connected\n     */\n    isConnected: () => connected,\n    \n    /**\n     * Force reconnection to the signaling server\n     * @returns {Promise<boolean>} - Whether reconnection was successful\n     */\n    reconnect: () => {\n      return new Promise((resolve) => {\n        if (connected) {\n          resolve(true);\n          return;\n        }\n        \n        log('Forcing reconnection to signaling server');\n        \n        // Reset socket.io options to try all transport methods\n        socket.io.opts.transports = ['websocket', 'polling'];\n        \n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n          \n          // Re-register after connection\n          socket.emit('register', userId);\n          log(`Re-registered as ${userId} after forced reconnection`);\n          resolve(true);\n        };\n        \n        socket.once('connect', connectHandler);\n        socket.connect();\n        \n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          log('Forced reconnection attempt timed out', 'error');\n          \n          // Try one more time with polling transport\n          socket.io.opts.transports = ['polling'];\n          socket.connect();\n          \n          // Set another timeout for the second attempt\n          setTimeout(() => {\n            if (connected) {\n              resolve(true);\n            } else {\n              log('Second reconnection attempt failed', 'error');\n              resolve(false);\n            }\n          }, 5000);\n        }, 5000);\n      });\n    },\n    \n    /**\n     * Get connection status and detailed diagnostic information\n     * @returns {Object} - Connection status object\n     */\n    getStatus: () => {\n      return {\n        connected,\n        reconnecting,\n        pendingMessages: pendingMessages.length,\n        socketId: socket.id,\n        reconnectAttempts,\n        currentTransports: socket.io.opts.transports,\n        url: serverUrl,\n        userId\n      };\n    },\n    \n    /**\n     * Flush any pending messages immediately\n     * @returns {number} - Number of messages flushed\n     */\n    flushPendingMessages: () => {\n      if (!connected || pendingMessages.length === 0) {\n        return 0;\n      }\n      \n      const count = pendingMessages.length;\n      log(`Flushing ${count} pending messages`);\n      \n      // Create a copy of the messages to avoid modification during sending\n      const messagesToSend = [...pendingMessages];\n      pendingMessages = [];\n      \n      // Send messages with a small delay between them\n      messagesToSend.forEach((msg, index) => {\n        setTimeout(() => {\n          try {\n            socket.emit(msg.event, msg.data);\n            log(`Flushed pending message: ${msg.event}`);\n          } catch (err) {\n            log(`Error during flush: ${err.message}`, 'error');\n            pendingMessages.push(msg); // Re-queue if sending fails\n          }\n        }, index * 100); // 100ms between messages\n      });\n      \n      return count;\n    },\n    \n    /**\n     * Force a new socket connection\n     * @returns {Promise<boolean>} - Whether the new connection was successful\n     */\n    forceNewConnection: () => {\n      return new Promise((resolve) => {\n        log('Forcing completely new socket connection');\n        \n        // Disconnect current socket if connected\n        if (connected) {\n          forceClosing = true;\n          socket.disconnect();\n        }\n        \n        // Reset connection options\n        socket.io.opts = {\n          ...socket.io.opts,\n          forceNew: true,\n          transports: ['websocket', 'polling']\n        };\n        \n        // Reset flags\n        forceClosing = false;\n        reconnecting = false;\n        \n        // Register connect handler\n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n          \n          // Re-register after connection\n          socket.emit('register', userId);\n          log(`Re-registered as ${userId} after new connection`);\n          resolve(true);\n        };\n        \n        socket.once('connect', connectHandler);\n        \n        // Attempt connection\n        socket.connect();\n        \n        // Set timeout for connection attempt\n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          log('New connection attempt timed out', 'error');\n          resolve(false);\n        }, 7000);\n      });\n    },\n    \n    /**\n     * Get the logs for debugging\n     * @returns {Array} - Array of log entries\n     */\n    getLogs: () => {\n      try {\n        return JSON.parse(localStorage.getItem('signaling_logs') || '[]');\n      } catch (e) {\n        return [];\n      }\n    },\n    \n    /**\n     * Disconnect from the signaling server\n     */\n    disconnect: () => {\n      if (connected) {\n        log('Explicitly disconnecting from signaling server');\n        forceClosing = true;\n        socket.disconnect();\n        connected = false;\n      }\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}