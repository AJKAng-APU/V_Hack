{"ast":null,"code":"class WebRTCService {\n  constructor() {\n    // Public API: State Checking Methods\n    this.isCallActive = () => ['connecting', 'active'].includes(this.callState);\n    this.isCallConnected = () => this.callState === 'active';\n    this.logger = new WebRTCLogger();\n    this.eventEmitter = new WebRTCEventEmitter();\n    this.errorHandler = new ErrorHandlingService(this.logger);\n    this.mediaManager = new MediaService(this.errorHandler, this.logger);\n    this.signalingService = new SignalingService(this.errorHandler, this.logger);\n    this.connectionManager = null;\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n\n    // Initialization state\n    this.isInitialized = false;\n\n    // Set up error handling\n    this.errorHandler.addListener(this.handleError.bind(this));\n  }\n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n\n  // Public API: Call State Management\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n\n      // Set the state immediately\n      this.callState = newState;\n\n      // Sync the UI immediately\n      this.eventEmitter.emit('callStateChanged', newState);\n\n      // For 'active' state, make extra sure all UI components know about it\n      if (newState === 'active') {\n        // Send additional update after short delay to ensure UI catches it\n        setTimeout(() => {\n          this.logger.log('Re-emitting active state after delay');\n          this.eventEmitter.emit('callStateChanged', 'active');\n\n          // Notify all callbacks\n          if (this.callbacks.onCallStarted) {\n            this.callbacks.onCallStarted();\n          }\n        }, 500);\n      }\n    } else if (newState === 'active') {\n      // Even if already in active state, re-emit to ensure UI sync\n      this.logger.log('Already in active state, but re-emitting to ensure UI sync');\n      this.eventEmitter.emit('callStateChanged', 'active');\n      if (this.callbacks.onCallStarted) {\n        this.callbacks.onCallStarted();\n      }\n    }\n  }\n\n  // Error handling\n  handleError(error) {\n    this.logger.error(`WebRTC error in ${error.context}: ${error.message}`);\n\n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context: error.context,\n      message: error.message,\n      fatal: error.fatal\n    });\n\n    // If it's a fatal error, end the call\n    if (error.fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n\n    // Connect to signaling service\n    this.signalingService.connect(userId, this.handleSignalingEvents.bind(this));\n\n    // Create connection manager - now references the other services\n    this.connectionManager = new ConnectionService(this.signalingService, this.mediaManager, this.eventEmitter, this.errorHandler, this.logger, this.updateCallState.bind(this));\n    this.isInitialized = true;\n  }\n\n  /**\n   * Update callback functions\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n\n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n\n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: this.callbacks.onRemoteStream,\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n\n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined();\n        break;\n      case 'call-in-progress':\n        this.updateCallState('ended');\n        if (this.callbacks.onCallInProgress) {\n          this.callbacks.onCallInProgress(data.callerUserId, data.message);\n        }\n        break;\n      case 'ice-candidate':\n        this.connectionManager.addRemoteIceCandidate(data.candidate);\n        break;\n      case 'media-connected':\n        this.logger.log('Remote peer reports media connected');\n        this.updateCallState('active');\n\n        // Force update UI regardless of previous state\n        if (this.callbacks.onCallStarted) {\n          this.callbacks.onCallStarted();\n        }\n\n        // Ensure connection manager is also updated\n        if (this.connectionManager && this.connectionManager.remoteStream) {\n          this.logger.log('We have remote media and received media-connected signal, enforcing active state');\n          this.updateCallState('active');\n        }\n        break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n\n  /**\n   * Other methods remain similar but would call the appropriate service methods\n   */\n  // ...\n\n  /**\n   * Get access to local camera and microphone\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n\n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      // Error already handled by mediaManager\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n\n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n\n    // Reset initialization status\n    this.isInitialized = false;\n\n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Export a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["WebRTCService","constructor","isCallActive","includes","callState","isCallConnected","logger","WebRTCLogger","eventEmitter","WebRTCEventEmitter","errorHandler","ErrorHandlingService","mediaManager","MediaService","signalingService","SignalingService","connectionManager","userId","targetUserId","isInitialized","addListener","handleError","bind","on","event","callback","updateCallState","newState","log","emit","setTimeout","callbacks","onCallStarted","error","context","message","fatal","endCall","initialize","serverUrl","updateCallbacks","disconnect","connect","handleSignalingEvents","ConnectionService","onLocalStream","onRemoteStream","onCallEnded","onCallConnecting","onIncomingCall","onICEConnectionStateChange","onUserNotOnline","onCallDeclined","onCallInProgress","setCallbacks","data","handleIncomingCall","handleCallAnswered","handleCallDeclined","callerUserId","addRemoteIceCandidate","candidate","remoteStream","handleCallEnded","handleCallFailed","getLocalMedia","videoConstraints","audioConstraints","stream","setLocalStream","checkUserOnline","isConnected","cleanup","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["class WebRTCService {\n  constructor() {\n    this.logger = new WebRTCLogger();\n    this.eventEmitter = new WebRTCEventEmitter();\n    this.errorHandler = new ErrorHandlingService(this.logger);\n    this.mediaManager = new MediaService(this.errorHandler, this.logger);\n    this.signalingService = new SignalingService(this.errorHandler, this.logger);\n    this.connectionManager = null;\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n    \n    // Initialization state\n    this.isInitialized = false;\n    \n    // Set up error handling\n    this.errorHandler.addListener(this.handleError.bind(this));\n  }\n  \n  // Public API: State Checking Methods\n  isCallActive = () => ['connecting', 'active'].includes(this.callState);\n  isCallConnected = () => this.callState === 'active';\n  \n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n  \n  // Public API: Call State Management\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n      \n      // Set the state immediately\n      this.callState = newState;\n      \n      // Sync the UI immediately\n      this.eventEmitter.emit('callStateChanged', newState);\n      \n      // For 'active' state, make extra sure all UI components know about it\n      if (newState === 'active') {\n        // Send additional update after short delay to ensure UI catches it\n        setTimeout(() => {\n          this.logger.log('Re-emitting active state after delay');\n          this.eventEmitter.emit('callStateChanged', 'active');\n          \n          // Notify all callbacks\n          if (this.callbacks.onCallStarted) {\n            this.callbacks.onCallStarted();\n          }\n        }, 500);\n      }\n    } else if (newState === 'active') {\n      // Even if already in active state, re-emit to ensure UI sync\n      this.logger.log('Already in active state, but re-emitting to ensure UI sync');\n      this.eventEmitter.emit('callStateChanged', 'active');\n      \n      if (this.callbacks.onCallStarted) {\n        this.callbacks.onCallStarted();\n      }\n    }\n  }\n  \n  // Error handling\n  handleError(error) {\n    this.logger.error(`WebRTC error in ${error.context}: ${error.message}`);\n    \n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context: error.context,\n      message: error.message,\n      fatal: error.fatal\n    });\n    \n    // If it's a fatal error, end the call\n    if (error.fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    \n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n    \n    // Connect to signaling service\n    this.signalingService.connect(userId, this.handleSignalingEvents.bind(this));\n    \n    // Create connection manager - now references the other services\n    this.connectionManager = new ConnectionService(\n      this.signalingService,\n      this.mediaManager,\n      this.eventEmitter,\n      this.errorHandler,\n      this.logger,\n      this.updateCallState.bind(this)\n    );\n    \n    this.isInitialized = true;\n  }\n  \n  /**\n   * Update callback functions\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n    \n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n    \n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: this.callbacks.onRemoteStream,\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n  \n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined();\n        break;\n      case 'call-in-progress':\n        this.updateCallState('ended');\n        if (this.callbacks.onCallInProgress) {\n          this.callbacks.onCallInProgress(data.callerUserId, data.message);\n        }\n        break;\n      case 'ice-candidate':\n        this.connectionManager.addRemoteIceCandidate(data.candidate);\n        break;\n      case 'media-connected':\n        this.logger.log('Remote peer reports media connected');\n        this.updateCallState('active');\n        \n        // Force update UI regardless of previous state\n        if (this.callbacks.onCallStarted) {\n          this.callbacks.onCallStarted();\n        }\n        \n        // Ensure connection manager is also updated\n        if (this.connectionManager && this.connectionManager.remoteStream) {\n          this.logger.log('We have remote media and received media-connected signal, enforcing active state');\n          this.updateCallState('active');\n        }\n        break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n  \n  /**\n   * Other methods remain similar but would call the appropriate service methods\n   */\n  // ...\n  \n  /**\n   * Get access to local camera and microphone\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n      \n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      \n      return stream;\n    } catch (error) {\n      // Error already handled by mediaManager\n      throw error;\n    }\n  }\n  \n  /**\n   * Check if a user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    \n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n    \n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n    \n    // Reset initialization status\n    this.isInitialized = false;\n    \n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Export a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}