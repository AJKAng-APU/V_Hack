{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // New state to track if we're using demo account\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n\n        // Check Supabase session\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          throw error;\n        }\n        if (session) {\n          // Get user data from users table with doctor information\n          // Use a timeout to prevent hanging queries\n          const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000 // 5 second timeout\n          );\n          if (userData.error) {\n            throw userData.error;\n          }\n\n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n\n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Connect doctor to the socket server\n            console.log(`Connecting doctor ${userData.data.name} to socket server...`);\n\n            // Skip WebRTC for demo accounts - IMPORTANT OPTIMIZATION\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n\n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              console.log('Demo account detected - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n\n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Start tracking performance\n        const startTime = performance.now();\n\n        // Get user data from users table with doctor info\n        const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000 // 5 second timeout\n        );\n        if (!userData.error && userData.data) {\n          // Set up user object with potential doctor info\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n\n          // Check if this is a demo account\n          const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n          setIsDemoAccount(isDemo);\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information for future reference\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Connect doctor to socket server ONLY if not a demo account\n            if (!isDemo) {\n              console.log(`Doctor signed in: ${userData.data.name}`);\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n            }\n          } else {\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Log performance\n          const endTime = performance.now();\n          console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n        }\n      }\n      if (event === 'SIGNED_OUT') {\n        setUser(null);\n        setIsAuthenticated(false);\n        setIsDemoAccount(false);\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        localStorage.setItem('is_doctor', 'false');\n        localStorage.removeItem('doctor_id');\n      }\n    });\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = doctorId => {\n    try {\n      if (!doctorId) return;\n      const doctorSocketId = `doctor-${doctorId}`;\n      console.log(`Initializing WebRTC for doctor: ${doctorSocketId}`);\n\n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks - can be expanded as needed\n        const callbacks = {\n          onIncomingCall: callerId => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n            // Could implement doctor-specific handling here\n          }\n        };\n\n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n\n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          try {\n            if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async email => {\n    try {\n      const {\n        error\n      } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      if (error) throw error;\n      return {\n        success: true,\n        message: 'Verification email sent! Please check your inbox.'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount,\n    // Expose this flag to components\n    signOut,\n    sendVerificationEmail\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: !loading && children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 367,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"aGqb4kBCFhIUwi7TyCaZ+wjjcvI=\");\n_c = AuthProvider;\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","webRTCService","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","isDemoAccount","setIsDemoAccount","checkUser","startTime","performance","now","data","session","error","auth","getSession","userData","fetchWithTimeout","from","select","eq","email","single","userObj","id","user_id","name","isPremium","is_premium","avatar","avatar_url","isDoctor","is_doctor","doctor","doctorId","doctor_id","specialty","doctorAvailability","availability","doctorRating","rating","localStorage","setItem","console","log","toLowerCase","connectDoctorToSocket","removeItem","JSON","stringify","storedAuth","getItem","storedUser","parse","parseInt","replace","endTime","Math","round","message","authListener","onAuthStateChange","event","isDemo","subscription","unsubscribe","promise","timeoutMs","timer","timeoutPromise","Promise","_","reject","setTimeout","Error","result","race","clearTimeout","doctorSocketId","callbacks","onIncomingCall","callerId","initTimeoutId","initialize","err","socketTimeoutId","signalingService","isConnected","send","e","sendVerificationEmail","resend","type","success","signOut","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // New state to track if we're using demo account\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n        \n        // Check Supabase session\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          throw error;\n        }\n        \n        if (session) {\n          // Get user data from users table with doctor information\n          // Use a timeout to prevent hanging queries\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000 // 5 second timeout\n          );\n            \n          if (userData.error) {\n            throw userData.error;\n          }\n          \n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n          \n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n            \n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n            \n            // Connect doctor to the socket server\n            console.log(`Connecting doctor ${userData.data.name} to socket server...`);\n            \n            // Skip WebRTC for demo accounts - IMPORTANT OPTIMIZATION\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          \n          setUser(userObj);\n          setIsAuthenticated(true);\n          \n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          \n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              console.log('Demo account detected - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n        \n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (event === 'SIGNED_IN' && session) {\n          // Start tracking performance\n          const startTime = performance.now();\n          \n          // Get user data from users table with doctor info\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000 // 5 second timeout\n          );\n          \n          if (!userData.error && userData.data) {\n            // Set up user object with potential doctor info\n            const userObj = {\n              id: userData.data.user_id,\n              name: userData.data.name,\n              email: userData.data.email,\n              isPremium: userData.data.is_premium,\n              avatar: userData.data.avatar_url,\n              isDoctor: userData.data.is_doctor || false\n            };\n            \n            // Check if this is a demo account\n            const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || \n                          userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n            \n            setIsDemoAccount(isDemo);\n            \n            if (userData.data.is_doctor && userData.data.doctor) {\n              userObj.doctorId = userData.data.doctor_id;\n              userObj.specialty = userData.data.doctor.specialty;\n              userObj.doctorAvailability = userData.data.doctor.availability;\n              userObj.doctorRating = userData.data.doctor.rating;\n              \n              // Store doctor information for future reference\n              localStorage.setItem('is_doctor', 'true');\n              localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n              \n              // Connect doctor to socket server ONLY if not a demo account\n              if (!isDemo) {\n                console.log(`Doctor signed in: ${userData.data.name}`);\n                connectDoctorToSocket(userData.data.doctor_id);\n              } else {\n                console.log('Demo doctor account - skipping WebRTC initialization');\n              }\n            } else {\n              localStorage.setItem('is_doctor', 'false');\n              localStorage.removeItem('doctor_id');\n            }\n            \n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Store in localStorage\n            localStorage.setItem('healthsync_auth', 'true');\n            localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n            \n            // Log performance\n            const endTime = performance.now();\n            console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n          }\n        }\n        \n        if (event === 'SIGNED_OUT') {\n          setUser(null);\n          setIsAuthenticated(false);\n          setIsDemoAccount(false);\n          localStorage.removeItem('healthsync_auth');\n          localStorage.removeItem('healthsync_user');\n          localStorage.setItem('is_doctor', 'false');\n          localStorage.removeItem('doctor_id');\n        }\n      }\n    );\n\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    \n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = (doctorId) => {\n    try {\n      if (!doctorId) return;\n      \n      const doctorSocketId = `doctor-${doctorId}`;\n      console.log(`Initializing WebRTC for doctor: ${doctorSocketId}`);\n      \n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks - can be expanded as needed\n        const callbacks = {\n          onIncomingCall: (callerId) => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n            // Could implement doctor-specific handling here\n          }\n        };\n        \n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        \n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n        \n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          \n          try {\n            if (webRTCService.signalingService && \n                webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async (email) => {\n    try {\n      const { error } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      \n      if (error) throw error;\n      \n      return { \n        success: true, \n        message: 'Verification email sent! Please check your inbox.' \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error.message \n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount, // Expose this flag to components\n    signOut,\n    sendVerificationEmail\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}