{"ast":null,"code":"import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n\n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.isCallActive = false; // New state to track active calls\n\n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n\n    // Initialization state\n    this.isInitialized = false;\n\n    // Debug flag - set to true to enable more detailed logging\n    this.debug = true;\n  }\n\n  /**\n   * Log with prefix and only if debug is enabled\n   */\n  log(...args) {\n    if (this.debug) {\n      console.log('[WebRTC]', ...args);\n    }\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    this.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Set up callbacks\n    this.updateCallbacks(callbacks);\n\n    // Connect to the signaling server if not already connected\n    if (!this.socket || !this.socket.connected) {\n      // Use provided URL, fallback to production URL, then localhost as last resort\n      const signalingServer = serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001';\n      this.log('Connecting to signaling server:', signalingServer);\n      this.socket = io(signalingServer);\n\n      // Set up event listeners for signaling messages\n      this.setupSocketListeners();\n    }\n\n    // Register user ID with the signaling server\n    if (this.socket) {\n      this.socket.emit('register', userId);\n    }\n    this.isInitialized = true;\n  }\n\n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    // Only update provided callbacks, keep existing ones otherwise\n    if (callbacks.onLocalStream !== undefined) this.onLocalStream = callbacks.onLocalStream;\n    if (callbacks.onRemoteStream !== undefined) this.onRemoteStream = callbacks.onRemoteStream;\n    if (callbacks.onCallStarted !== undefined) this.onCallStarted = callbacks.onCallStarted;\n    if (callbacks.onCallEnded !== undefined) this.onCallEnded = callbacks.onCallEnded;\n    if (callbacks.onCallConnecting !== undefined) this.onCallConnecting = callbacks.onCallConnecting;\n    if (callbacks.onIncomingCall !== undefined) this.onIncomingCall = callbacks.onIncomingCall;\n    if (callbacks.onICEConnectionStateChange !== undefined) this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange;\n\n    // Initialize default callback functions if not already set\n    this.onLocalStream = this.onLocalStream || (stream => {\n      this.log('Default onLocalStream handler, stream:', stream ? 'available' : 'null');\n    });\n    this.onRemoteStream = this.onRemoteStream || (stream => {\n      this.log('Default onRemoteStream handler, stream:', stream ? 'available' : 'null');\n    });\n    this.onCallStarted = this.onCallStarted || (() => {\n      this.log('Default onCallStarted handler');\n    });\n    this.onCallEnded = this.onCallEnded || (() => {\n      this.log('Default onCallEnded handler');\n    });\n    this.onCallConnecting = this.onCallConnecting || (() => {\n      this.log('Default onCallConnecting handler');\n    });\n    this.onIncomingCall = this.onIncomingCall || (callerId => {\n      this.log('Default onIncomingCall handler, caller:', callerId);\n    });\n    this.onICEConnectionStateChange = this.onICEConnectionStateChange || (state => {\n      this.log('Default onICEConnectionStateChange handler, state:', state);\n    });\n  }\n\n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({\n      callerUserId,\n      offerSDP\n    }) => {\n      this.log('Incoming call from:', callerUserId);\n\n      // If there's already an active call, ignore this one\n      if (this.isCallActive) {\n        this.log('Already in a call, ignoring incoming call');\n        return;\n      }\n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n\n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n\n      // Mark call as active to prevent multiple calls\n      this.isCallActive = true;\n\n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n\n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({\n      answerSDP\n    }) => {\n      this.log('Call was answered, setting remote description');\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answerSDP));\n          this.log('Remote description set successfully');\n        } else {\n          this.log('Error: No peer connection when receiving answer');\n        }\n      } catch (error) {\n        console.error('Error setting remote description:', error);\n      }\n    });\n\n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({\n      candidate\n    }) => {\n      try {\n        if (this.peerConnection) {\n          this.log('Adding ICE candidate');\n          await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n          this.log('Added ICE candidate successfully');\n        } else {\n          this.log('Error: No peer connection when receiving ICE candidate');\n        }\n      } catch (error) {\n        console.error('Error adding ICE candidate:', error);\n      }\n    });\n\n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      this.log('Call ended remotely');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n\n    // Handle call failure\n    this.socket.on('call-failed', ({\n      message,\n      targetUserId\n    }) => {\n      console.error('Call failed:', message);\n      this.onCallEnded();\n      this.resetCallState();\n    });\n  }\n\n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // If there's already an active call, end it first\n      if (this.isCallActive) {\n        this.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      this.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.isCallActive = true; // Mark call as active\n      this.onCallConnecting();\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n\n      // Create an offer (SDP)\n      this.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n\n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n\n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      this.log('Call offer sent');\n    } catch (error) {\n      console.error('Error making call:', error);\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      this.log('Accepting incoming call from:', this.targetUserId);\n      this.isCallActive = true; // Mark call as active\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n      if (!this.pendingOffer) {\n        this.log('Error: No pending offer to accept');\n        return;\n      }\n\n      // Set the remote description from the stored offer\n      this.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(new RTCSessionDescription(this.pendingOffer));\n\n      // Create an answer\n      this.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n\n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n\n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      this.log('Call accepted, answer sent');\n      this.onCallConnecting();\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.log('Ending call, notify peer:', notifyPeer);\n\n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      this.socket.emit('end-call', {\n        targetUserId: this.targetUserId\n      });\n    }\n\n    // Close peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n\n    // Mark call as inactive\n    this.isCallActive = false;\n\n    // Trigger callback\n    this.onCallEnded();\n\n    // Reset state\n    this.resetCallState();\n  }\n\n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.isCallActive = false;\n  }\n  initializePeerConnection() {\n    // ICE servers configuration (STUN/TURN)\n    const configuration = {\n      iceServers: [\n      // Google's public STUN server\n      {\n        urls: 'stun:stun.l.google.com:19302'\n      },\n      // Alternative STUN servers in case the first fails\n      {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      },\n      // For production, use your TURN server configuration\n      // Try to get from environment variables if available\n      ...(process.env.REACT_APP_TURN_SERVER ? [{\n        urls: process.env.REACT_APP_TURN_SERVER,\n        username: process.env.REACT_APP_TURN_USERNAME || '',\n        credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n      }] : [])]\n    };\n    this.log('Initializing peer connection with configuration:', configuration);\n\n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    } else {\n      this.log('Warning: No local stream available when initializing peer connection');\n    }\n\n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = event => {\n      this.log('Received remote track:', event.track.kind);\n\n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n\n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        this.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n\n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.log('Generated ICE candidate of type:', event.candidate.type);\n\n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state changes\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      this.log('ICE connection state changed to:', state);\n      this.onICEConnectionStateChange(state);\n\n      // Handle connection establishment\n      if (state === 'connected') {\n        this.log('Call connected successfully!');\n        this.onCallStarted();\n      }\n      // Handle connection failures\n      else if (state === 'disconnected' || state === 'failed' || state === 'closed') {\n        this.log('Connection lost or failed');\n        this.endCall(true);\n      }\n    };\n\n    // Monitor signaling state \n    this.peerConnection.onsignalingstatechange = () => {\n      this.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.log('Connection state changed:', this.peerConnection.connectionState);\n\n      // Additional connection state handling\n      if (this.peerConnection.connectionState === 'connected') {\n        this.log('PeerConnection fully connected!');\n      }\n    };\n  }\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // Define more specific constraints for better compatibility\n      const constraints = {\n        audio: audioConstraints === true ? {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } : audioConstraints,\n        video: videoConstraints === true ? {\n          width: {\n            ideal: 1280,\n            max: 1920\n          },\n          height: {\n            ideal: 720,\n            max: 1080\n          },\n          facingMode: 'user'\n        } : videoConstraints\n      };\n      this.log('Requesting access to local media with constraints:', constraints);\n\n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      this.log('Access to local media granted');\n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n\n      // Try fallback with just audio if video fails\n      if (videoConstraints && error.name === 'NotFoundError') {\n        this.log('Camera not found, trying audio only');\n        try {\n          return await this.getLocalMedia(false, audioConstraints);\n        } catch (audioError) {\n          console.error('Audio-only fallback also failed:', audioError);\n          throw audioError;\n        }\n      }\n      throw error;\n    }\n  }\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    } else {\n      this.log('Cannot toggle audio: No local stream available');\n    }\n  }\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    } else {\n      this.log('Cannot toggle video: No local stream available');\n    }\n  }\n  disconnect() {\n    this.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    // Reset initialization status\n    this.isInitialized = false;\n\n    // Clear user ID\n    this.userId = null;\n  }\n\n  // Check if there's a pending incoming call\n  hasPendingCall() {\n    return this.pendingOffer !== null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["io","WebRTCService","constructor","socket","peerConnection","localStream","remoteStream","userId","targetUserId","isCallInitiator","pendingOffer","isCallActive","onLocalStream","onRemoteStream","onCallStarted","onCallEnded","onCallConnecting","onIncomingCall","onICEConnectionStateChange","isInitialized","debug","log","args","console","initialize","callbacks","serverUrl","updateCallbacks","connected","signalingServer","process","env","REACT_APP_SIGNALING_SERVER","setupSocketListeners","emit","undefined","stream","callerId","state","on","callerUserId","offerSDP","answerSDP","setRemoteDescription","RTCSessionDescription","error","candidate","addIceCandidate","RTCIceCandidate","endCall","message","resetCallState","makeCall","getLocalMedia","initializePeerConnection","offer","createOffer","setLocalDescription","acceptCall","answer","createAnswer","notifyPeer","close","getTracks","forEach","track","kind","stop","configuration","iceServers","urls","REACT_APP_TURN_SERVER","username","REACT_APP_TURN_USERNAME","credential","REACT_APP_TURN_CREDENTIAL","RTCPeerConnection","addTrack","ontrack","event","MediaStream","streams","onicecandidate","type","oniceconnectionstatechange","iceConnectionState","onsignalingstatechange","signalingState","onconnectionstatechange","connectionState","videoConstraints","audioConstraints","constraints","audio","echoCancellation","noiseSuppression","autoGainControl","video","width","ideal","max","height","facingMode","navigator","mediaDevices","getUserMedia","name","audioError","toggleAudio","muted","getAudioTracks","enabled","toggleVideo","videoOff","getVideoTracks","disconnect","hasPendingCall","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n    \n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.isCallActive = false; // New state to track active calls\n    \n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n    \n    // Initialization state\n    this.isInitialized = false;\n    \n    // Debug flag - set to true to enable more detailed logging\n    this.debug = true;\n  }\n  \n  /**\n   * Log with prefix and only if debug is enabled\n   */\n  log(...args) {\n    if (this.debug) {\n      console.log('[WebRTC]', ...args);\n    }\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    this.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Set up callbacks\n    this.updateCallbacks(callbacks);\n    \n    // Connect to the signaling server if not already connected\n    if (!this.socket || !this.socket.connected) {\n      // Use provided URL, fallback to production URL, then localhost as last resort\n      const signalingServer = serverUrl || \n                             (process.env.REACT_APP_SIGNALING_SERVER || \n                              'http://localhost:3001');\n      \n      this.log('Connecting to signaling server:', signalingServer);\n      this.socket = io(signalingServer);\n      \n      // Set up event listeners for signaling messages\n      this.setupSocketListeners();\n    }\n    \n    // Register user ID with the signaling server\n    if (this.socket) {\n      this.socket.emit('register', userId);\n    }\n    \n    this.isInitialized = true;\n  }\n  \n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    // Only update provided callbacks, keep existing ones otherwise\n    if (callbacks.onLocalStream !== undefined) \n      this.onLocalStream = callbacks.onLocalStream;\n    if (callbacks.onRemoteStream !== undefined) \n      this.onRemoteStream = callbacks.onRemoteStream;\n    if (callbacks.onCallStarted !== undefined) \n      this.onCallStarted = callbacks.onCallStarted;\n    if (callbacks.onCallEnded !== undefined) \n      this.onCallEnded = callbacks.onCallEnded;\n    if (callbacks.onCallConnecting !== undefined) \n      this.onCallConnecting = callbacks.onCallConnecting;\n    if (callbacks.onIncomingCall !== undefined) \n      this.onIncomingCall = callbacks.onIncomingCall;\n    if (callbacks.onICEConnectionStateChange !== undefined) \n      this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange;\n    \n    // Initialize default callback functions if not already set\n    this.onLocalStream = this.onLocalStream || ((stream) => { this.log('Default onLocalStream handler, stream:', stream ? 'available' : 'null'); });\n    this.onRemoteStream = this.onRemoteStream || ((stream) => { this.log('Default onRemoteStream handler, stream:', stream ? 'available' : 'null'); });\n    this.onCallStarted = this.onCallStarted || (() => { this.log('Default onCallStarted handler'); });\n    this.onCallEnded = this.onCallEnded || (() => { this.log('Default onCallEnded handler'); });\n    this.onCallConnecting = this.onCallConnecting || (() => { this.log('Default onCallConnecting handler'); });\n    this.onIncomingCall = this.onIncomingCall || ((callerId) => { this.log('Default onIncomingCall handler, caller:', callerId); });\n    this.onICEConnectionStateChange = this.onICEConnectionStateChange || ((state) => { this.log('Default onICEConnectionStateChange handler, state:', state); });\n  }\n  \n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({ callerUserId, offerSDP }) => {\n      this.log('Incoming call from:', callerUserId);\n      \n      // If there's already an active call, ignore this one\n      if (this.isCallActive) {\n        this.log('Already in a call, ignoring incoming call');\n        return;\n      }\n      \n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n      \n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n      \n      // Mark call as active to prevent multiple calls\n      this.isCallActive = true;\n      \n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n    \n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({ answerSDP }) => {\n      this.log('Call was answered, setting remote description');\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(\n            new RTCSessionDescription(answerSDP)\n          );\n          this.log('Remote description set successfully');\n        } else {\n          this.log('Error: No peer connection when receiving answer');\n        }\n      } catch (error) {\n        console.error('Error setting remote description:', error);\n      }\n    });\n    \n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({ candidate }) => {\n      try {\n        if (this.peerConnection) {\n          this.log('Adding ICE candidate');\n          await this.peerConnection.addIceCandidate(\n            new RTCIceCandidate(candidate)\n          );\n          this.log('Added ICE candidate successfully');\n        } else {\n          this.log('Error: No peer connection when receiving ICE candidate');\n        }\n      } catch (error) {\n        console.error('Error adding ICE candidate:', error);\n      }\n    });\n    \n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      this.log('Call ended remotely');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n    \n    // Handle call failure\n    this.socket.on('call-failed', ({ message, targetUserId }) => {\n      console.error('Call failed:', message);\n      this.onCallEnded();\n      this.resetCallState();\n    });\n  }\n  \n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // If there's already an active call, end it first\n      if (this.isCallActive) {\n        this.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      \n      this.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.isCallActive = true; // Mark call as active\n      this.onCallConnecting();\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      // Create an offer (SDP)\n      this.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      \n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      \n      this.log('Call offer sent');\n    } catch (error) {\n      console.error('Error making call:', error);\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      this.log('Accepting incoming call from:', this.targetUserId);\n      this.isCallActive = true; // Mark call as active\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      if (!this.pendingOffer) {\n        this.log('Error: No pending offer to accept');\n        return;\n      }\n      \n      // Set the remote description from the stored offer\n      this.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(\n        new RTCSessionDescription(this.pendingOffer)\n      );\n      \n      // Create an answer\n      this.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n      \n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n      \n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      \n      this.log('Call accepted, answer sent');\n      this.onCallConnecting();\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.log('Ending call, notify peer:', notifyPeer);\n    \n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      this.socket.emit('end-call', { targetUserId: this.targetUserId });\n    }\n    \n    // Close peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    \n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n    \n    // Mark call as inactive\n    this.isCallActive = false;\n    \n    // Trigger callback\n    this.onCallEnded();\n    \n    // Reset state\n    this.resetCallState();\n  }\n  \n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.isCallActive = false;\n  }\n  \n  initializePeerConnection() {\n    // ICE servers configuration (STUN/TURN)\n    const configuration = {\n      iceServers: [\n        // Google's public STUN server\n        { urls: 'stun:stun.l.google.com:19302' },\n        // Alternative STUN servers in case the first fails\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' },\n        // For production, use your TURN server configuration\n        // Try to get from environment variables if available\n        ...(process.env.REACT_APP_TURN_SERVER ? [{\n          urls: process.env.REACT_APP_TURN_SERVER,\n          username: process.env.REACT_APP_TURN_USERNAME || '',\n          credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n        }] : [])\n      ]\n    };\n    \n    this.log('Initializing peer connection with configuration:', configuration);\n    \n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n    \n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    } else {\n      this.log('Warning: No local stream available when initializing peer connection');\n    }\n    \n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = (event) => {\n      this.log('Received remote track:', event.track.kind);\n      \n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n      \n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        this.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n    \n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.log('Generated ICE candidate of type:', event.candidate.type);\n        \n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n    \n    // Monitor connection state changes\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      this.log('ICE connection state changed to:', state);\n      \n      this.onICEConnectionStateChange(state);\n      \n      // Handle connection establishment\n      if (state === 'connected') {\n        this.log('Call connected successfully!');\n        this.onCallStarted();\n      } \n      // Handle connection failures\n      else if (\n        state === 'disconnected' || \n        state === 'failed' ||\n        state === 'closed'\n      ) {\n        this.log('Connection lost or failed');\n        this.endCall(true);\n      }\n    };\n    \n    // Monitor signaling state \n    this.peerConnection.onsignalingstatechange = () => {\n      this.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n    \n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.log('Connection state changed:', this.peerConnection.connectionState);\n      \n      // Additional connection state handling\n      if (this.peerConnection.connectionState === 'connected') {\n        this.log('PeerConnection fully connected!');\n      }\n    };\n  }\n\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // Define more specific constraints for better compatibility\n      const constraints = {\n        audio: audioConstraints === true ? {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } : audioConstraints,\n        video: videoConstraints === true ? {\n          width: { ideal: 1280, max: 1920 },\n          height: { ideal: 720, max: 1080 },\n          facingMode: 'user'\n        } : videoConstraints\n      };\n      \n      this.log('Requesting access to local media with constraints:', constraints);\n      \n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      \n      this.log('Access to local media granted');\n      \n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n      \n      // Try fallback with just audio if video fails\n      if (videoConstraints && error.name === 'NotFoundError') {\n        this.log('Camera not found, trying audio only');\n        try {\n          return await this.getLocalMedia(false, audioConstraints);\n        } catch (audioError) {\n          console.error('Audio-only fallback also failed:', audioError);\n          throw audioError;\n        }\n      }\n      \n      throw error;\n    }\n  }\n  \n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    } else {\n      this.log('Cannot toggle audio: No local stream available');\n    }\n  }\n  \n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    } else {\n      this.log('Cannot toggle video: No local stream available');\n    }\n  }\n  \n  disconnect() {\n    this.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    \n    // Reset initialization status\n    this.isInitialized = false;\n    \n    // Clear user ID\n    this.userId = null;\n  }\n  \n  // Check if there's a pending incoming call\n  hasPendingCall() {\n    return this.pendingOffer !== null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}