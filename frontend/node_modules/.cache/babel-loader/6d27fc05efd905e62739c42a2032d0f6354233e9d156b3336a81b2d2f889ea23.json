{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // New state to track if we're using demo account\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n\n        // Check Supabase session\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          throw error;\n        }\n        if (session) {\n          // Get user data from users table with doctor information\n          // Use a timeout to prevent hanging queries\n          const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000 // 5 second timeout\n          );\n          if (userData.error) {\n            throw userData.error;\n          }\n\n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n\n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Connect doctor to the socket server\n            console.log(`Connecting doctor ${userData.data.name} to socket server...`);\n\n            // Skip WebRTC for demo accounts - IMPORTANT OPTIMIZATION\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n\n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              console.log('Demo account detected - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n\n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Start tracking performance\n        const startTime = performance.now();\n\n        // Get user data from users table with doctor info\n        const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000 // 5 second timeout\n        );\n        if (!userData.error && userData.data) {\n          // Set up user object with potential doctor info\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n\n          // Check if this is a demo account\n          const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n          setIsDemoAccount(isDemo);\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information for future reference\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Connect doctor to socket server ONLY if not a demo account\n            if (!isDemo) {\n              console.log(`Doctor signed in: ${userData.data.name}`);\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n            }\n          } else {\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Log performance\n          const endTime = performance.now();\n          console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n        }\n      }\n      if (event === 'SIGNED_OUT') {\n        setUser(null);\n        setIsAuthenticated(false);\n        setIsDemoAccount(false);\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        localStorage.setItem('is_doctor', 'false');\n        localStorage.removeItem('doctor_id');\n      }\n    });\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = doctorId => {\n    try {\n      if (!doctorId) return;\n      const doctorSocketId = `doctor-${doctorId}`;\n      console.log(`Initializing WebRTC for doctor: ${doctorSocketId}`);\n\n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks - can be expanded as needed\n        const callbacks = {\n          onIncomingCall: callerId => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n            // Could implement doctor-specific handling here\n          }\n        };\n\n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n\n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          try {\n            if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async email => {\n    try {\n      const {\n        error\n      } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      if (error) throw error;\n      return {\n        success: true,\n        message: 'Verification email sent! Please check your inbox.'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // NEW: Two-Factor Authentication methods\n  const enrollMFA = async () => {\n    try {\n      console.log('Checking for existing factors...');\n\n      // First, check if there are existing factors\n      const {\n        data: factorsData,\n        error: factorsError\n      } = await supabase.auth.mfa.listFactors();\n      if (factorsError) {\n        console.error('Error listing factors:', factorsError);\n        throw factorsError;\n      }\n      console.log('Existing factors:', factorsData);\n\n      // Clean up any existing unverified factors to prevent conflicts\n      if (factorsData && factorsData.totp && factorsData.totp.length > 0) {\n        for (const factor of factorsData.totp) {\n          if (!factor.verified) {\n            console.log('Removing unverified factor:', factor.id);\n            await supabase.auth.mfa.unenroll({\n              factorId: factor.id\n            });\n          }\n        }\n      }\n\n      // Now try to enroll with a friendly name\n      console.log('Enrolling in MFA with friendly name...');\n      const {\n        data,\n        error\n      } = await supabase.auth.mfa.enroll({\n        factorType: 'totp',\n        friendlyName: `HealthSync-${Date.now()}` // Add unique friendly name\n      });\n      if (error) throw error;\n      console.log('Enrollment successful:', data);\n      return {\n        success: true,\n        qrCode: data.totp.qr_code,\n        secret: data.totp.secret,\n        factorId: data.id\n      };\n    } catch (error) {\n      console.error('Error enrolling in MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n  const verifyMFA = async (factorId, code) => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.auth.mfa.challenge({\n        factorId: factorId\n      });\n      if (error) throw error;\n\n      // Verify the challenge\n      const {\n        data: verifyData,\n        error: verifyError\n      } = await supabase.auth.mfa.verify({\n        factorId: factorId,\n        challengeId: data.id,\n        code: code\n      });\n      if (verifyError) throw verifyError;\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error verifying MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n  const unenrollMFA = async factorId => {\n    try {\n      const {\n        error\n      } = await supabase.auth.mfa.unenroll({\n        factorId: factorId\n      });\n      if (error) throw error;\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error disabling MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Generate backup codes for account recovery\n  const generateBackupCodes = async userId => {\n    try {\n      // Generate 10 random codes\n      const codes = Array.from({\n        length: 10\n      }, () => Math.random().toString(36).substring(2, 8).toUpperCase());\n\n      // Store the codes in your database (in a real app, you'd hash these)\n      const {\n        error\n      } = await supabase.from('user_backup_codes').upsert(codes.map(code => ({\n        user_id: userId,\n        code: code,\n        used: false\n      })));\n      if (error) throw error;\n      return {\n        success: true,\n        codes\n      };\n    } catch (error) {\n      console.error('Error generating backup codes:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Update user profile method including 2FA status\n  const updateUserProfile = async updates => {\n    try {\n      if (!user) throw new Error('User not authenticated');\n\n      // Update Supabase Auth if email is changing\n      if (updates.email && updates.email !== user.email) {\n        const {\n          error: updateAuthError\n        } = await supabase.auth.updateUser({\n          email: updates.email\n        });\n        if (updateAuthError) throw updateAuthError;\n      }\n\n      // Update database record\n      const dataToUpdate = {};\n      if (updates.name) dataToUpdate.name = updates.name;\n      if (updates.avatar) dataToUpdate.avatar_url = updates.avatar;\n      if (Object.keys(dataToUpdate).length > 0) {\n        const {\n          error: updateError\n        } = await supabase.from('users').update(dataToUpdate).eq('user_id', user.id);\n        if (updateError) throw updateError;\n      }\n\n      // Update user preferences including 2FA status\n      if (updates.twoFactorEnabled !== undefined || updates.factorId) {\n        const {\n          error: updatePrefsError\n        } = await supabase.from('user_preferences').upsert({\n          user_id: user.id,\n          two_factor_enabled: updates.twoFactorEnabled,\n          factor_id: updates.factorId\n        });\n        if (updatePrefsError) throw updatePrefsError;\n      }\n\n      // Update local user state\n      const updatedUser = {\n        ...user\n      };\n      if (updates.name) updatedUser.name = updates.name;\n      if (updates.email) updatedUser.email = updates.email;\n      if (updates.avatar) updatedUser.avatar = updates.avatar;\n      if (updates.twoFactorEnabled !== undefined) updatedUser.twoFactorEnabled = updates.twoFactorEnabled;\n      if (updates.factorId) updatedUser.factorId = updates.factorId;\n      setUser(updatedUser);\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount,\n    signOut,\n    sendVerificationEmail,\n    updateUserProfile,\n    // 2FA methods\n    enrollMFA,\n    verifyMFA,\n    unenrollMFA,\n    generateBackupCodes\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: !loading && children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 550,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"aGqb4kBCFhIUwi7TyCaZ+wjjcvI=\");\n_c = AuthProvider;\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","webRTCService","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","isDemoAccount","setIsDemoAccount","checkUser","startTime","performance","now","data","session","error","auth","getSession","userData","fetchWithTimeout","from","select","eq","email","single","userObj","id","user_id","name","isPremium","is_premium","avatar","avatar_url","isDoctor","is_doctor","doctor","doctorId","doctor_id","specialty","doctorAvailability","availability","doctorRating","rating","localStorage","setItem","console","log","toLowerCase","connectDoctorToSocket","removeItem","JSON","stringify","storedAuth","getItem","storedUser","parse","parseInt","replace","endTime","Math","round","message","authListener","onAuthStateChange","event","isDemo","subscription","unsubscribe","promise","timeoutMs","timer","timeoutPromise","Promise","_","reject","setTimeout","Error","result","race","clearTimeout","doctorSocketId","callbacks","onIncomingCall","callerId","initTimeoutId","initialize","err","socketTimeoutId","signalingService","isConnected","send","e","sendVerificationEmail","resend","type","success","signOut","enrollMFA","factorsData","factorsError","mfa","listFactors","totp","length","factor","verified","unenroll","factorId","enroll","factorType","friendlyName","Date","qrCode","qr_code","secret","verifyMFA","code","challenge","verifyData","verifyError","verify","challengeId","unenrollMFA","generateBackupCodes","userId","codes","Array","random","toString","substring","toUpperCase","upsert","map","used","updateUserProfile","updates","updateAuthError","updateUser","dataToUpdate","Object","keys","updateError","update","twoFactorEnabled","undefined","updatePrefsError","two_factor_enabled","factor_id","updatedUser","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // New state to track if we're using demo account\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n        \n        // Check Supabase session\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          throw error;\n        }\n        \n        if (session) {\n          // Get user data from users table with doctor information\n          // Use a timeout to prevent hanging queries\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000 // 5 second timeout\n          );\n            \n          if (userData.error) {\n            throw userData.error;\n          }\n          \n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false\n          };\n          \n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n            \n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n            \n            // Connect doctor to the socket server\n            console.log(`Connecting doctor ${userData.data.name} to socket server...`);\n            \n            // Skip WebRTC for demo accounts - IMPORTANT OPTIMIZATION\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              console.log('Demo doctor account - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          \n          setUser(userObj);\n          setIsAuthenticated(true);\n          \n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          \n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              console.log('Demo account detected - skipping WebRTC initialization');\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n        \n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (event === 'SIGNED_IN' && session) {\n          // Start tracking performance\n          const startTime = performance.now();\n          \n          // Get user data from users table with doctor info\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000 // 5 second timeout\n          );\n          \n          if (!userData.error && userData.data) {\n            // Set up user object with potential doctor info\n            const userObj = {\n              id: userData.data.user_id,\n              name: userData.data.name,\n              email: userData.data.email,\n              isPremium: userData.data.is_premium,\n              avatar: userData.data.avatar_url,\n              isDoctor: userData.data.is_doctor || false\n            };\n            \n            // Check if this is a demo account\n            const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || \n                          userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n            \n            setIsDemoAccount(isDemo);\n            \n            if (userData.data.is_doctor && userData.data.doctor) {\n              userObj.doctorId = userData.data.doctor_id;\n              userObj.specialty = userData.data.doctor.specialty;\n              userObj.doctorAvailability = userData.data.doctor.availability;\n              userObj.doctorRating = userData.data.doctor.rating;\n              \n              // Store doctor information for future reference\n              localStorage.setItem('is_doctor', 'true');\n              localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n              \n              // Connect doctor to socket server ONLY if not a demo account\n              if (!isDemo) {\n                console.log(`Doctor signed in: ${userData.data.name}`);\n                connectDoctorToSocket(userData.data.doctor_id);\n              } else {\n                console.log('Demo doctor account - skipping WebRTC initialization');\n              }\n            } else {\n              localStorage.setItem('is_doctor', 'false');\n              localStorage.removeItem('doctor_id');\n            }\n            \n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Store in localStorage\n            localStorage.setItem('healthsync_auth', 'true');\n            localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n            \n            // Log performance\n            const endTime = performance.now();\n            console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n          }\n        }\n        \n        if (event === 'SIGNED_OUT') {\n          setUser(null);\n          setIsAuthenticated(false);\n          setIsDemoAccount(false);\n          localStorage.removeItem('healthsync_auth');\n          localStorage.removeItem('healthsync_user');\n          localStorage.setItem('is_doctor', 'false');\n          localStorage.removeItem('doctor_id');\n        }\n      }\n    );\n\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    \n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n  \n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = (doctorId) => {\n    try {\n      if (!doctorId) return;\n      \n      const doctorSocketId = `doctor-${doctorId}`;\n      console.log(`Initializing WebRTC for doctor: ${doctorSocketId}`);\n      \n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks - can be expanded as needed\n        const callbacks = {\n          onIncomingCall: (callerId) => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n            // Could implement doctor-specific handling here\n          }\n        };\n        \n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        \n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n        \n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          \n          try {\n            if (webRTCService.signalingService && \n                webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async (email) => {\n    try {\n      const { error } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      \n      if (error) throw error;\n      \n      return { \n        success: true, \n        message: 'Verification email sent! Please check your inbox.' \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error.message \n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // NEW: Two-Factor Authentication methods\n  const enrollMFA = async () => {\n    try {\n      console.log('Checking for existing factors...');\n      \n      // First, check if there are existing factors\n      const { data: factorsData, error: factorsError } = await supabase.auth.mfa.listFactors();\n      \n      if (factorsError) {\n        console.error('Error listing factors:', factorsError);\n        throw factorsError;\n      }\n      \n      console.log('Existing factors:', factorsData);\n      \n      // Clean up any existing unverified factors to prevent conflicts\n      if (factorsData && factorsData.totp && factorsData.totp.length > 0) {\n        for (const factor of factorsData.totp) {\n          if (!factor.verified) {\n            console.log('Removing unverified factor:', factor.id);\n            await supabase.auth.mfa.unenroll({ factorId: factor.id });\n          }\n        }\n      }\n      \n      // Now try to enroll with a friendly name\n      console.log('Enrolling in MFA with friendly name...');\n      const { data, error } = await supabase.auth.mfa.enroll({\n        factorType: 'totp',\n        friendlyName: `HealthSync-${Date.now()}` // Add unique friendly name\n      });\n      \n      if (error) throw error;\n      \n      console.log('Enrollment successful:', data);\n      \n      return {\n        success: true,\n        qrCode: data.totp.qr_code,\n        secret: data.totp.secret,\n        factorId: data.id\n      };\n    } catch (error) {\n      console.error('Error enrolling in MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  const verifyMFA = async (factorId, code) => {\n    try {\n      const { data, error } = await supabase.auth.mfa.challenge({\n        factorId: factorId\n      });\n      \n      if (error) throw error;\n      \n      // Verify the challenge\n      const { data: verifyData, error: verifyError } = await supabase.auth.mfa.verify({\n        factorId: factorId,\n        challengeId: data.id,\n        code: code\n      });\n      \n      if (verifyError) throw verifyError;\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error verifying MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  const unenrollMFA = async (factorId) => {\n    try {\n      const { error } = await supabase.auth.mfa.unenroll({\n        factorId: factorId\n      });\n      \n      if (error) throw error;\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error disabling MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Generate backup codes for account recovery\n  const generateBackupCodes = async (userId) => {\n    try {\n      // Generate 10 random codes\n      const codes = Array.from({ length: 10 }, () => \n        Math.random().toString(36).substring(2, 8).toUpperCase()\n      );\n      \n      // Store the codes in your database (in a real app, you'd hash these)\n      const { error } = await supabase\n        .from('user_backup_codes')\n        .upsert(\n          codes.map(code => ({\n            user_id: userId,\n            code: code,\n            used: false\n          }))\n        );\n        \n      if (error) throw error;\n      \n      return { success: true, codes };\n    } catch (error) {\n      console.error('Error generating backup codes:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  \n\n  // Update user profile method including 2FA status\n  const updateUserProfile = async (updates) => {\n    try {\n      if (!user) throw new Error('User not authenticated');\n      \n      // Update Supabase Auth if email is changing\n      if (updates.email && updates.email !== user.email) {\n        const { error: updateAuthError } = await supabase.auth.updateUser({\n          email: updates.email\n        });\n        \n        if (updateAuthError) throw updateAuthError;\n      }\n      \n      // Update database record\n      const dataToUpdate = {};\n      if (updates.name) dataToUpdate.name = updates.name;\n      if (updates.avatar) dataToUpdate.avatar_url = updates.avatar;\n      \n      if (Object.keys(dataToUpdate).length > 0) {\n        const { error: updateError } = await supabase\n          .from('users')\n          .update(dataToUpdate)\n          .eq('user_id', user.id);\n          \n        if (updateError) throw updateError;\n      }\n      \n      // Update user preferences including 2FA status\n      if (updates.twoFactorEnabled !== undefined || updates.factorId) {\n        const { error: updatePrefsError } = await supabase\n          .from('user_preferences')\n          .upsert({\n            user_id: user.id,\n            two_factor_enabled: updates.twoFactorEnabled,\n            factor_id: updates.factorId\n          });\n          \n        if (updatePrefsError) throw updatePrefsError;\n      }\n      \n      // Update local user state\n      const updatedUser = { ...user };\n      if (updates.name) updatedUser.name = updates.name;\n      if (updates.email) updatedUser.email = updates.email;\n      if (updates.avatar) updatedUser.avatar = updates.avatar;\n      if (updates.twoFactorEnabled !== undefined) updatedUser.twoFactorEnabled = updates.twoFactorEnabled;\n      if (updates.factorId) updatedUser.factorId = updates.factorId;\n      \n      setUser(updatedUser);\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount,\n    signOut,\n    sendVerificationEmail,\n    updateUserProfile,\n    // 2FA methods\n    enrollMFA,\n    verifyMFA,\n    unenrollMFA,\n    generateBackupCodes\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}