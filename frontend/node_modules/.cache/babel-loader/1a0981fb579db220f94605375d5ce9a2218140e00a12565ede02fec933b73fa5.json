{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/VideoCallScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport VideoDisplay from './VideoDisplay';\nimport CallHeader from './CallHeader';\nimport CallControls from './CallControls';\nimport ConnectionStatus from './ConnectionStatus';\nimport ConnectingState from './ConnectingState';\nimport EndedState from './EndedState';\nimport webRTCService from '../services/WebRTC/WebRTCService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCall = ({\n  doctor,\n  callState,\n  onEndCall,\n  colors,\n  isDarkMode\n}) => {\n  _s();\n  // UI state\n  const [showControls, setShowControls] = useState(true);\n  const [callDuration, setCallDuration] = useState(0);\n  const [connectionQuality, setConnectionQuality] = useState('good');\n  const [reconnectAttempt, setReconnectAttempt] = useState(0);\n\n  // Media state\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const [isSpeakerOff, setIsSpeakerOff] = useState(false);\n\n  // Video refs\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n\n  // Duration timer\n  const durationTimerRef = useRef(null);\n\n  // Control auto-hide timer\n  const controlsTimerRef = useRef(null);\n  useEffect(() => {\n    // Initialize camera - THIS IS CRITICAL\n    const initializeMedia = async () => {\n      try {\n        console.log('Initializing media for video call');\n\n        // Get camera access BEFORE call setup\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n        console.log('Successfully obtained local stream with tracks:', stream.getTracks().map(t => `${t.kind}:${t.readyState}`).join(', '));\n\n        // Directly set to video element for immediate display\n        if (localVideoRef.current) {\n          localVideoRef.current.srcObject = stream;\n          localVideoRef.current.play().catch(e => console.error('Failed to play video:', e));\n        }\n\n        // Store for debugging\n        window.myLocalStream = stream;\n\n        // Ensure video is turned on\n        setIsVideoOff(false);\n\n        // Set up callbacks\n        webRTCService.updateCallbacks({\n          onLocalStream: stream => {\n            console.log('Local stream callback received');\n\n            // This is crucial - directly attach stream to video element\n            if (localVideoRef.current) {\n              localVideoRef.current.srcObject = stream;\n            }\n          },\n          onRemoteStream: stream => {\n            console.log('Remote stream callback received');\n            if (remoteVideoRef.current) {\n              remoteVideoRef.current.srcObject = stream;\n            }\n          },\n          onICEConnectionStateChange: state => {\n            console.log('ICE connection state changed:', state);\n            if (state === 'checking' || state === 'disconnected') {\n              setConnectionQuality('poor');\n            } else if (state === 'failed') {\n              setConnectionQuality('unstable');\n              setReconnectAttempt(prev => prev + 1);\n            } else if (state === 'connected' || state === 'completed') {\n              setConnectionQuality('good');\n            }\n          }\n        });\n\n        // If webRTCService is already initialized, update its stream\n        if (webRTCService.mediaManager) {\n          webRTCService.mediaManager.setLocalStream(stream);\n        }\n      } catch (error) {\n        console.error('Error initializing media:', error);\n        alert('Failed to access camera: ' + error.message);\n      }\n    };\n    initializeMedia();\n\n    // Setup auto-hide for controls\n    const setupControlsAutoHide = () => {\n      if (controlsTimerRef.current) {\n        clearTimeout(controlsTimerRef.current);\n      }\n      controlsTimerRef.current = setTimeout(() => {\n        setShowControls(false);\n      }, 5000);\n    };\n\n    // Start call duration timer\n    if (callState === 'active') {\n      durationTimerRef.current = setInterval(() => {\n        setCallDuration(prev => prev + 1);\n      }, 1000);\n      setupControlsAutoHide();\n    }\n\n    // Handle mousemove to show controls\n    const handleMouseMove = () => {\n      setShowControls(true);\n      setupControlsAutoHide();\n    };\n    document.addEventListener('mousemove', handleMouseMove);\n\n    // Cleanup\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      if (durationTimerRef.current) {\n        clearInterval(durationTimerRef.current);\n      }\n      if (controlsTimerRef.current) {\n        clearTimeout(controlsTimerRef.current);\n      }\n    };\n  }, [callState]);\n\n  // Handle media controls\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager) {\n      webRTCService.mediaManager.toggleAudio(isMuted);\n    }\n  }, [isMuted]);\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager) {\n      webRTCService.mediaManager.toggleVideo(isVideoOff);\n    }\n  }, [isVideoOff]);\n\n  // Format time for display\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n\n  // Render appropriate state\n  if (callState === 'connecting') {\n    return /*#__PURE__*/_jsxDEV(ConnectingState, {\n      doctor: doctor,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 12\n    }, this);\n  }\n  if (callState === 'ended') {\n    return /*#__PURE__*/_jsxDEV(EndedState, {\n      callDuration: callDuration,\n      formatTime: formatTime,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 174,\n      columnNumber: 12\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"relative h-full\",\n    onClick: () => setShowControls(true),\n    children: [/*#__PURE__*/_jsxDEV(VideoDisplay, {\n      remoteVideoRef: remoteVideoRef,\n      localVideoRef: localVideoRef,\n      isSpeakerOff: isSpeakerOff,\n      isVideoOff: isVideoOff,\n      doctor: doctor,\n      connectionQuality: connectionQuality,\n      reconnectAttempt: reconnectAttempt,\n      showControls: showControls,\n      isDarkMode: isDarkMode,\n      colors: colors,\n      children: [/*#__PURE__*/_jsxDEV(CallHeader, {\n        doctor: doctor,\n        callDuration: callDuration,\n        formatTime: formatTime,\n        showControls: showControls\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ConnectionStatus, {\n        connectionQuality: connectionQuality,\n        showControls: showControls\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 203,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CallControls, {\n      isMuted: isMuted,\n      setIsMuted: setIsMuted,\n      isVideoOff: isVideoOff,\n      setIsVideoOff: setIsVideoOff,\n      isSpeakerOff: isSpeakerOff,\n      setIsSpeakerOff: setIsSpeakerOff,\n      handleEndCall: onEndCall,\n      showControls: showControls,\n      colors: colors,\n      callStatus: callState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 183,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCall, \"4/0MULw8aAYYH5f6RbFqK+Jdwsw=\");\n_c = VideoCall;\nexport default VideoCall;\nvar _c;\n$RefreshReg$(_c, \"VideoCall\");","map":{"version":3,"names":["React","useState","useEffect","useRef","VideoDisplay","CallHeader","CallControls","ConnectionStatus","ConnectingState","EndedState","webRTCService","jsxDEV","_jsxDEV","VideoCall","doctor","callState","onEndCall","colors","isDarkMode","_s","showControls","setShowControls","callDuration","setCallDuration","connectionQuality","setConnectionQuality","reconnectAttempt","setReconnectAttempt","isMuted","setIsMuted","isVideoOff","setIsVideoOff","isSpeakerOff","setIsSpeakerOff","localVideoRef","remoteVideoRef","durationTimerRef","controlsTimerRef","initializeMedia","console","log","stream","navigator","mediaDevices","getUserMedia","video","audio","getTracks","map","t","kind","readyState","join","current","srcObject","play","catch","e","error","window","myLocalStream","updateCallbacks","onLocalStream","onRemoteStream","onICEConnectionStateChange","state","prev","mediaManager","setLocalStream","alert","message","setupControlsAutoHide","clearTimeout","setTimeout","setInterval","handleMouseMove","document","addEventListener","removeEventListener","clearInterval","toggleAudio","toggleVideo","formatTime","seconds","mins","Math","floor","secs","fileName","_jsxFileName","lineNumber","columnNumber","className","onClick","children","handleEndCall","callStatus","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/VideoCallScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport VideoDisplay from './VideoDisplay';\nimport CallHeader from './CallHeader';\nimport CallControls from './CallControls';\nimport ConnectionStatus from './ConnectionStatus';\nimport ConnectingState from './ConnectingState';\nimport EndedState from './EndedState';\nimport webRTCService from '../services/WebRTC/WebRTCService';\n\nconst VideoCall = ({ \n  doctor,\n  callState,\n  onEndCall,\n  colors,\n  isDarkMode\n}) => {\n  // UI state\n  const [showControls, setShowControls] = useState(true);\n  const [callDuration, setCallDuration] = useState(0);\n  const [connectionQuality, setConnectionQuality] = useState('good');\n  const [reconnectAttempt, setReconnectAttempt] = useState(0);\n  \n  // Media state\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const [isSpeakerOff, setIsSpeakerOff] = useState(false);\n  \n  // Video refs\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  \n  // Duration timer\n  const durationTimerRef = useRef(null);\n  \n  // Control auto-hide timer\n  const controlsTimerRef = useRef(null);\n  \n  useEffect(() => {\n    // Initialize camera - THIS IS CRITICAL\n    const initializeMedia = async () => {\n      try {\n        console.log('Initializing media for video call');\n        \n        // Get camera access BEFORE call setup\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n        \n        console.log('Successfully obtained local stream with tracks:', \n          stream.getTracks().map(t => `${t.kind}:${t.readyState}`).join(', '));\n        \n        // Directly set to video element for immediate display\n        if (localVideoRef.current) {\n          localVideoRef.current.srcObject = stream;\n          localVideoRef.current.play().catch(e => console.error('Failed to play video:', e));\n        }\n        \n        // Store for debugging\n        window.myLocalStream = stream;\n        \n        // Ensure video is turned on\n        setIsVideoOff(false);\n        \n        // Set up callbacks\n        webRTCService.updateCallbacks({\n          onLocalStream: (stream) => {\n            console.log('Local stream callback received');\n            \n            // This is crucial - directly attach stream to video element\n            if (localVideoRef.current) {\n              localVideoRef.current.srcObject = stream;\n            }\n          },\n          onRemoteStream: (stream) => {\n            console.log('Remote stream callback received');\n            if (remoteVideoRef.current) {\n              remoteVideoRef.current.srcObject = stream;\n            }\n          },\n          onICEConnectionStateChange: (state) => {\n            console.log('ICE connection state changed:', state);\n            if (state === 'checking' || state === 'disconnected') {\n              setConnectionQuality('poor');\n            } else if (state === 'failed') {\n              setConnectionQuality('unstable');\n              setReconnectAttempt(prev => prev + 1);\n            } else if (state === 'connected' || state === 'completed') {\n              setConnectionQuality('good');\n            }\n          }\n        });\n        \n        // If webRTCService is already initialized, update its stream\n        if (webRTCService.mediaManager) {\n          webRTCService.mediaManager.setLocalStream(stream);\n        }\n      } catch (error) {\n        console.error('Error initializing media:', error);\n        alert('Failed to access camera: ' + error.message);\n      }\n    };\n    \n    initializeMedia();\n    \n    // Setup auto-hide for controls\n    const setupControlsAutoHide = () => {\n      if (controlsTimerRef.current) {\n        clearTimeout(controlsTimerRef.current);\n      }\n      \n      controlsTimerRef.current = setTimeout(() => {\n        setShowControls(false);\n      }, 5000);\n    };\n    \n    // Start call duration timer\n    if (callState === 'active') {\n      durationTimerRef.current = setInterval(() => {\n        setCallDuration(prev => prev + 1);\n      }, 1000);\n      \n      setupControlsAutoHide();\n    }\n    \n    // Handle mousemove to show controls\n    const handleMouseMove = () => {\n      setShowControls(true);\n      setupControlsAutoHide();\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    \n    // Cleanup\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      \n      if (durationTimerRef.current) {\n        clearInterval(durationTimerRef.current);\n      }\n      \n      if (controlsTimerRef.current) {\n        clearTimeout(controlsTimerRef.current);\n      }\n    };\n  }, [callState]);\n  \n  // Handle media controls\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager) {\n      webRTCService.mediaManager.toggleAudio(isMuted);\n    }\n  }, [isMuted]);\n  \n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager) {\n      webRTCService.mediaManager.toggleVideo(isVideoOff);\n    }\n  }, [isVideoOff]);\n  \n  // Format time for display\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n  \n  // Render appropriate state\n  if (callState === 'connecting') {\n    return <ConnectingState doctor={doctor} colors={colors} />;\n  }\n  \n  if (callState === 'ended') {\n    return <EndedState \n      callDuration={callDuration} \n      formatTime={formatTime} \n      colors={colors} \n      isDarkMode={isDarkMode} \n    />;\n  }\n  \n  return (\n    <div className=\"relative h-full\" onClick={() => setShowControls(true)}>\n      <VideoDisplay\n        remoteVideoRef={remoteVideoRef}\n        localVideoRef={localVideoRef}\n        isSpeakerOff={isSpeakerOff}\n        isVideoOff={isVideoOff}\n        doctor={doctor}\n        connectionQuality={connectionQuality}\n        reconnectAttempt={reconnectAttempt}\n        showControls={showControls}\n        isDarkMode={isDarkMode}\n        colors={colors}\n      >\n        <CallHeader \n          doctor={doctor}\n          callDuration={callDuration}\n          formatTime={formatTime}\n          showControls={showControls}\n        />\n        \n        <ConnectionStatus \n          connectionQuality={connectionQuality}\n          showControls={showControls}\n        />\n      </VideoDisplay>\n      \n      <CallControls\n        isMuted={isMuted}\n        setIsMuted={setIsMuted}\n        isVideoOff={isVideoOff}\n        setIsVideoOff={setIsVideoOff}\n        isSpeakerOff={isSpeakerOff}\n        setIsSpeakerOff={setIsSpeakerOff}\n        handleEndCall={onEndCall}\n        showControls={showControls}\n        colors={colors}\n        callStatus={callState}\n      />\n    </div>\n  );\n};\n\nexport default VideoCall;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}