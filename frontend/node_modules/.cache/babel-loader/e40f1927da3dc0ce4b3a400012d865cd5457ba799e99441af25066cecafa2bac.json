{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userPreferences, setUserPreferences] = useState({\n    notifications: true,\n    reminders: true,\n    biometrics: true,\n    darkMode: false,\n    dataSharing: false\n  });\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Check Supabase session\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          throw error;\n        }\n        if (session) {\n          // Get user data from users table\n          const {\n            data: userData,\n            error: userError\n          } = await supabase.from('users').select('*').eq('email', session.user.email).single();\n          if (userError) {\n            throw userError;\n          }\n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          if (storedAuth === 'true' && storedUser) {\n            const parsedUser = JSON.parse(storedUser);\n            setUser(parsedUser);\n            setIsAuthenticated(true);\n\n            // Try to fetch preferences if we have a user ID\n            if (parsedUser.id) {\n              await fetchUserPreferences(parsedUser.id);\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Get user data from users table\n        const {\n          data: userData,\n          error: userError\n        } = await supabase.from('users').select('*').eq('email', session.user.email).single();\n        if (!userError && userData) {\n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n        }\n      }\n      if (event === 'SIGNED_OUT') {\n        setUser(null);\n        setIsAuthenticated(false);\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n\n        // Reset preferences to defaults\n        setUserPreferences({\n          notifications: true,\n          reminders: true,\n          biometrics: true,\n          darkMode: false,\n          dataSharing: false\n        });\n      }\n    });\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Fetch user preferences from the database\n  const fetchUserPreferences = async userId => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('user_preferences').select('*').eq('user_id', userId).single();\n      if (error) {\n        console.error('Error fetching preferences:', error);\n        return;\n      }\n      if (data) {\n        // Update preferences state\n        setUserPreferences({\n          notifications: data.enable_notifications,\n          reminders: data.enable_reminders,\n          biometrics: data.enable_biometrics,\n          darkMode: data.enable_dark_mode,\n          dataSharing: data.enable_data_sharing\n        });\n\n        // Also update localStorage for dark mode to persist theme\n        localStorage.setItem('healthsync_darkmode', data.enable_dark_mode);\n      }\n    } catch (error) {\n      console.error('Error in fetchUserPreferences:', error);\n    }\n  };\n\n  // Update user preferences in the database\n  const updateUserPreferences = async preferences => {\n    if (!(user !== null && user !== void 0 && user.id)) return {\n      success: false,\n      error: 'Not authenticated'\n    };\n    try {\n      // Check if preferences record exists\n      const {\n        data: existingPrefs\n      } = await supabase.from('user_preferences').select('user_preferences_id').eq('user_id', user.id).single();\n\n      // Prepare preferences data\n      const prefsData = {\n        user_id: user.id,\n        enable_notifications: preferences.notifications,\n        enable_reminders: preferences.reminders,\n        enable_biometrics: preferences.biometrics,\n        enable_dark_mode: preferences.darkMode,\n        enable_data_sharing: preferences.dataSharing,\n        updated_at: new Date().toISOString()\n      };\n\n      // Update or insert preferences\n      if (existingPrefs) {\n        const {\n          error\n        } = await supabase.from('user_preferences').update(prefsData).eq('user_id', user.id);\n        if (error) throw error;\n      } else {\n        const {\n          error\n        } = await supabase.from('user_preferences').insert([prefsData]);\n        if (error) throw error;\n      }\n\n      // Update local state\n      setUserPreferences(preferences);\n\n      // Update localStorage for dark mode\n      localStorage.setItem('healthsync_darkmode', preferences.darkMode);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating preferences:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Send verification email for unverified accounts\n  const sendVerificationEmail = async email => {\n    try {\n      const {\n        error\n      } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      if (error) {\n        return {\n          success: false,\n          error: error.message\n        };\n      }\n      return {\n        success: true,\n        message: 'Verification email sent! Please check your inbox (and spam folder).'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      setUser(null);\n      setIsAuthenticated(false);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    signOut,\n    sendVerificationEmail,\n    userPreferences,\n    updateUserPreferences\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: !loading && children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 288,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"kWftcY2Yjwg9Eu0dwcjpzHmZgCg=\");\n_c = AuthProvider;\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","userPreferences","setUserPreferences","notifications","reminders","biometrics","darkMode","dataSharing","checkUser","data","session","error","auth","getSession","userData","userError","from","select","eq","email","single","userObj","id","user_id","name","isPremium","is_premium","avatar","avatar_url","localStorage","setItem","JSON","stringify","fetchUserPreferences","storedAuth","getItem","storedUser","parsedUser","parse","console","message","removeItem","authListener","onAuthStateChange","event","subscription","unsubscribe","userId","enable_notifications","enable_reminders","enable_biometrics","enable_dark_mode","enable_data_sharing","updateUserPreferences","preferences","success","existingPrefs","prefsData","updated_at","Date","toISOString","update","insert","sendVerificationEmail","resend","type","signOut","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\n\n// Create auth context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userPreferences, setUserPreferences] = useState({\n    notifications: true,\n    reminders: true,\n    biometrics: true,\n    darkMode: false,\n    dataSharing: false\n  });\n\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Check Supabase session\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          throw error;\n        }\n        \n        if (session) {\n          // Get user data from users table\n          const { data: userData, error: userError } = await supabase\n            .from('users')\n            .select('*')\n            .eq('email', session.user.email)\n            .single();\n            \n          if (userError) {\n            throw userError;\n          }\n          \n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          \n          setUser(userObj);\n          setIsAuthenticated(true);\n          \n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n          \n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n          \n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          \n          if (storedAuth === 'true' && storedUser) {\n            const parsedUser = JSON.parse(storedUser);\n            setUser(parsedUser);\n            setIsAuthenticated(true);\n            \n            // Try to fetch preferences if we have a user ID\n            if (parsedUser.id) {\n              await fetchUserPreferences(parsedUser.id);\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (event === 'SIGNED_IN' && session) {\n          // Get user data from users table\n          const { data: userData, error: userError } = await supabase\n            .from('users')\n            .select('*')\n            .eq('email', session.user.email)\n            .single();\n            \n          if (!userError && userData) {\n            const userObj = {\n              id: userData.user_id,\n              name: userData.name,\n              email: userData.email,\n              isPremium: userData.is_premium,\n              avatar: userData.avatar_url\n            };\n            \n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Store in localStorage\n            localStorage.setItem('healthsync_auth', 'true');\n            localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n            \n            // Fetch user preferences\n            await fetchUserPreferences(userData.user_id);\n          }\n        }\n        \n        if (event === 'SIGNED_OUT') {\n          setUser(null);\n          setIsAuthenticated(false);\n          localStorage.removeItem('healthsync_auth');\n          localStorage.removeItem('healthsync_user');\n          \n          // Reset preferences to defaults\n          setUserPreferences({\n            notifications: true,\n            reminders: true,\n            biometrics: true,\n            darkMode: false,\n            dataSharing: false\n          });\n        }\n      }\n    );\n\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Fetch user preferences from the database\n  const fetchUserPreferences = async (userId) => {\n    try {\n      const { data, error } = await supabase\n        .from('user_preferences')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n      \n      if (error) {\n        console.error('Error fetching preferences:', error);\n        return;\n      }\n      \n      if (data) {\n        // Update preferences state\n        setUserPreferences({\n          notifications: data.enable_notifications,\n          reminders: data.enable_reminders,\n          biometrics: data.enable_biometrics,\n          darkMode: data.enable_dark_mode,\n          dataSharing: data.enable_data_sharing\n        });\n        \n        // Also update localStorage for dark mode to persist theme\n        localStorage.setItem('healthsync_darkmode', data.enable_dark_mode);\n      }\n    } catch (error) {\n      console.error('Error in fetchUserPreferences:', error);\n    }\n  };\n\n  // Update user preferences in the database\n  const updateUserPreferences = async (preferences) => {\n    if (!user?.id) return { success: false, error: 'Not authenticated' };\n    \n    try {\n      // Check if preferences record exists\n      const { data: existingPrefs } = await supabase\n        .from('user_preferences')\n        .select('user_preferences_id')\n        .eq('user_id', user.id)\n        .single();\n      \n      // Prepare preferences data\n      const prefsData = {\n        user_id: user.id,\n        enable_notifications: preferences.notifications,\n        enable_reminders: preferences.reminders,\n        enable_biometrics: preferences.biometrics,\n        enable_dark_mode: preferences.darkMode,\n        enable_data_sharing: preferences.dataSharing,\n        updated_at: new Date().toISOString()\n      };\n      \n      // Update or insert preferences\n      if (existingPrefs) {\n        const { error } = await supabase\n          .from('user_preferences')\n          .update(prefsData)\n          .eq('user_id', user.id);\n          \n        if (error) throw error;\n      } else {\n        const { error } = await supabase\n          .from('user_preferences')\n          .insert([prefsData]);\n          \n        if (error) throw error;\n      }\n      \n      // Update local state\n      setUserPreferences(preferences);\n      \n      // Update localStorage for dark mode\n      localStorage.setItem('healthsync_darkmode', preferences.darkMode);\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error updating preferences:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Send verification email for unverified accounts\n  const sendVerificationEmail = async (email) => {\n    try {\n      const { error } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      \n      if (error) {\n        return { success: false, error: error.message };\n      }\n      \n      return { \n        success: true, \n        message: 'Verification email sent! Please check your inbox (and spam folder).' \n      };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      setUser(null);\n      setIsAuthenticated(false);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    signOut,\n    sendVerificationEmail,\n    userPreferences,\n    updateUserPreferences\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}