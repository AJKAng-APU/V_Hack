{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userPreferences, setUserPreferences] = useState({\n    notifications: true,\n    reminders: true,\n    biometrics: true,\n    darkMode: false,\n    dataSharing: false\n  });\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Check Supabase session\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          throw error;\n        }\n        if (session) {\n          // Get user data from users table\n          const {\n            data: userData,\n            error: userError\n          } = await supabase.from('users').select('*').eq('email', session.user.email).single();\n          if (userError) {\n            throw userError;\n          }\n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          if (storedAuth === 'true' && storedUser) {\n            const parsedUser = JSON.parse(storedUser);\n            setUser(parsedUser);\n            setIsAuthenticated(true);\n\n            // Try to fetch preferences if we have a user ID\n            if (parsedUser.id) {\n              await fetchUserPreferences(parsedUser.id);\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Get user data from users table\n        const {\n          data: userData,\n          error: userError\n        } = await supabase.from('users').select('*').eq('email', session.user.email).single();\n        if (!userError && userData) {\n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n        }\n      }\n      if (event === 'SIGNED_OUT') {\n        setUser(null);\n        setIsAuthenticated(false);\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n\n        // Reset preferences to defaults\n        setUserPreferences({\n          notifications: true,\n          reminders: true,\n          biometrics: true,\n          darkMode: false,\n          dataSharing: false\n        });\n      }\n    });\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Update user profile data (name, avatar, etc)\n  const updateUserProfile = async profileData => {\n    if (!(user !== null && user !== void 0 && user.id)) return {\n      success: false,\n      error: 'Not authenticated'\n    };\n    try {\n      // Update user in database\n      const updateData = {};\n      if (profileData.name) updateData.name = profileData.name;\n      if (profileData.avatar) updateData.avatar_url = profileData.avatar;\n\n      // Only proceed if we have data to update\n      if (Object.keys(updateData).length === 0) {\n        return {\n          success: true,\n          message: 'No changes to update'\n        };\n      }\n      const {\n        error\n      } = await supabase.from('users').update(updateData).eq('user_id', user.id);\n      if (error) throw error;\n\n      // Update local user state\n      const updatedUser = {\n        ...user,\n        name: profileData.name || user.name,\n        avatar: profileData.avatar || user.avatar\n      };\n      setUser(updatedUser);\n\n      // Update localStorage\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Fetch user preferences from the database\n  const fetchUserPreferences = async userId => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('user_preferences').select('*').eq('user_id', userId).single();\n      if (error) {\n        console.error('Error fetching preferences:', error);\n        return;\n      }\n      if (data) {\n        // Update preferences state\n        setUserPreferences({\n          notifications: data.enable_notifications,\n          reminders: data.enable_reminders,\n          biometrics: data.enable_biometrics,\n          darkMode: data.enable_dark_mode,\n          dataSharing: data.enable_data_sharing\n        });\n\n        // Also update localStorage for dark mode to persist theme\n        localStorage.setItem('healthsync_darkmode', data.enable_dark_mode);\n      }\n    } catch (error) {\n      console.error('Error in fetchUserPreferences:', error);\n    }\n  };\n\n  // Update user preferences in the database\n  const updateUserPreferences = async preferences => {\n    if (!(user !== null && user !== void 0 && user.id)) return {\n      success: false,\n      error: 'Not authenticated'\n    };\n    try {\n      // Check if preferences record exists\n      const {\n        data: existingPrefs\n      } = await supabase.from('user_preferences').select('user_preferences_id').eq('user_id', user.id).single();\n\n      // Prepare preferences data\n      const prefsData = {\n        user_id: user.id,\n        enable_notifications: preferences.notifications,\n        enable_reminders: preferences.reminders,\n        enable_biometrics: preferences.biometrics,\n        enable_dark_mode: preferences.darkMode,\n        enable_data_sharing: preferences.dataSharing,\n        updated_at: new Date().toISOString()\n      };\n\n      // Update or insert preferences\n      if (existingPrefs) {\n        const {\n          error\n        } = await supabase.from('user_preferences').update(prefsData).eq('user_id', user.id);\n        if (error) throw error;\n      } else {\n        const {\n          error\n        } = await supabase.from('user_preferences').insert([prefsData]);\n        if (error) throw error;\n      }\n\n      // Update local state\n      setUserPreferences(preferences);\n\n      // Update localStorage for dark mode\n      localStorage.setItem('healthsync_darkmode', preferences.darkMode);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating preferences:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Function to create a storage bucket if it doesn't exist\n  const initializeStorage = async () => {\n    try {\n      // Check if avatars bucket exists, if not create it\n      const {\n        data: buckets\n      } = await supabase.storage.listBuckets();\n      if (!buckets.find(bucket => bucket.name === 'avatars')) {\n        const {\n          error\n        } = await supabase.storage.createBucket('avatars', {\n          public: true,\n          fileSizeLimit: 2097152,\n          // 2MB in bytes\n          allowedMimeTypes: ['image/png', 'image/jpeg', 'image/gif']\n        });\n        if (error) {\n          console.error('Error creating avatars bucket:', error);\n        }\n      }\n    } catch (error) {\n      console.error('Error initializing storage:', error);\n    }\n  };\n\n  // Initialize storage on load\n  useEffect(() => {\n    if (isAuthenticated) {\n      initializeStorage();\n    }\n  }, [isAuthenticated]);\n\n  // Send verification email for unverified accounts\n  const sendVerificationEmail = async email => {\n    try {\n      const {\n        error\n      } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      if (error) {\n        return {\n          success: false,\n          error: error.message\n        };\n      }\n      return {\n        success: true,\n        message: 'Verification email sent! Please check your inbox (and spam folder).'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      setUser(null);\n      setIsAuthenticated(false);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    signOut,\n    sendVerificationEmail,\n    userPreferences,\n    updateUserPreferences,\n    updateUserProfile\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: !loading && children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 360,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"C/Zmkoz9WzHBwglrFgw3+3YMhHw=\");\n_c = AuthProvider;\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","userPreferences","setUserPreferences","notifications","reminders","biometrics","darkMode","dataSharing","checkUser","data","session","error","auth","getSession","userData","userError","from","select","eq","email","single","userObj","id","user_id","name","isPremium","is_premium","avatar","avatar_url","localStorage","setItem","JSON","stringify","fetchUserPreferences","storedAuth","getItem","storedUser","parsedUser","parse","console","message","removeItem","authListener","onAuthStateChange","event","subscription","unsubscribe","updateUserProfile","profileData","success","updateData","Object","keys","length","update","updatedUser","userId","enable_notifications","enable_reminders","enable_biometrics","enable_dark_mode","enable_data_sharing","updateUserPreferences","preferences","existingPrefs","prefsData","updated_at","Date","toISOString","insert","initializeStorage","buckets","storage","listBuckets","find","bucket","createBucket","public","fileSizeLimit","allowedMimeTypes","sendVerificationEmail","resend","type","signOut","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\n\n// Create auth context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userPreferences, setUserPreferences] = useState({\n    notifications: true,\n    reminders: true,\n    biometrics: true,\n    darkMode: false,\n    dataSharing: false\n  });\n\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Check Supabase session\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          throw error;\n        }\n        \n        if (session) {\n          // Get user data from users table\n          const { data: userData, error: userError } = await supabase\n            .from('users')\n            .select('*')\n            .eq('email', session.user.email)\n            .single();\n            \n          if (userError) {\n            throw userError;\n          }\n          \n          const userObj = {\n            id: userData.user_id,\n            name: userData.name,\n            email: userData.email,\n            isPremium: userData.is_premium,\n            avatar: userData.avatar_url\n          };\n          \n          setUser(userObj);\n          setIsAuthenticated(true);\n          \n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n          \n          // Fetch user preferences\n          await fetchUserPreferences(userData.user_id);\n          \n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          \n          if (storedAuth === 'true' && storedUser) {\n            const parsedUser = JSON.parse(storedUser);\n            setUser(parsedUser);\n            setIsAuthenticated(true);\n            \n            // Try to fetch preferences if we have a user ID\n            if (parsedUser.id) {\n              await fetchUserPreferences(parsedUser.id);\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (event === 'SIGNED_IN' && session) {\n          // Get user data from users table\n          const { data: userData, error: userError } = await supabase\n            .from('users')\n            .select('*')\n            .eq('email', session.user.email)\n            .single();\n            \n          if (!userError && userData) {\n            const userObj = {\n              id: userData.user_id,\n              name: userData.name,\n              email: userData.email,\n              isPremium: userData.is_premium,\n              avatar: userData.avatar_url\n            };\n            \n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Store in localStorage\n            localStorage.setItem('healthsync_auth', 'true');\n            localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n            \n            // Fetch user preferences\n            await fetchUserPreferences(userData.user_id);\n          }\n        }\n        \n        if (event === 'SIGNED_OUT') {\n          setUser(null);\n          setIsAuthenticated(false);\n          localStorage.removeItem('healthsync_auth');\n          localStorage.removeItem('healthsync_user');\n          \n          // Reset preferences to defaults\n          setUserPreferences({\n            notifications: true,\n            reminders: true,\n            biometrics: true,\n            darkMode: false,\n            dataSharing: false\n          });\n        }\n      }\n    );\n\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Update user profile data (name, avatar, etc)\n  const updateUserProfile = async (profileData) => {\n    if (!user?.id) return { success: false, error: 'Not authenticated' };\n    \n    try {\n      // Update user in database\n      const updateData = {};\n      \n      if (profileData.name) updateData.name = profileData.name;\n      if (profileData.avatar) updateData.avatar_url = profileData.avatar;\n      \n      // Only proceed if we have data to update\n      if (Object.keys(updateData).length === 0) {\n        return { success: true, message: 'No changes to update' };\n      }\n      \n      const { error } = await supabase\n        .from('users')\n        .update(updateData)\n        .eq('user_id', user.id);\n      \n      if (error) throw error;\n      \n      // Update local user state\n      const updatedUser = {\n        ...user,\n        name: profileData.name || user.name,\n        avatar: profileData.avatar || user.avatar\n      };\n      \n      setUser(updatedUser);\n      \n      // Update localStorage\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Fetch user preferences from the database\n  const fetchUserPreferences = async (userId) => {\n    try {\n      const { data, error } = await supabase\n        .from('user_preferences')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n      \n      if (error) {\n        console.error('Error fetching preferences:', error);\n        return;\n      }\n      \n      if (data) {\n        // Update preferences state\n        setUserPreferences({\n          notifications: data.enable_notifications,\n          reminders: data.enable_reminders,\n          biometrics: data.enable_biometrics,\n          darkMode: data.enable_dark_mode,\n          dataSharing: data.enable_data_sharing\n        });\n        \n        // Also update localStorage for dark mode to persist theme\n        localStorage.setItem('healthsync_darkmode', data.enable_dark_mode);\n      }\n    } catch (error) {\n      console.error('Error in fetchUserPreferences:', error);\n    }\n  };\n\n  // Update user preferences in the database\n  const updateUserPreferences = async (preferences) => {\n    if (!user?.id) return { success: false, error: 'Not authenticated' };\n    \n    try {\n      // Check if preferences record exists\n      const { data: existingPrefs } = await supabase\n        .from('user_preferences')\n        .select('user_preferences_id')\n        .eq('user_id', user.id)\n        .single();\n      \n      // Prepare preferences data\n      const prefsData = {\n        user_id: user.id,\n        enable_notifications: preferences.notifications,\n        enable_reminders: preferences.reminders,\n        enable_biometrics: preferences.biometrics,\n        enable_dark_mode: preferences.darkMode,\n        enable_data_sharing: preferences.dataSharing,\n        updated_at: new Date().toISOString()\n      };\n      \n      // Update or insert preferences\n      if (existingPrefs) {\n        const { error } = await supabase\n          .from('user_preferences')\n          .update(prefsData)\n          .eq('user_id', user.id);\n          \n        if (error) throw error;\n      } else {\n        const { error } = await supabase\n          .from('user_preferences')\n          .insert([prefsData]);\n          \n        if (error) throw error;\n      }\n      \n      // Update local state\n      setUserPreferences(preferences);\n      \n      // Update localStorage for dark mode\n      localStorage.setItem('healthsync_darkmode', preferences.darkMode);\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error updating preferences:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Function to create a storage bucket if it doesn't exist\n  const initializeStorage = async () => {\n    try {\n      // Check if avatars bucket exists, if not create it\n      const { data: buckets } = await supabase.storage.listBuckets();\n      \n      if (!buckets.find(bucket => bucket.name === 'avatars')) {\n        const { error } = await supabase.storage.createBucket('avatars', {\n          public: true,\n          fileSizeLimit: 2097152, // 2MB in bytes\n          allowedMimeTypes: ['image/png', 'image/jpeg', 'image/gif']\n        });\n        \n        if (error) {\n          console.error('Error creating avatars bucket:', error);\n        }\n      }\n    } catch (error) {\n      console.error('Error initializing storage:', error);\n    }\n  };\n\n  // Initialize storage on load\n  useEffect(() => {\n    if (isAuthenticated) {\n      initializeStorage();\n    }\n  }, [isAuthenticated]);\n\n  // Send verification email for unverified accounts\n  const sendVerificationEmail = async (email) => {\n    try {\n      const { error } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      \n      if (error) {\n        return { success: false, error: error.message };\n      }\n      \n      return { \n        success: true, \n        message: 'Verification email sent! Please check your inbox (and spam folder).' \n      };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      setUser(null);\n      setIsAuthenticated(false);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    signOut,\n    sendVerificationEmail,\n    userPreferences,\n    updateUserPreferences,\n    updateUserProfile\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}