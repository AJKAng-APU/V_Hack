{"ast":null,"code":"import WebRTCEventEmitter from './WebRTCEventEmitter';\nimport WebRTCConnectionManager from './WebRTCConnectionManager';\nimport WebRTCMediaManager from './WebRTCMediaManager';\nimport WebRTCLogger from './WebRTCLogger';\nimport { createSignalingService } from './SignalingService';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management and error handling\n */\nclass WebRTCService {\n  constructor() {\n    // Public API: State Checking Methods\n    this.isCallActive = () => ['connecting', 'active'].includes(this.callState);\n    this.isCallConnected = () => this.callState === 'active';\n    // Create logger\n    this.logger = new WebRTCLogger();\n\n    // Create event emitter\n    this.eventEmitter = new WebRTCEventEmitter();\n\n    // Create media manager\n    this.mediaManager = new WebRTCMediaManager(this.logger);\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n\n    // Initialize subsystems\n    this.connectionManager = null;\n    this.signalingService = null;\n\n    // Initialization state\n    this.isInitialized = false;\n  }\n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n\n  // Public API: Call State Management\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n      this.callState = newState;\n\n      // Emit event for UI components\n      this.eventEmitter.emit('callStateChanged', newState);\n\n      // Trigger appropriate callbacks\n      if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n      if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n      if (newState === 'connecting' && this.callbacks.onCallConnecting) this.callbacks.onCallConnecting();\n    }\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n\n    // Create signaling service - ONLY ONCE\n    this.signalingService = createSignalingService(serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001', userId, this.handleSignalingEvents.bind(this));\n\n    // Configure socket settings for better reliability\n    if (this.signalingService && this.signalingService.socket) {\n      // Prevent disconnections\n      this.signalingService.socket.io.reconnection(true);\n      this.signalingService.socket.io.reconnectionAttempts(10);\n      this.signalingService.socket.io.reconnectionDelay(1000);\n      this.signalingService.socket.io.timeout(10000);\n\n      // Debug connection issues\n      this.signalingService.socket.on('connect', () => {\n        this.logger.log('Socket connected successfully!');\n        // Immediately register user ID again after reconnection\n        this.signalingService.send('register', userId);\n      });\n      this.signalingService.socket.on('disconnect', reason => {\n        this.logger.log('Socket disconnected, reason:', reason);\n      });\n    }\n\n    // Create connection manager\n    this.connectionManager = new WebRTCConnectionManager(this.signalingService, this.mediaManager, this.eventEmitter, this.logger, this.updateCallState.bind(this));\n    this.isInitialized = true;\n  }\n  endCall(notifyOther = true) {\n    const wasActive = this.callState !== 'idle' && this.callState !== 'ended';\n    this.callState = 'ended';\n\n    // Update UI state\n    this.eventEmitter.emit('callStateChanged', 'ended');\n\n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n\n    // Make sure we notify the other user about call ending\n    if (notifyOther && wasActive && this.signalingService && this.targetUserId) {\n      console.log('Sending end-call signal to:', this.targetUserId);\n\n      // Send the end call signal - retry up to 3 times\n      let attempts = 0;\n      const sendEndCall = () => {\n        attempts++;\n        this.signalingService.send('end-call', {\n          targetUserId: this.targetUserId\n        });\n        if (attempts < 3) {\n          setTimeout(sendEndCall, 500); // Retry after 500ms\n        }\n      };\n      sendEndCall();\n    }\n\n    // Reset state\n    this.pendingOffer = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n  }\n\n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined(data);\n        break;\n      case 'call-in-progress':\n        this.updateCallState('ended'); // Add this line to end the call explicitly\n        if (this.callbacks.onCallInProgress) {\n          this.callbacks.onCallInProgress(data.callerUserId, data.message);\n        }\n        break;\n      case 'ice-candidate':\n        this.connectionManager.addRemoteIceCandidate(data.candidate);\n        break;\n      case 'media-connected':\n        this.logger.log('Remote peer reports media connected');\n        this.updateCallState('active');\n        break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n\n  /**\n   * Handle incoming call event\n   */\n  handleIncomingCall(data) {\n    const {\n      callerUserId,\n      offerSDP\n    } = data;\n    this.logger.log('Incoming call from:', callerUserId);\n\n    // If there's already an active call, ignore this one\n    if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n      this.logger.log('Already in a call, ignoring incoming call');\n      // Explicitly decline the call so the caller knows\n      this.signalingService.send('call-declined', {\n        targetUserId: callerUserId\n      });\n      return;\n    }\n    this.targetUserId = callerUserId;\n\n    // Store the offer to use when call is accepted\n    this.connectionManager.setPendingOffer(offerSDP);\n\n    // Update call state\n    this.updateCallState('connecting');\n\n    // Notify the application of the incoming call\n    if (this.callbacks.onIncomingCall) {\n      this.callbacks.onIncomingCall(callerUserId);\n    }\n  }\n\n  /**\n   * Handle call answered event\n   */\n  handleCallAnswered(data) {\n    const {\n      answerSDP\n    } = data;\n    this.logger.log('Call was answered, setting remote description');\n\n    // Ensure we update the call state when setting the remote description\n    this.connectionManager.setRemoteDescription(answerSDP).then(() => {\n      // Explicitly check for media flow after setting remote description\n      setTimeout(() => {\n        if (this.callState === 'connecting') {\n          this.logger.log('Checking for media flow after answer');\n          // Force update to active state if we're still connecting after 2 seconds\n          if (this.connectionManager.remoteStream && this.connectionManager.remoteStream.getTracks().length > 0) {\n            this.updateCallState('active');\n          }\n        }\n      }, 2000);\n    }).catch(error => {\n      this.logger.error('Error setting remote description:', error);\n    });\n  }\n\n  /**\n   * Handle call declined event\n   */\n  handleCallDeclined() {\n    this.logger.log('Call was declined by the recipient');\n    this.updateCallState('ended');\n    this.endCall(false); // Don't notify the other person since they declined it\n\n    // Notify the application\n    if (this.callbacks.onCallDeclined) {\n      this.callbacks.onCallDeclined();\n    }\n  }\n\n  /**\n   * Handle call ended event\n   */\n  handleCallEnded() {\n    this.logger.log('Call ended remotely');\n    this.updateCallState('ended');\n    this.endCall(false); // Don't notify the other person since they ended it\n  }\n\n  /**\n   * Handle call failed event\n   */\n  handleCallFailed(data) {\n    const {\n      message,\n      targetUserId\n    } = data;\n    this.logger.log('Call failed:', message);\n\n    // Handle user not online case\n    if (message === 'User is not online') {\n      if (this.callbacks.onUserNotOnline) {\n        this.callbacks.onUserNotOnline(targetUserId);\n      } else {\n        this.updateCallState('ended');\n      }\n    } else {\n      this.updateCallState('ended');\n    }\n    this.resetCallState();\n  }\n\n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n\n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n\n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: this.callbacks.onRemoteStream,\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n\n  /**\n   * Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    return this.connectionManager.attemptReconnection(aggressive);\n  }\n\n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      if (!isOnline) {\n        this.logger.log('Cannot make call - user is not online:', targetUserId);\n        if (this.callbacks.onUserNotOnline) {\n          this.callbacks.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        return;\n      }\n\n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.logger.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      this.logger.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n\n      // Initialize the call\n      await this.connectionManager.initiateCall(this.userId, targetUserId);\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to accept');\n      return;\n    }\n    try {\n      this.logger.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n\n      // Accept the call\n      await this.connectionManager.acceptCall(this.targetUserId);\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n\n  /**\n   * Decline an incoming call\n   */\n  declineCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to decline');\n      return;\n    }\n    this.logger.log('Declining call from:', this.targetUserId);\n    this.signalingService.send('call-declined', {\n      targetUserId: this.targetUserId\n    });\n    this.resetCallState();\n  }\n\n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.logger.log('Ending call, notify peer:', notifyPeer);\n    if (notifyPeer && this.signalingService && this.targetUserId) {\n      // If the call is in connecting state, decline it instead of ending\n      if (!this.isCallConnected() && this.callState === 'connecting') {\n        this.signalingService.send('call-declined', {\n          targetUserId: this.targetUserId\n        });\n      } else {\n        this.signalingService.send('end-call', {\n          targetUserId: this.targetUserId\n        });\n      }\n    }\n\n    // Clean up connection and media\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n    if (this.mediaManager) {\n      this.mediaManager.stopLocalStream();\n    }\n\n    // Update call state\n    this.updateCallState('ended');\n\n    // Reset state\n    this.resetCallState();\n  }\n\n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.logger.log('Resetting call state');\n    this.targetUserId = null;\n    if (this.connectionManager) {\n      this.connectionManager.reset();\n    }\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n\n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      this.handleError('accessing media devices', error, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    this.mediaManager.toggleAudio(muted);\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    this.mediaManager.toggleVideo(videoOff);\n  }\n\n  /**\n   * Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.logger.error(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n\n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n\n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n\n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n\n    // Reset initialization status\n    this.isInitialized = false;\n\n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["WebRTCEventEmitter","WebRTCConnectionManager","WebRTCMediaManager","WebRTCLogger","createSignalingService","WebRTCService","constructor","isCallActive","includes","callState","isCallConnected","logger","eventEmitter","mediaManager","userId","targetUserId","connectionManager","signalingService","isInitialized","on","event","callback","updateCallState","newState","log","emit","callbacks","onCallStarted","onCallEnded","onCallConnecting","initialize","serverUrl","updateCallbacks","disconnect","process","env","REACT_APP_SIGNALING_SERVER","handleSignalingEvents","bind","socket","io","reconnection","reconnectionAttempts","reconnectionDelay","timeout","send","reason","endCall","notifyOther","wasActive","closeConnection","console","attempts","sendEndCall","setTimeout","pendingOffer","isCallInitiator","data","handleIncomingCall","handleCallAnswered","handleCallDeclined","onCallInProgress","callerUserId","message","addRemoteIceCandidate","candidate","handleCallEnded","handleCallFailed","offerSDP","setPendingOffer","onIncomingCall","answerSDP","setRemoteDescription","then","remoteStream","getTracks","length","catch","error","onCallDeclined","onUserNotOnline","resetCallState","onLocalStream","onRemoteStream","onICEConnectionStateChange","setCallbacks","checkUserOnline","isConnected","attemptReconnection","aggressive","makeCall","isOnline","hasLocalStream","getLocalMedia","initiateCall","handleError","acceptCall","declineCall","notifyPeer","stopLocalStream","reset","videoConstraints","audioConstraints","stream","setLocalStream","toggleAudio","muted","toggleVideo","videoOff","context","fatal","cleanup","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["import WebRTCEventEmitter from './WebRTCEventEmitter';\nimport WebRTCConnectionManager from './WebRTCConnectionManager';\nimport WebRTCMediaManager from './WebRTCMediaManager';\nimport WebRTCLogger from './WebRTCLogger';\nimport { createSignalingService } from './SignalingService';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management and error handling\n */\nclass WebRTCService {\n  constructor() {\n    // Create logger\n    this.logger = new WebRTCLogger();\n    \n    // Create event emitter\n    this.eventEmitter = new WebRTCEventEmitter();\n    \n    // Create media manager\n    this.mediaManager = new WebRTCMediaManager(this.logger);\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n    \n    // Initialize subsystems\n    this.connectionManager = null;\n    this.signalingService = null;\n    \n    // Initialization state\n    this.isInitialized = false;\n  }\n  \n  // Public API: State Checking Methods\n  isCallActive = () => ['connecting', 'active'].includes(this.callState);\n  isCallConnected = () => this.callState === 'active';\n  \n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n  \n  // Public API: Call State Management\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n      this.callState = newState;\n      \n      // Emit event for UI components\n      this.eventEmitter.emit('callStateChanged', newState);\n      \n      // Trigger appropriate callbacks\n      if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n      if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n      if (newState === 'connecting' && this.callbacks.onCallConnecting) this.callbacks.onCallConnecting();\n    }\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    \n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n    \n    // Create signaling service - ONLY ONCE\n    this.signalingService = createSignalingService(\n      serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001',\n      userId,\n      this.handleSignalingEvents.bind(this)\n    );\n    \n    // Configure socket settings for better reliability\n    if (this.signalingService && this.signalingService.socket) {\n      // Prevent disconnections\n      this.signalingService.socket.io.reconnection(true);\n      this.signalingService.socket.io.reconnectionAttempts(10);\n      this.signalingService.socket.io.reconnectionDelay(1000);\n      this.signalingService.socket.io.timeout(10000);\n      \n      // Debug connection issues\n      this.signalingService.socket.on('connect', () => {\n        this.logger.log('Socket connected successfully!');\n        // Immediately register user ID again after reconnection\n        this.signalingService.send('register', userId);\n      });\n      \n      this.signalingService.socket.on('disconnect', (reason) => {\n        this.logger.log('Socket disconnected, reason:', reason);\n      });\n    }\n    \n    // Create connection manager\n    this.connectionManager = new WebRTCConnectionManager(\n      this.signalingService,\n      this.mediaManager,\n      this.eventEmitter,\n      this.logger,\n      this.updateCallState.bind(this)\n    );\n    \n    this.isInitialized = true;\n  }\n\n  endCall(notifyOther = true) {\n    const wasActive = this.callState !== 'idle' && this.callState !== 'ended';\n    this.callState = 'ended';\n    \n    // Update UI state\n    this.eventEmitter.emit('callStateChanged', 'ended');\n    \n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n    \n    // Make sure we notify the other user about call ending\n    if (notifyOther && wasActive && this.signalingService && this.targetUserId) {\n      console.log('Sending end-call signal to:', this.targetUserId);\n      \n      // Send the end call signal - retry up to 3 times\n      let attempts = 0;\n      const sendEndCall = () => {\n        attempts++;\n        this.signalingService.send('end-call', {\n          targetUserId: this.targetUserId\n        });\n        \n        if (attempts < 3) {\n          setTimeout(sendEndCall, 500); // Retry after 500ms\n        }\n      };\n      \n      sendEndCall();\n    }\n    \n    // Reset state\n    this.pendingOffer = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n  }\n  \n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined(data);\n        break;\n      case 'call-in-progress':\n          this.updateCallState('ended'); // Add this line to end the call explicitly\n          if (this.callbacks.onCallInProgress) {\n            this.callbacks.onCallInProgress(data.callerUserId, data.message);\n          }\n          break;\n      case 'ice-candidate':\n        this.connectionManager.addRemoteIceCandidate(data.candidate);\n        break;\n      case 'media-connected':\n          this.logger.log('Remote peer reports media connected');\n          this.updateCallState('active');\n          break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n  \n  /**\n   * Handle incoming call event\n   */\n  handleIncomingCall(data) {\n    const { callerUserId, offerSDP } = data;\n    this.logger.log('Incoming call from:', callerUserId);\n    \n    // If there's already an active call, ignore this one\n    if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n      this.logger.log('Already in a call, ignoring incoming call');\n      // Explicitly decline the call so the caller knows\n      this.signalingService.send('call-declined', { targetUserId: callerUserId });\n      return;\n    }\n    \n    this.targetUserId = callerUserId;\n    \n    // Store the offer to use when call is accepted\n    this.connectionManager.setPendingOffer(offerSDP);\n    \n    // Update call state\n    this.updateCallState('connecting');\n    \n    // Notify the application of the incoming call\n    if (this.callbacks.onIncomingCall) {\n      this.callbacks.onIncomingCall(callerUserId);\n    }\n  }\n  \n  /**\n   * Handle call answered event\n   */\n  handleCallAnswered(data) {\n    const { answerSDP } = data;\n    this.logger.log('Call was answered, setting remote description');\n    \n    // Ensure we update the call state when setting the remote description\n    this.connectionManager.setRemoteDescription(answerSDP)\n      .then(() => {\n        // Explicitly check for media flow after setting remote description\n        setTimeout(() => {\n          if (this.callState === 'connecting') {\n            this.logger.log('Checking for media flow after answer');\n            // Force update to active state if we're still connecting after 2 seconds\n            if (this.connectionManager.remoteStream && \n                this.connectionManager.remoteStream.getTracks().length > 0) {\n              this.updateCallState('active');\n            }\n          }\n        }, 2000);\n      })\n      .catch(error => {\n        this.logger.error('Error setting remote description:', error);\n      });\n  }\n  \n  /**\n   * Handle call declined event\n   */\n  handleCallDeclined() {\n    this.logger.log('Call was declined by the recipient');\n    this.updateCallState('ended');\n    this.endCall(false); // Don't notify the other person since they declined it\n    \n    // Notify the application\n    if (this.callbacks.onCallDeclined) {\n      this.callbacks.onCallDeclined();\n    }\n  }\n  \n  /**\n   * Handle call ended event\n   */\n  handleCallEnded() {\n    this.logger.log('Call ended remotely');\n    this.updateCallState('ended');\n    this.endCall(false); // Don't notify the other person since they ended it\n  }\n  \n  /**\n   * Handle call failed event\n   */\n  handleCallFailed(data) {\n    const { message, targetUserId } = data;\n    this.logger.log('Call failed:', message);\n    \n    // Handle user not online case\n    if (message === 'User is not online') {\n      if (this.callbacks.onUserNotOnline) {\n        this.callbacks.onUserNotOnline(targetUserId);\n      } else {\n        this.updateCallState('ended');\n      }\n    } else {\n      this.updateCallState('ended');\n    }\n    \n    this.resetCallState();\n  }\n  \n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n    \n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n    \n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: this.callbacks.onRemoteStream,\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n  \n  /**\n   * Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    \n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    return this.connectionManager.attemptReconnection(aggressive);\n  }\n  \n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      \n      if (!isOnline) {\n        this.logger.log('Cannot make call - user is not online:', targetUserId);\n        \n        if (this.callbacks.onUserNotOnline) {\n          this.callbacks.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        \n        return;\n      }\n      \n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.logger.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      \n      this.logger.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n      \n      // Initialize the call\n      await this.connectionManager.initiateCall(this.userId, targetUserId);\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to accept');\n      return;\n    }\n    \n    try {\n      this.logger.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n      \n      // Accept the call\n      await this.connectionManager.acceptCall(this.targetUserId);\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n  \n  /**\n   * Decline an incoming call\n   */\n  declineCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to decline');\n      return;\n    }\n    \n    this.logger.log('Declining call from:', this.targetUserId);\n    this.signalingService.send('call-declined', { targetUserId: this.targetUserId });\n    this.resetCallState();\n  }\n  \n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.logger.log('Ending call, notify peer:', notifyPeer);\n    \n    if (notifyPeer && this.signalingService && this.targetUserId) {\n      // If the call is in connecting state, decline it instead of ending\n      if (!this.isCallConnected() && this.callState === 'connecting') {\n        this.signalingService.send('call-declined', { targetUserId: this.targetUserId });\n      } else {\n        this.signalingService.send('end-call', { targetUserId: this.targetUserId });\n      }\n    }\n    \n    // Clean up connection and media\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.stopLocalStream();\n    }\n    \n    // Update call state\n    this.updateCallState('ended');\n    \n    // Reset state\n    this.resetCallState();\n  }\n  \n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.logger.log('Resetting call state');\n    this.targetUserId = null;\n    \n    if (this.connectionManager) {\n      this.connectionManager.reset();\n    }\n  }\n  \n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n      \n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      \n      return stream;\n    } catch (error) {\n      this.handleError('accessing media devices', error, true);\n      throw error;\n    }\n  }\n  \n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    this.mediaManager.toggleAudio(muted);\n  }\n  \n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    this.mediaManager.toggleVideo(videoOff);\n  }\n  \n  /**\n   * Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.logger.error(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n    \n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n    \n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n    \n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n    \n    // Reset initialization status\n    this.isInitialized = false;\n    \n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}