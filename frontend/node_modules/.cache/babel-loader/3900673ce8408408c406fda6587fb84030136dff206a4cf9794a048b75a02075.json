{"ast":null,"code":"/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n\n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // First try with both video and audio\n      return await this._tryGetUserMedia(videoConstraints, audioConstraints);\n    } catch (error) {\n      // If both fail, try audio only\n      if (videoConstraints && audioConstraints) {\n        this.logger.log('Failed to get video+audio, trying audio only');\n        try {\n          return await this._tryGetUserMedia(false, true);\n        } catch (audioError) {\n          this.logger.error('Failed to get audio-only access:', audioError.message);\n          throw audioError;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n  async _tryGetUserMedia(video, audio) {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video,\n        audio\n      });\n      this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n      this.localStream = stream;\n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n      // Re-throw with more user-friendly message\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Camera/microphone access was denied by the user');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n      } else if (error.name === 'NotReadableError') {\n        throw new Error('Media device is in use by another application');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.logger.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n\n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\nexport default WebRTCMediaManager;","map":{"version":3,"names":["WebRTCMediaManager","constructor","logger","localStream","callbacks","onLocalStream","setCallbacks","hasLocalStream","getLocalMedia","videoConstraints","audioConstraints","_tryGetUserMedia","error","log","audioError","message","video","audio","stream","navigator","mediaDevices","getUserMedia","name","Error","toggleAudio","muted","getAudioTracks","forEach","track","enabled","toggleVideo","videoOff","getVideoTracks","stopLocalStream","getTracks","kind","stop","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCMediaManager.js"],"sourcesContent":["/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n    constructor(logger) {\n      this.logger = logger;\n      this.localStream = null;\n      this.callbacks = {\n        onLocalStream: null\n      };\n    }\n    \n    /**\n     * Set callbacks\n     * @param {object} callbacks - Callback functions\n     */\n    setCallbacks(callbacks) {\n      this.callbacks = {\n        ...this.callbacks,\n        ...callbacks\n      };\n    }\n    \n    /**\n     * Check if local stream is available\n     * @returns {boolean} - Whether local stream is available\n     */\n    hasLocalStream() {\n      return !!this.localStream;\n    }\n    \n    /**\n     * Get access to local camera and microphone\n     * @param {boolean|object} videoConstraints - Constraints for video\n     * @param {boolean|object} audioConstraints - Constraints for audio\n     * @returns {Promise<MediaStream>} - Local media stream\n     */\n    async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n      try {\n        // First try with both video and audio\n        return await this._tryGetUserMedia(videoConstraints, audioConstraints);\n      } catch (error) {\n        // If both fail, try audio only\n        if (videoConstraints && audioConstraints) {\n          this.logger.log('Failed to get video+audio, trying audio only');\n          try {\n            return await this._tryGetUserMedia(false, true);\n          } catch (audioError) {\n            this.logger.error('Failed to get audio-only access:', audioError.message);\n            throw audioError;\n          }\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    async _tryGetUserMedia(video, audio) {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video, audio\n        });\n        \n        this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n        this.localStream = stream;\n        \n        if (this.callbacks.onLocalStream) {\n          this.callbacks.onLocalStream(stream);\n        }\n        \n        return stream;\n      } catch (error) {\n        this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n        // Re-throw with more user-friendly message\n        if (error.name === 'NotAllowedError') {\n          throw new Error('Camera/microphone access was denied by the user');\n        } else if (error.name === 'NotFoundError') {\n          throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n        } else if (error.name === 'NotReadableError') {\n          throw new Error('Media device is in use by another application');\n        } else {\n          throw error;\n        }\n      }\n    }\n    \n    /**\n     * Toggle audio mute state\n     * @param {boolean} muted - Whether to mute audio\n     */\n    toggleAudio(muted) {\n      if (this.localStream) {\n        this.localStream.getAudioTracks().forEach(track => {\n          this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n          track.enabled = !muted;\n        });\n      }\n    }\n    \n    /**\n     * Toggle video on/off\n     * @param {boolean} videoOff - Whether to turn off video\n     */\n    toggleVideo(videoOff) {\n      if (this.localStream) {\n        this.localStream.getVideoTracks().forEach(track => {\n          this.logger.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n          track.enabled = !videoOff;\n        });\n      }\n    }\n    \n    /**\n     * Stop all tracks in the local stream\n     */\n    stopLocalStream() {\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.logger.log('Stopping track:', track.kind);\n          track.stop();\n        });\n        this.localStream = null;\n      }\n    }\n    \n    /**\n     * Clean up resources\n     */\n    cleanup() {\n      this.stopLocalStream();\n    }\n  }\n  \n  export default WebRTCMediaManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}