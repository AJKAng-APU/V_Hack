{"ast":null,"code":"/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n\n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // First try with both video and audio\n      const stream = await this._tryGetUserMedia(videoConstraints, audioConstraints);\n\n      // Debug log all tracks\n      this.logger.log('Got local stream with tracks:', stream.getTracks().map(t => `${t.kind}: ${t.enabled ? 'enabled' : 'disabled'}`).join(', '));\n\n      // Store stream in window for debugging\n      window.myLocalStream = stream;\n      return stream;\n    } catch (error) {\n      // If both fail, try audio only\n      if (videoConstraints && audioConstraints) {\n        this.logger.log('Failed to get video+audio, trying audio only');\n        try {\n          return await this._tryGetUserMedia(false, true);\n        } catch (audioError) {\n          this.logger.error('Failed to get audio-only access:', audioError.message);\n          throw audioError;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n  async _tryGetUserMedia(video, audio) {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video,\n        audio\n      });\n      this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n      this.localStream = stream;\n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n      // Re-throw with more user-friendly message\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Camera/microphone access was denied by the user');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n      } else if (error.name === 'NotReadableError') {\n        throw new Error('Media device is in use by another application');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle video on/off - IMPROVED VERSION\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    console.log('MediaManager:toggleVideo called with videoOff:', videoOff);\n    if (this.localStream) {\n      const videoTracks = this.localStream.getVideoTracks();\n      console.log('Video tracks found:', videoTracks.length);\n      if (videoTracks.length > 0) {\n        videoTracks.forEach(track => {\n          console.log('Video track before toggle, enabled:', track.enabled);\n\n          // MODIFIED: Just disable the track but don't stop it\n          // This keeps the video stream running but makes it \"invisible\" to the recipient\n          track.enabled = !videoOff;\n          console.log('Video track after toggle, readyState:', track.readyState, 'enabled:', track.enabled);\n        });\n      } else if (!videoOff) {\n        this.logger.log('No video tracks found in local stream, but video requested');\n\n        // If video should be on but no tracks exist, try to get video\n        this._getNewVideoTrack();\n      }\n    } else if (!videoOff) {\n      this.logger.log('No local stream available for video toggle, but video requested');\n\n      // Try to initialize stream if it doesn't exist and video should be on\n      this.getLocalMedia(true, true).catch(err => this.logger.error('Failed to initialize media:', err));\n    }\n  }\n\n  /**\n   * Helper method to get a new video track when needed\n   * @private\n   */\n  _getNewVideoTrack() {\n    this.logger.log('Attempting to add new video track');\n\n    // Use saved constraints if available, otherwise use default\n    const constraints = this._savedVideoConstraints || {\n      video: true\n    };\n    navigator.mediaDevices.getUserMedia({\n      video: constraints\n    }).then(videoStream => {\n      const videoTrack = videoStream.getVideoTracks()[0];\n      if (videoTrack) {\n        // Remove any existing video tracks first\n        const existingTracks = this.localStream.getVideoTracks();\n        existingTracks.forEach(track => {\n          this.localStream.removeTrack(track);\n          track.stop();\n        });\n\n        // Add the new track\n        this.localStream.addTrack(videoTrack);\n        this.logger.log('Added new video track to local stream');\n\n        // If we have callbacks set up, notify about the updated stream\n        if (this.callbacks.onLocalStream) {\n          this.callbacks.onLocalStream(this.localStream);\n        }\n      }\n    }).catch(err => {\n      this.logger.error('Failed to get new video track:', err);\n      // Notify user about camera access failure\n      if (this.callbacks.onError) {\n        this.callbacks.onError({\n          message: 'Could not access camera. Please check permissions.',\n          fatal: false\n        });\n      }\n    });\n  }\n\n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\nexport default WebRTCMediaManager;","map":{"version":3,"names":["WebRTCMediaManager","constructor","logger","localStream","callbacks","onLocalStream","setCallbacks","hasLocalStream","getLocalMedia","videoConstraints","audioConstraints","stream","_tryGetUserMedia","log","getTracks","map","t","kind","enabled","join","window","myLocalStream","error","audioError","message","video","audio","navigator","mediaDevices","getUserMedia","name","Error","toggleAudio","muted","getAudioTracks","forEach","track","toggleVideo","videoOff","console","videoTracks","getVideoTracks","length","readyState","_getNewVideoTrack","catch","err","constraints","_savedVideoConstraints","then","videoStream","videoTrack","existingTracks","removeTrack","stop","addTrack","onError","fatal","stopLocalStream","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCMediaManager.js"],"sourcesContent":["/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n  \n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n  \n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n  \n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // First try with both video and audio\n      const stream = await this._tryGetUserMedia(videoConstraints, audioConstraints);\n      \n      // Debug log all tracks\n      this.logger.log('Got local stream with tracks:', \n        stream.getTracks().map(t => `${t.kind}: ${t.enabled ? 'enabled' : 'disabled'}`).join(', '));\n      \n      // Store stream in window for debugging\n      window.myLocalStream = stream;\n      \n      return stream;\n    } catch (error) {\n      // If both fail, try audio only\n      if (videoConstraints && audioConstraints) {\n        this.logger.log('Failed to get video+audio, trying audio only');\n        try {\n          return await this._tryGetUserMedia(false, true);\n        } catch (audioError) {\n          this.logger.error('Failed to get audio-only access:', audioError.message);\n          throw audioError;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async _tryGetUserMedia(video, audio) {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video, audio\n      });\n      \n      this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n      this.localStream = stream;\n      \n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      \n      return stream;\n    } catch (error) {\n      this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n      // Re-throw with more user-friendly message\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Camera/microphone access was denied by the user');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n      } else if (error.name === 'NotReadableError') {\n        throw new Error('Media device is in use by another application');\n      } else {\n        throw error;\n      }\n    }\n  }\n  \n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Toggle video on/off - IMPROVED VERSION\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    console.log('MediaManager:toggleVideo called with videoOff:', videoOff);\n    \n    if (this.localStream) {\n      const videoTracks = this.localStream.getVideoTracks();\n      console.log('Video tracks found:', videoTracks.length);\n      \n      if (videoTracks.length > 0) {\n        videoTracks.forEach(track => {\n          console.log('Video track before toggle, enabled:', track.enabled);\n          \n          // MODIFIED: Just disable the track but don't stop it\n          // This keeps the video stream running but makes it \"invisible\" to the recipient\n          track.enabled = !videoOff;\n          \n          console.log('Video track after toggle, readyState:', track.readyState, 'enabled:', track.enabled);\n        });\n      } else if (!videoOff) {\n        this.logger.log('No video tracks found in local stream, but video requested');\n        \n        // If video should be on but no tracks exist, try to get video\n        this._getNewVideoTrack();\n      }\n    } else if (!videoOff) {\n      this.logger.log('No local stream available for video toggle, but video requested');\n      \n      // Try to initialize stream if it doesn't exist and video should be on\n      this.getLocalMedia(true, true)\n        .catch(err => this.logger.error('Failed to initialize media:', err));\n    }\n  }\n  \n  /**\n   * Helper method to get a new video track when needed\n   * @private\n   */\n  _getNewVideoTrack() {\n    this.logger.log('Attempting to add new video track');\n    \n    // Use saved constraints if available, otherwise use default\n    const constraints = this._savedVideoConstraints || { video: true };\n    \n    navigator.mediaDevices.getUserMedia({ video: constraints })\n      .then(videoStream => {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (videoTrack) {\n          // Remove any existing video tracks first\n          const existingTracks = this.localStream.getVideoTracks();\n          existingTracks.forEach(track => {\n            this.localStream.removeTrack(track);\n            track.stop();\n          });\n          \n          // Add the new track\n          this.localStream.addTrack(videoTrack);\n          this.logger.log('Added new video track to local stream');\n          \n          // If we have callbacks set up, notify about the updated stream\n          if (this.callbacks.onLocalStream) {\n            this.callbacks.onLocalStream(this.localStream);\n          }\n        }\n      })\n      .catch(err => {\n        this.logger.error('Failed to get new video track:', err);\n        // Notify user about camera access failure\n        if (this.callbacks.onError) {\n          this.callbacks.onError({ \n            message: 'Could not access camera. Please check permissions.', \n            fatal: false \n          });\n        }\n      });\n  }\n  \n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\n\nexport default WebRTCMediaManager;"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,kBAAkB,CAAC;EACvBC,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,SAAS,GAAG;MACfC,aAAa,EAAE;IACjB,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACEC,YAAYA,CAACF,SAAS,EAAE;IACtB,IAAI,CAACA,SAAS,GAAG;MACf,GAAG,IAAI,CAACA,SAAS;MACjB,GAAGA;IACL,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACEG,cAAcA,CAAA,EAAG;IACf,OAAO,CAAC,CAAC,IAAI,CAACJ,WAAW;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMK,aAAaA,CAACC,gBAAgB,GAAG,IAAI,EAAEC,gBAAgB,GAAG,IAAI,EAAE;IACpE,IAAI;MACF;MACA,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAACH,gBAAgB,EAAEC,gBAAgB,CAAC;;MAE9E;MACA,IAAI,CAACR,MAAM,CAACW,GAAG,CAAC,+BAA+B,EAC7CF,MAAM,CAACG,SAAS,CAAC,CAAC,CAACC,GAAG,CAACC,CAAC,IAAI,GAAGA,CAAC,CAACC,IAAI,KAAKD,CAAC,CAACE,OAAO,GAAG,SAAS,GAAG,UAAU,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;;MAE7F;MACAC,MAAM,CAACC,aAAa,GAAGV,MAAM;MAE7B,OAAOA,MAAM;IACf,CAAC,CAAC,OAAOW,KAAK,EAAE;MACd;MACA,IAAIb,gBAAgB,IAAIC,gBAAgB,EAAE;QACxC,IAAI,CAACR,MAAM,CAACW,GAAG,CAAC,8CAA8C,CAAC;QAC/D,IAAI;UACF,OAAO,MAAM,IAAI,CAACD,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC;QACjD,CAAC,CAAC,OAAOW,UAAU,EAAE;UACnB,IAAI,CAACrB,MAAM,CAACoB,KAAK,CAAC,kCAAkC,EAAEC,UAAU,CAACC,OAAO,CAAC;UACzE,MAAMD,UAAU;QAClB;MACF,CAAC,MAAM;QACL,MAAMD,KAAK;MACb;IACF;EACF;EAEA,MAAMV,gBAAgBA,CAACa,KAAK,EAAEC,KAAK,EAAE;IACnC,IAAI;MACF,MAAMf,MAAM,GAAG,MAAMgB,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDJ,KAAK;QAAEC;MACT,CAAC,CAAC;MAEF,IAAI,CAACxB,MAAM,CAACW,GAAG,CAAC,kCAAkC,CAAC,CAACY,KAAK,WAAW,CAAC,CAACC,KAAK,EAAE,CAAC;MAC9E,IAAI,CAACvB,WAAW,GAAGQ,MAAM;MAEzB,IAAI,IAAI,CAACP,SAAS,CAACC,aAAa,EAAE;QAChC,IAAI,CAACD,SAAS,CAACC,aAAa,CAACM,MAAM,CAAC;MACtC;MAEA,OAAOA,MAAM;IACf,CAAC,CAAC,OAAOW,KAAK,EAAE;MACd,IAAI,CAACpB,MAAM,CAACoB,KAAK,CAAC,6BAA6B,CAAC,CAACG,KAAK,WAAW,CAAC,CAACC,KAAK,IAAI,EAAEJ,KAAK,CAACE,OAAO,CAAC;MAC5F;MACA,IAAIF,KAAK,CAACQ,IAAI,KAAK,iBAAiB,EAAE;QACpC,MAAM,IAAIC,KAAK,CAAC,iDAAiD,CAAC;MACpE,CAAC,MAAM,IAAIT,KAAK,CAACQ,IAAI,KAAK,eAAe,EAAE;QACzC,MAAM,IAAIC,KAAK,CAACN,KAAK,GAAG,kCAAkC,GAAG,sBAAsB,CAAC;MACtF,CAAC,MAAM,IAAIH,KAAK,CAACQ,IAAI,KAAK,kBAAkB,EAAE;QAC5C,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;MAClE,CAAC,MAAM;QACL,MAAMT,KAAK;MACb;IACF;EACF;;EAEA;AACF;AACA;AACA;EACEU,WAAWA,CAACC,KAAK,EAAE;IACjB,IAAI,IAAI,CAAC9B,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC+B,cAAc,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAI;QACjD,IAAI,CAAClC,MAAM,CAACW,GAAG,CAACoB,KAAK,GAAG,cAAc,GAAG,gBAAgB,CAAC;QAC1DG,KAAK,CAAClB,OAAO,GAAG,CAACe,KAAK;MACxB,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;AACA;EACEI,WAAWA,CAACC,QAAQ,EAAE;IACpBC,OAAO,CAAC1B,GAAG,CAAC,gDAAgD,EAAEyB,QAAQ,CAAC;IAEvE,IAAI,IAAI,CAACnC,WAAW,EAAE;MACpB,MAAMqC,WAAW,GAAG,IAAI,CAACrC,WAAW,CAACsC,cAAc,CAAC,CAAC;MACrDF,OAAO,CAAC1B,GAAG,CAAC,qBAAqB,EAAE2B,WAAW,CAACE,MAAM,CAAC;MAEtD,IAAIF,WAAW,CAACE,MAAM,GAAG,CAAC,EAAE;QAC1BF,WAAW,CAACL,OAAO,CAACC,KAAK,IAAI;UAC3BG,OAAO,CAAC1B,GAAG,CAAC,qCAAqC,EAAEuB,KAAK,CAAClB,OAAO,CAAC;;UAEjE;UACA;UACAkB,KAAK,CAAClB,OAAO,GAAG,CAACoB,QAAQ;UAEzBC,OAAO,CAAC1B,GAAG,CAAC,uCAAuC,EAAEuB,KAAK,CAACO,UAAU,EAAE,UAAU,EAAEP,KAAK,CAAClB,OAAO,CAAC;QACnG,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI,CAACoB,QAAQ,EAAE;QACpB,IAAI,CAACpC,MAAM,CAACW,GAAG,CAAC,4DAA4D,CAAC;;QAE7E;QACA,IAAI,CAAC+B,iBAAiB,CAAC,CAAC;MAC1B;IACF,CAAC,MAAM,IAAI,CAACN,QAAQ,EAAE;MACpB,IAAI,CAACpC,MAAM,CAACW,GAAG,CAAC,iEAAiE,CAAC;;MAElF;MACA,IAAI,CAACL,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC,CAC3BqC,KAAK,CAACC,GAAG,IAAI,IAAI,CAAC5C,MAAM,CAACoB,KAAK,CAAC,6BAA6B,EAAEwB,GAAG,CAAC,CAAC;IACxE;EACF;;EAEA;AACF;AACA;AACA;EACEF,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAAC1C,MAAM,CAACW,GAAG,CAAC,mCAAmC,CAAC;;IAEpD;IACA,MAAMkC,WAAW,GAAG,IAAI,CAACC,sBAAsB,IAAI;MAAEvB,KAAK,EAAE;IAAK,CAAC;IAElEE,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MAAEJ,KAAK,EAAEsB;IAAY,CAAC,CAAC,CACxDE,IAAI,CAACC,WAAW,IAAI;MACnB,MAAMC,UAAU,GAAGD,WAAW,CAACT,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MAClD,IAAIU,UAAU,EAAE;QACd;QACA,MAAMC,cAAc,GAAG,IAAI,CAACjD,WAAW,CAACsC,cAAc,CAAC,CAAC;QACxDW,cAAc,CAACjB,OAAO,CAACC,KAAK,IAAI;UAC9B,IAAI,CAACjC,WAAW,CAACkD,WAAW,CAACjB,KAAK,CAAC;UACnCA,KAAK,CAACkB,IAAI,CAAC,CAAC;QACd,CAAC,CAAC;;QAEF;QACA,IAAI,CAACnD,WAAW,CAACoD,QAAQ,CAACJ,UAAU,CAAC;QACrC,IAAI,CAACjD,MAAM,CAACW,GAAG,CAAC,uCAAuC,CAAC;;QAExD;QACA,IAAI,IAAI,CAACT,SAAS,CAACC,aAAa,EAAE;UAChC,IAAI,CAACD,SAAS,CAACC,aAAa,CAAC,IAAI,CAACF,WAAW,CAAC;QAChD;MACF;IACF,CAAC,CAAC,CACD0C,KAAK,CAACC,GAAG,IAAI;MACZ,IAAI,CAAC5C,MAAM,CAACoB,KAAK,CAAC,gCAAgC,EAAEwB,GAAG,CAAC;MACxD;MACA,IAAI,IAAI,CAAC1C,SAAS,CAACoD,OAAO,EAAE;QAC1B,IAAI,CAACpD,SAAS,CAACoD,OAAO,CAAC;UACrBhC,OAAO,EAAE,oDAAoD;UAC7DiC,KAAK,EAAE;QACT,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACN;;EAEA;AACF;AACA;EACEC,eAAeA,CAAA,EAAG;IAChB,IAAI,IAAI,CAACvD,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAACW,SAAS,CAAC,CAAC,CAACqB,OAAO,CAACC,KAAK,IAAI;QAC5C,IAAI,CAAClC,MAAM,CAACW,GAAG,CAAC,iBAAiB,EAAEuB,KAAK,CAACnB,IAAI,CAAC;QAC9CmB,KAAK,CAACkB,IAAI,CAAC,CAAC;MACd,CAAC,CAAC;MACF,IAAI,CAACnD,WAAW,GAAG,IAAI;IACzB;EACF;;EAEA;AACF;AACA;EACEwD,OAAOA,CAAA,EAAG;IACR,IAAI,CAACD,eAAe,CAAC,CAAC;EACxB;AACF;AAEA,eAAe1D,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}