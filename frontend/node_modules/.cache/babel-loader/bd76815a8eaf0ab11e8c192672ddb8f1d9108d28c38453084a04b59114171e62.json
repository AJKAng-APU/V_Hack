{"ast":null,"code":"// File: services/WebRTC/ConnectionRecoveryUtils.js\n\n/**\n * Utilities for WebRTC connection recovery and socket reconnection\n * Add this file to your project and import where needed\n */\n\n// Reliable socket reconnection with backoff\nexport async function reconnectSocket(signalingService, userId) {\n  if (!signalingService) return false;\n  console.log('Starting socket reconnection attempt with backoff');\n\n  // Try different transport strategies in sequence\n  const strategies = [{\n    transport: ['websocket', 'polling'],\n    delay: 1000,\n    attempts: 2\n  }, {\n    transport: ['polling', 'websocket'],\n    delay: 2000,\n    attempts: 2\n  }, {\n    transport: ['polling'],\n    delay: 3000,\n    attempts: 1\n  }];\n  for (const strategy of strategies) {\n    // Try each strategy for the specified number of attempts\n    for (let i = 0; i < strategy.attempts; i++) {\n      console.log(`Trying reconnection with transports: ${strategy.transport.join(', ')} (attempt ${i + 1}/${strategy.attempts})`);\n      try {\n        // Configure transports\n        if (signalingService.socket && signalingService.socket.io) {\n          signalingService.socket.io.opts.transports = strategy.transport;\n        }\n\n        // Try to reconnect\n        const success = await attemptReconnect(signalingService, userId, strategy.delay);\n        if (success) {\n          console.log('Reconnection successful!');\n          return true;\n        }\n      } catch (err) {\n        console.error('Error during reconnection attempt:', err);\n      }\n\n      // Wait before trying next attempt\n      await new Promise(resolve => setTimeout(resolve, strategy.delay));\n    }\n  }\n  console.log('All reconnection strategies failed');\n  return false;\n}\n\n// Helper function for attempting a single reconnection\nasync function attemptReconnect(signalingService, userId, timeout) {\n  return new Promise(resolve => {\n    // Already connected\n    if (signalingService.isConnected()) {\n      resolve(true);\n      return;\n    }\n    console.log(`Attempting reconnection with ${timeout}ms timeout`);\n\n    // Setup handlers for connection events\n    const connectHandler = () => {\n      if (signalingService.socket) {\n        signalingService.socket.off('connect', connectHandler);\n      }\n      clearTimeout(timeoutId);\n\n      // Re-register after successful connection\n      if (userId) {\n        signalingService.send('register', userId);\n        console.log(`Re-registered as ${userId} after reconnection`);\n      }\n      resolve(true);\n    };\n    if (signalingService.socket) {\n      signalingService.socket.once('connect', connectHandler);\n\n      // Clean up old connection before trying to connect\n      try {\n        if (signalingService.socket.connected) {\n          signalingService.socket.disconnect();\n        }\n      } catch (e) {\n        console.warn('Error cleaning up socket before reconnection:', e);\n      }\n\n      // Try to connect\n      try {\n        signalingService.socket.connect();\n      } catch (e) {\n        console.error('Error attempting to connect socket:', e);\n      }\n    } else if (typeof signalingService.reconnect === 'function') {\n      // Use the reconnect method if available\n      signalingService.reconnect().then(success => {\n        if (success) {\n          connectHandler();\n        } else {\n          resolve(false);\n        }\n      }).catch(() => resolve(false));\n    }\n\n    // Set timeout for the attempt\n    const timeoutId = setTimeout(() => {\n      if (signalingService.socket) {\n        signalingService.socket.off('connect', connectHandler);\n      }\n      console.log('Reconnection attempt timed out');\n      resolve(false);\n    }, timeout);\n  });\n}\n\n// Diagnostic function to check socket health\nexport function checkSocketHealth(signalingService) {\n  if (!signalingService) return {\n    healthy: false,\n    reason: 'No signaling service'\n  };\n\n  // Basic connectivity check\n  const isConnected = signalingService.isConnected();\n  if (!isConnected) {\n    return {\n      healthy: false,\n      reason: 'Socket disconnected'\n    };\n  }\n\n  // Get more detailed status if available\n  const status = signalingService.getStatus ? signalingService.getStatus() : {\n    connected: isConnected\n  };\n\n  // Check if there are pending messages\n  if (status.pendingMessages && status.pendingMessages > 10) {\n    return {\n      healthy: false,\n      reason: `Too many pending messages (${status.pendingMessages})`,\n      status\n    };\n  }\n\n  // Check if the socket is in a reconnecting state\n  if (status.reconnecting) {\n    return {\n      healthy: false,\n      reason: 'Socket is trying to reconnect',\n      status\n    };\n  }\n\n  // Return healthy status with details\n  return {\n    healthy: true,\n    status\n  };\n}\n\n// Create a global socket health check that runs periodically\nexport function setupGlobalSocketHealthCheck(signalingService, userId, checkIntervalMs = 10000) {\n  if (!signalingService) return null;\n  console.log(`Setting up global socket health check every ${checkIntervalMs}ms`);\n  let consecutiveFailures = 0;\n  const MAX_FAILURES = 3;\n  const intervalId = setInterval(async () => {\n    const health = checkSocketHealth(signalingService);\n    if (!health.healthy) {\n      consecutiveFailures++;\n      console.warn(`Socket health check failed (${consecutiveFailures}/${MAX_FAILURES}): ${health.reason}`);\n      if (consecutiveFailures >= MAX_FAILURES) {\n        console.error(`${MAX_FAILURES} consecutive socket health checks failed, attempting recovery`);\n\n        // Try to reconnect\n        const success = await reconnectSocket(signalingService, userId);\n        if (success) {\n          consecutiveFailures = 0;\n          console.log('Socket recovery successful');\n\n          // Dispatch recovery event\n          try {\n            window.dispatchEvent(new CustomEvent('socket-recovered'));\n          } catch (e) {\n            // Ignore dispatch errors\n          }\n        } else {\n          console.error('Socket recovery failed');\n\n          // Dispatch failure event\n          try {\n            window.dispatchEvent(new CustomEvent('socket-recovery-failed'));\n          } catch (e) {\n            // Ignore dispatch errors\n          }\n        }\n      }\n    } else {\n      // Reset counter on successful health check\n      if (consecutiveFailures > 0) {\n        console.log('Socket health restored');\n        consecutiveFailures = 0;\n      }\n    }\n  }, checkIntervalMs);\n\n  // Return a function to stop the health check\n  return () => {\n    clearInterval(intervalId);\n    console.log('Global socket health check stopped');\n  };\n}\n\n// Function to help recover from call failure\nexport async function recoverFromCallFailure(webRTCService, targetUserId) {\n  console.log('Attempting to recover from call failure');\n\n  // 1. End any existing call\n  webRTCService.endCall(true);\n\n  // 2. Make sure socket is connected\n  const socketRecovered = await reconnectSocket(webRTCService.signalingService, webRTCService.userId);\n  if (!socketRecovered) {\n    console.error('Failed to recover socket connection');\n    return false;\n  }\n\n  // 3. Verify target user is still online\n  let isTargetOnline = false;\n  try {\n    isTargetOnline = await webRTCService.checkUserOnline(targetUserId);\n  } catch (e) {\n    console.error('Error checking if target user is online:', e);\n  }\n  if (!isTargetOnline) {\n    console.log('Target user is not online, cannot recover call');\n    return false;\n  }\n\n  // 4. Reset media resources\n  try {\n    await webRTCService.getLocalMedia(true, true);\n  } catch (e) {\n    console.error('Failed to reset media resources:', e);\n    return false;\n  }\n  console.log('Call recovery preparation complete, ready to try again');\n  return true;\n}","map":{"version":3,"names":["reconnectSocket","signalingService","userId","console","log","strategies","transport","delay","attempts","strategy","i","join","socket","io","opts","transports","success","attemptReconnect","err","error","Promise","resolve","setTimeout","timeout","isConnected","connectHandler","off","clearTimeout","timeoutId","send","once","connected","disconnect","e","warn","connect","reconnect","then","catch","checkSocketHealth","healthy","reason","status","getStatus","pendingMessages","reconnecting","setupGlobalSocketHealthCheck","checkIntervalMs","consecutiveFailures","MAX_FAILURES","intervalId","setInterval","health","window","dispatchEvent","CustomEvent","clearInterval","recoverFromCallFailure","webRTCService","targetUserId","endCall","socketRecovered","isTargetOnline","checkUserOnline","getLocalMedia"],"sources":["/Users/ang/V_Hack_Ver4_2/frontend2/src/components/services/ConnectionRecoveryUtils.js"],"sourcesContent":["// File: services/WebRTC/ConnectionRecoveryUtils.js\n\n/**\n * Utilities for WebRTC connection recovery and socket reconnection\n * Add this file to your project and import where needed\n */\n\n// Reliable socket reconnection with backoff\nexport async function reconnectSocket(signalingService, userId) {\n    if (!signalingService) return false;\n    \n    console.log('Starting socket reconnection attempt with backoff');\n    \n    // Try different transport strategies in sequence\n    const strategies = [\n      { transport: ['websocket', 'polling'], delay: 1000, attempts: 2 },\n      { transport: ['polling', 'websocket'], delay: 2000, attempts: 2 },\n      { transport: ['polling'], delay: 3000, attempts: 1 }\n    ];\n    \n    for (const strategy of strategies) {\n      // Try each strategy for the specified number of attempts\n      for (let i = 0; i < strategy.attempts; i++) {\n        console.log(`Trying reconnection with transports: ${strategy.transport.join(', ')} (attempt ${i+1}/${strategy.attempts})`);\n        \n        try {\n          // Configure transports\n          if (signalingService.socket && signalingService.socket.io) {\n            signalingService.socket.io.opts.transports = strategy.transport;\n          }\n          \n          // Try to reconnect\n          const success = await attemptReconnect(signalingService, userId, strategy.delay);\n          if (success) {\n            console.log('Reconnection successful!');\n            return true;\n          }\n        } catch (err) {\n          console.error('Error during reconnection attempt:', err);\n        }\n        \n        // Wait before trying next attempt\n        await new Promise(resolve => setTimeout(resolve, strategy.delay));\n      }\n    }\n    \n    console.log('All reconnection strategies failed');\n    return false;\n  }\n  \n  // Helper function for attempting a single reconnection\n  async function attemptReconnect(signalingService, userId, timeout) {\n    return new Promise((resolve) => {\n      // Already connected\n      if (signalingService.isConnected()) {\n        resolve(true);\n        return;\n      }\n      \n      console.log(`Attempting reconnection with ${timeout}ms timeout`);\n      \n      // Setup handlers for connection events\n      const connectHandler = () => {\n        if (signalingService.socket) {\n          signalingService.socket.off('connect', connectHandler);\n        }\n        clearTimeout(timeoutId);\n        \n        // Re-register after successful connection\n        if (userId) {\n          signalingService.send('register', userId);\n          console.log(`Re-registered as ${userId} after reconnection`);\n        }\n        \n        resolve(true);\n      };\n      \n      if (signalingService.socket) {\n        signalingService.socket.once('connect', connectHandler);\n        \n        // Clean up old connection before trying to connect\n        try {\n          if (signalingService.socket.connected) {\n            signalingService.socket.disconnect();\n          }\n        } catch (e) {\n          console.warn('Error cleaning up socket before reconnection:', e);\n        }\n        \n        // Try to connect\n        try {\n          signalingService.socket.connect();\n        } catch (e) {\n          console.error('Error attempting to connect socket:', e);\n        }\n      } else if (typeof signalingService.reconnect === 'function') {\n        // Use the reconnect method if available\n        signalingService.reconnect()\n          .then(success => {\n            if (success) {\n              connectHandler();\n            } else {\n              resolve(false);\n            }\n          })\n          .catch(() => resolve(false));\n      }\n      \n      // Set timeout for the attempt\n      const timeoutId = setTimeout(() => {\n        if (signalingService.socket) {\n          signalingService.socket.off('connect', connectHandler);\n        }\n        console.log('Reconnection attempt timed out');\n        resolve(false);\n      }, timeout);\n    });\n  }\n  \n  // Diagnostic function to check socket health\n  export function checkSocketHealth(signalingService) {\n    if (!signalingService) return { healthy: false, reason: 'No signaling service' };\n    \n    // Basic connectivity check\n    const isConnected = signalingService.isConnected();\n    if (!isConnected) {\n      return { healthy: false, reason: 'Socket disconnected' };\n    }\n    \n    // Get more detailed status if available\n    const status = signalingService.getStatus ? signalingService.getStatus() : { connected: isConnected };\n    \n    // Check if there are pending messages\n    if (status.pendingMessages && status.pendingMessages > 10) {\n      return { \n        healthy: false, \n        reason: `Too many pending messages (${status.pendingMessages})`,\n        status\n      };\n    }\n    \n    // Check if the socket is in a reconnecting state\n    if (status.reconnecting) {\n      return { \n        healthy: false, \n        reason: 'Socket is trying to reconnect',\n        status\n      };\n    }\n    \n    // Return healthy status with details\n    return { \n      healthy: true, \n      status\n    };\n  }\n  \n  // Create a global socket health check that runs periodically\n  export function setupGlobalSocketHealthCheck(signalingService, userId, checkIntervalMs = 10000) {\n    if (!signalingService) return null;\n    \n    console.log(`Setting up global socket health check every ${checkIntervalMs}ms`);\n    \n    let consecutiveFailures = 0;\n    const MAX_FAILURES = 3;\n    \n    const intervalId = setInterval(async () => {\n      const health = checkSocketHealth(signalingService);\n      \n      if (!health.healthy) {\n        consecutiveFailures++;\n        console.warn(`Socket health check failed (${consecutiveFailures}/${MAX_FAILURES}): ${health.reason}`);\n        \n        if (consecutiveFailures >= MAX_FAILURES) {\n          console.error(`${MAX_FAILURES} consecutive socket health checks failed, attempting recovery`);\n          \n          // Try to reconnect\n          const success = await reconnectSocket(signalingService, userId);\n          \n          if (success) {\n            consecutiveFailures = 0;\n            console.log('Socket recovery successful');\n            \n            // Dispatch recovery event\n            try {\n              window.dispatchEvent(new CustomEvent('socket-recovered'));\n            } catch (e) {\n              // Ignore dispatch errors\n            }\n          } else {\n            console.error('Socket recovery failed');\n            \n            // Dispatch failure event\n            try {\n              window.dispatchEvent(new CustomEvent('socket-recovery-failed'));\n            } catch (e) {\n              // Ignore dispatch errors\n            }\n          }\n        }\n      } else {\n        // Reset counter on successful health check\n        if (consecutiveFailures > 0) {\n          console.log('Socket health restored');\n          consecutiveFailures = 0;\n        }\n      }\n    }, checkIntervalMs);\n    \n    // Return a function to stop the health check\n    return () => {\n      clearInterval(intervalId);\n      console.log('Global socket health check stopped');\n    };\n  }\n  \n  // Function to help recover from call failure\n  export async function recoverFromCallFailure(webRTCService, targetUserId) {\n    console.log('Attempting to recover from call failure');\n    \n    // 1. End any existing call\n    webRTCService.endCall(true);\n    \n    // 2. Make sure socket is connected\n    const socketRecovered = await reconnectSocket(\n      webRTCService.signalingService, \n      webRTCService.userId\n    );\n    \n    if (!socketRecovered) {\n      console.error('Failed to recover socket connection');\n      return false;\n    }\n    \n    // 3. Verify target user is still online\n    let isTargetOnline = false;\n    try {\n      isTargetOnline = await webRTCService.checkUserOnline(targetUserId);\n    } catch (e) {\n      console.error('Error checking if target user is online:', e);\n    }\n    \n    if (!isTargetOnline) {\n      console.log('Target user is not online, cannot recover call');\n      return false;\n    }\n    \n    // 4. Reset media resources\n    try {\n      await webRTCService.getLocalMedia(true, true);\n    } catch (e) {\n      console.error('Failed to reset media resources:', e);\n      return false;\n    }\n    \n    console.log('Call recovery preparation complete, ready to try again');\n    return true;\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}