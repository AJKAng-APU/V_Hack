{"ast":null,"code":"/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n\n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // First try with both video and audio\n      const stream = await this._tryGetUserMedia(videoConstraints, audioConstraints);\n\n      // Debug log all tracks\n      this.logger.log('Got local stream with tracks:', stream.getTracks().map(t => `${t.kind}: ${t.enabled ? 'enabled' : 'disabled'}`).join(', '));\n\n      // Store stream in window for debugging\n      window.myLocalStream = stream;\n      return stream;\n    } catch (error) {\n      // If both fail, try audio only\n      if (videoConstraints && audioConstraints) {\n        this.logger.log('Failed to get video+audio, trying audio only');\n        try {\n          return await this._tryGetUserMedia(false, true);\n        } catch (audioError) {\n          this.logger.error('Failed to get audio-only access:', audioError.message);\n          throw audioError;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n  async _tryGetUserMedia(video, audio) {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video,\n        audio\n      });\n      this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n      this.localStream = stream;\n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n      // Re-throw with more user-friendly message\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Camera/microphone access was denied by the user');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n      } else if (error.name === 'NotReadableError') {\n        throw new Error('Media device is in use by another application');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle video on/off - IMPROVED VERSION\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    console.log('MediaManager:toggleVideo called with videoOff:', videoOff);\n    if (this.localStream) {\n      const videoTracks = this.localStream.getVideoTracks();\n      console.log('Video tracks found:', videoTracks.length);\n      if (videoTracks.length > 0) {\n        videoTracks.forEach(track => {\n          console.log('Video track before toggle, enabled:', track.enabled);\n          track.enabled = !videoOff;\n          console.log('Video track after toggle, enabled:', track.enabled);\n        });\n      } else {\n        this.logger.log('No video tracks found in local stream');\n\n        // If video should be on but no tracks exist, try to get video again\n        if (!videoOff) {\n          this.logger.log('Attempting to add video track since none exists');\n          navigator.mediaDevices.getUserMedia({\n            video: true\n          }).then(videoStream => {\n            const videoTrack = videoStream.getVideoTracks()[0];\n            if (videoTrack) {\n              this.localStream.addTrack(videoTrack);\n              this.logger.log('Added new video track to local stream');\n\n              // If we have callbacks set up, notify about the updated stream\n              if (this.callbacks.onLocalStream) {\n                this.callbacks.onLocalStream(this.localStream);\n              }\n            }\n          }).catch(err => this.logger.error('Failed to get video after toggle:', err));\n        }\n      }\n    } else {\n      this.logger.log('No local stream available for video toggle');\n\n      // Try to initialize stream if it doesn't exist and video should be on\n      if (!videoOff) {\n        this.logger.log('No stream exists but video requested - initializing media');\n        this.getLocalMedia(true, true).catch(err => this.logger.error('Failed to initialize media:', err));\n      }\n    }\n  }\n\n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\nexport default WebRTCMediaManager;","map":{"version":3,"names":["WebRTCMediaManager","constructor","logger","localStream","callbacks","onLocalStream","setCallbacks","hasLocalStream","getLocalMedia","videoConstraints","audioConstraints","stream","_tryGetUserMedia","log","getTracks","map","t","kind","enabled","join","window","myLocalStream","error","audioError","message","video","audio","navigator","mediaDevices","getUserMedia","name","Error","toggleAudio","muted","getAudioTracks","forEach","track","toggleVideo","videoOff","console","videoTracks","getVideoTracks","length","then","videoStream","videoTrack","addTrack","catch","err","stopLocalStream","stop","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCMediaManager.js"],"sourcesContent":["/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n  \n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n  \n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n  \n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // First try with both video and audio\n      const stream = await this._tryGetUserMedia(videoConstraints, audioConstraints);\n      \n      // Debug log all tracks\n      this.logger.log('Got local stream with tracks:', \n        stream.getTracks().map(t => `${t.kind}: ${t.enabled ? 'enabled' : 'disabled'}`).join(', '));\n      \n      // Store stream in window for debugging\n      window.myLocalStream = stream;\n      \n      return stream;\n    } catch (error) {\n      // If both fail, try audio only\n      if (videoConstraints && audioConstraints) {\n        this.logger.log('Failed to get video+audio, trying audio only');\n        try {\n          return await this._tryGetUserMedia(false, true);\n        } catch (audioError) {\n          this.logger.error('Failed to get audio-only access:', audioError.message);\n          throw audioError;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async _tryGetUserMedia(video, audio) {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video, audio\n      });\n      \n      this.logger.log(`Access granted to media: video=${!!video}, audio=${!!audio}`);\n      this.localStream = stream;\n      \n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      \n      return stream;\n    } catch (error) {\n      this.logger.error(`Media access error (video=${!!video}, audio=${!!audio}):`, error.message);\n      // Re-throw with more user-friendly message\n      if (error.name === 'NotAllowedError') {\n        throw new Error('Camera/microphone access was denied by the user');\n      } else if (error.name === 'NotFoundError') {\n        throw new Error(video ? 'Camera not found or disconnected' : 'Microphone not found');\n      } else if (error.name === 'NotReadableError') {\n        throw new Error('Media device is in use by another application');\n      } else {\n        throw error;\n      }\n    }\n  }\n  \n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Toggle video on/off - IMPROVED VERSION\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    console.log('MediaManager:toggleVideo called with videoOff:', videoOff);\n    \n    if (this.localStream) {\n      const videoTracks = this.localStream.getVideoTracks();\n      console.log('Video tracks found:', videoTracks.length);\n      \n      if (videoTracks.length > 0) {\n        videoTracks.forEach(track => {\n          console.log('Video track before toggle, enabled:', track.enabled);\n          track.enabled = !videoOff;\n          console.log('Video track after toggle, enabled:', track.enabled);\n        });\n      } else {\n        this.logger.log('No video tracks found in local stream');\n        \n        // If video should be on but no tracks exist, try to get video again\n        if (!videoOff) {\n          this.logger.log('Attempting to add video track since none exists');\n          navigator.mediaDevices.getUserMedia({ video: true })\n            .then(videoStream => {\n              const videoTrack = videoStream.getVideoTracks()[0];\n              if (videoTrack) {\n                this.localStream.addTrack(videoTrack);\n                this.logger.log('Added new video track to local stream');\n                \n                // If we have callbacks set up, notify about the updated stream\n                if (this.callbacks.onLocalStream) {\n                  this.callbacks.onLocalStream(this.localStream);\n                }\n              }\n            })\n            .catch(err => this.logger.error('Failed to get video after toggle:', err));\n        }\n      }\n    } else {\n      this.logger.log('No local stream available for video toggle');\n      \n      // Try to initialize stream if it doesn't exist and video should be on\n      if (!videoOff) {\n        this.logger.log('No stream exists but video requested - initializing media');\n        this.getLocalMedia(true, true)\n          .catch(err => this.logger.error('Failed to initialize media:', err));\n      }\n    }\n  }\n  \n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\n\nexport default WebRTCMediaManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}