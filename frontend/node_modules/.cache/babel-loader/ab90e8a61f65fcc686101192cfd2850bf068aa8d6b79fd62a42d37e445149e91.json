{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n\n        // Check Supabase session\n        const {\n          data: {\n            session\n          },\n          error\n        } = await supabase.auth.getSession();\n        if (error) {\n          throw error;\n        }\n        if (session) {\n          // Get user data from users table with doctor information\n          const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000 // 5 second timeout\n          );\n          if (userData.error) {\n            throw userData.error;\n          }\n\n          // Get 2FA status from user preferences\n          const {\n            data: prefsData\n          } = await supabase.from('user_preferences').select('two_factor_enabled, factor_id').eq('user_id', userData.data.user_id).single();\n\n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false,\n            twoFactorEnabled: (prefsData === null || prefsData === void 0 ? void 0 : prefsData.two_factor_enabled) || false,\n            factorId: (prefsData === null || prefsData === void 0 ? void 0 : prefsData.factor_id) || null\n          };\n\n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Skip WebRTC for demo accounts\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n\n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n\n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (event === 'SIGNED_IN' && session) {\n        // Handle sign in\n        const startTime = performance.now();\n\n        // Get user data\n        const userData = await fetchWithTimeout(supabase.from('users').select('*, doctor:doctors(*)').eq('email', session.user.email).single(), 5000);\n        if (!userData.error && userData.data) {\n          // Get 2FA status from user preferences\n          const {\n            data: prefsData\n          } = await supabase.from('user_preferences').select('two_factor_enabled, factor_id').eq('user_id', userData.data.user_id).single();\n\n          // Set up user object with potential doctor info\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false,\n            twoFactorEnabled: (prefsData === null || prefsData === void 0 ? void 0 : prefsData.two_factor_enabled) || false,\n            factorId: (prefsData === null || prefsData === void 0 ? void 0 : prefsData.factor_id) || null\n          };\n\n          // Check if this is a demo account\n          const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n          setIsDemoAccount(isDemo);\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n\n            // Store doctor information for future reference\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n\n            // Connect doctor to socket server ONLY if not a demo account\n            if (!isDemo) {\n              connectDoctorToSocket(userData.data.doctor_id);\n            }\n          } else {\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          setUser(userObj);\n          setIsAuthenticated(true);\n\n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n\n          // Log performance\n          const endTime = performance.now();\n          console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n        }\n      }\n      if (event === 'SIGNED_OUT') {\n        setUser(null);\n        setIsAuthenticated(false);\n        setIsDemoAccount(false);\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        localStorage.setItem('is_doctor', 'false');\n        localStorage.removeItem('doctor_id');\n      }\n    });\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = doctorId => {\n    try {\n      if (!doctorId) return;\n      const doctorSocketId = `doctor-${doctorId}`;\n\n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks\n        const callbacks = {\n          onIncomingCall: callerId => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n          }\n        };\n\n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n\n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          try {\n            if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async email => {\n    try {\n      const {\n        error\n      } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      if (error) throw error;\n      return {\n        success: true,\n        message: 'Verification email sent! Please check your inbox.'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return {\n        success: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // NEW: Two-Factor Authentication methods\n  const enrollMFA = async () => {\n    try {\n      // Start the enrollment process\n      const {\n        data,\n        error\n      } = await supabase.auth.mfa.enroll({\n        factorType: 'totp',\n        issuer: 'HealthSync',\n        friendlyName: 'Mobile Authenticator'\n      });\n      if (error) throw error;\n      return {\n        success: true,\n        qrCode: data.totp.qr_code,\n        secret: data.totp.secret,\n        factorId: data.id\n      };\n    } catch (error) {\n      console.error('Error enrolling in MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n  const verifyMFA = async (factorId, code) => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.auth.mfa.challenge({\n        factorId: factorId\n      });\n      if (error) throw error;\n\n      // Verify the challenge\n      const {\n        data: verifyData,\n        error: verifyError\n      } = await supabase.auth.mfa.verify({\n        factorId: factorId,\n        challengeId: data.id,\n        code: code\n      });\n      if (verifyError) throw verifyError;\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error verifying MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n  const unenrollMFA = async factorId => {\n    try {\n      const {\n        error\n      } = await supabase.auth.mfa.unenroll({\n        factorId: factorId\n      });\n      if (error) throw error;\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error disabling MFA:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Generate backup codes for account recovery\n  const generateBackupCodes = async userId => {\n    try {\n      // Generate 10 random codes\n      const codes = Array.from({\n        length: 10\n      }, () => Math.random().toString(36).substring(2, 8).toUpperCase());\n\n      // Store the codes in your database (in a real app, you'd hash these)\n      const {\n        error\n      } = await supabase.from('user_backup_codes').upsert(codes.map(code => ({\n        user_id: userId,\n        code: code,\n        used: false\n      })));\n      if (error) throw error;\n      return {\n        success: true,\n        codes\n      };\n    } catch (error) {\n      console.error('Error generating backup codes:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Update user profile method including 2FA status\n  const updateUserProfile = async updates => {\n    try {\n      if (!user) throw new Error('User not authenticated');\n\n      // Update Supabase Auth if email is changing\n      if (updates.email && updates.email !== user.email) {\n        const {\n          error: updateAuthError\n        } = await supabase.auth.updateUser({\n          email: updates.email\n        });\n        if (updateAuthError) throw updateAuthError;\n      }\n\n      // Update database record\n      const dataToUpdate = {};\n      if (updates.name) dataToUpdate.name = updates.name;\n      if (updates.avatar) dataToUpdate.avatar_url = updates.avatar;\n      if (Object.keys(dataToUpdate).length > 0) {\n        const {\n          error: updateError\n        } = await supabase.from('users').update(dataToUpdate).eq('user_id', user.id);\n        if (updateError) throw updateError;\n      }\n\n      // Update user preferences including 2FA status\n      if (updates.twoFactorEnabled !== undefined || updates.factorId !== undefined) {\n        const {\n          error: updatePrefsError\n        } = await supabase.from('user_preferences').upsert({\n          user_id: user.id,\n          two_factor_enabled: updates.twoFactorEnabled,\n          factor_id: updates.factorId\n        });\n        if (updatePrefsError) throw updatePrefsError;\n      }\n\n      // Update local user state\n      const updatedUser = {\n        ...user\n      };\n      if (updates.name) updatedUser.name = updates.name;\n      if (updates.email) updatedUser.email = updates.email;\n      if (updates.avatar) updatedUser.avatar = updates.avatar;\n      if (updates.twoFactorEnabled !== undefined) updatedUser.twoFactorEnabled = updates.twoFactorEnabled;\n      if (updates.factorId !== undefined) updatedUser.factorId = updates.factorId;\n      setUser(updatedUser);\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount,\n    signOut,\n    sendVerificationEmail,\n    updateUserProfile,\n    // 2FA methods\n    enrollMFA,\n    verifyMFA,\n    unenrollMFA,\n    generateBackupCodes\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: !loading && children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 528,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"aGqb4kBCFhIUwi7TyCaZ+wjjcvI=\");\n_c = AuthProvider;\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","webRTCService","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","loading","setLoading","isAuthenticated","setIsAuthenticated","isDemoAccount","setIsDemoAccount","checkUser","startTime","performance","now","data","session","error","auth","getSession","userData","fetchWithTimeout","from","select","eq","email","single","prefsData","user_id","userObj","id","name","isPremium","is_premium","avatar","avatar_url","isDoctor","is_doctor","twoFactorEnabled","two_factor_enabled","factorId","factor_id","doctor","doctorId","doctor_id","specialty","doctorAvailability","availability","doctorRating","rating","localStorage","setItem","toLowerCase","connectDoctorToSocket","removeItem","JSON","stringify","storedAuth","getItem","storedUser","parse","parseInt","replace","endTime","console","log","Math","round","message","authListener","onAuthStateChange","event","isDemo","subscription","unsubscribe","promise","timeoutMs","timer","timeoutPromise","Promise","_","reject","setTimeout","Error","result","race","clearTimeout","doctorSocketId","callbacks","onIncomingCall","callerId","initTimeoutId","initialize","err","socketTimeoutId","signalingService","isConnected","send","e","sendVerificationEmail","resend","type","success","signOut","enrollMFA","mfa","enroll","factorType","issuer","friendlyName","qrCode","totp","qr_code","secret","verifyMFA","code","challenge","verifyData","verifyError","verify","challengeId","unenrollMFA","unenroll","generateBackupCodes","userId","codes","Array","length","random","toString","substring","toUpperCase","upsert","map","used","updateUserProfile","updates","updateAuthError","updateUser","dataToUpdate","Object","keys","updateError","update","undefined","updatePrefsError","updatedUser","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/AuthProvider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport supabase from './supabaseClient';\nimport webRTCService from './services/WebRTCService';\n\n// Create auth context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isDemoAccount, setIsDemoAccount] = useState(false);\n\n  useEffect(() => {\n    // Check for existing session\n    const checkUser = async () => {\n      try {\n        // Start tracking loading time for performance analysis\n        const startTime = performance.now();\n        \n        // Check Supabase session\n        const { data: { session }, error } = await supabase.auth.getSession();\n        \n        if (error) {\n          throw error;\n        }\n        \n        if (session) {\n          // Get user data from users table with doctor information\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000 // 5 second timeout\n          );\n            \n          if (userData.error) {\n            throw userData.error;\n          }\n          \n          // Get 2FA status from user preferences\n          const { data: prefsData } = await supabase\n            .from('user_preferences')\n            .select('two_factor_enabled, factor_id')\n            .eq('user_id', userData.data.user_id)\n            .single();\n          \n          // Create the user object with all needed properties\n          const userObj = {\n            id: userData.data.user_id,\n            name: userData.data.name,\n            email: userData.data.email,\n            isPremium: userData.data.is_premium,\n            avatar: userData.data.avatar_url,\n            isDoctor: userData.data.is_doctor || false,\n            twoFactorEnabled: prefsData?.two_factor_enabled || false,\n            factorId: prefsData?.factor_id || null\n          };\n          \n          // If this is a doctor, add doctor details\n          if (userData.data.is_doctor && userData.data.doctor) {\n            userObj.doctorId = userData.data.doctor_id;\n            userObj.specialty = userData.data.doctor.specialty;\n            userObj.doctorAvailability = userData.data.doctor.availability;\n            userObj.doctorRating = userData.data.doctor.rating;\n            \n            // Store doctor information in localStorage\n            localStorage.setItem('is_doctor', 'true');\n            localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n            \n            // Skip WebRTC for demo accounts\n            if (userData.data.email.toLowerCase() !== 'doctor@healthsync.com') {\n              connectDoctorToSocket(userData.data.doctor_id);\n            } else {\n              setIsDemoAccount(true);\n            }\n          } else {\n            // Clear doctor flags if not a doctor\n            localStorage.setItem('is_doctor', 'false');\n            localStorage.removeItem('doctor_id');\n          }\n          \n          setUser(userObj);\n          setIsAuthenticated(true);\n          \n          // Store in localStorage\n          localStorage.setItem('healthsync_auth', 'true');\n          localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n        } else {\n          // Check localStorage as fallback (useful for demo mode)\n          const storedAuth = localStorage.getItem('healthsync_auth');\n          const storedUser = localStorage.getItem('healthsync_user');\n          \n          if (storedAuth === 'true' && storedUser) {\n            const userObj = JSON.parse(storedUser);\n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Check if this is a demo account\n            if (userObj.email === 'demo@healthsync.com' || userObj.email === 'doctor@healthsync.com') {\n              setIsDemoAccount(true);\n            }\n            // If the stored user is a doctor, connect to socket ONLY if not a demo account\n            else if (userObj.isDoctor && localStorage.getItem('doctor_id')) {\n              const doctorId = parseInt(localStorage.getItem('doctor_id').replace('doctor-', ''));\n              if (doctorId) {\n                connectDoctorToSocket(doctorId);\n              }\n            }\n          } else {\n            setUser(null);\n            setIsAuthenticated(false);\n          }\n        }\n        \n        // Log performance metrics\n        const endTime = performance.now();\n        console.log(`Auth check completed in ${Math.round(endTime - startTime)}ms`);\n      } catch (error) {\n        console.error('Auth error:', error.message);\n        // Clear any potentially corrupt local data\n        localStorage.removeItem('healthsync_auth');\n        localStorage.removeItem('healthsync_user');\n        setUser(null);\n        setIsAuthenticated(false);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Set up auth state listener\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (event === 'SIGNED_IN' && session) {\n          // Handle sign in\n          const startTime = performance.now();\n          \n          // Get user data\n          const userData = await fetchWithTimeout(\n            supabase\n              .from('users')\n              .select('*, doctor:doctors(*)')\n              .eq('email', session.user.email)\n              .single(),\n            5000\n          );\n          \n          if (!userData.error && userData.data) {\n            // Get 2FA status from user preferences\n            const { data: prefsData } = await supabase\n              .from('user_preferences')\n              .select('two_factor_enabled, factor_id')\n              .eq('user_id', userData.data.user_id)\n              .single();\n              \n            // Set up user object with potential doctor info\n            const userObj = {\n              id: userData.data.user_id,\n              name: userData.data.name,\n              email: userData.data.email,\n              isPremium: userData.data.is_premium,\n              avatar: userData.data.avatar_url,\n              isDoctor: userData.data.is_doctor || false,\n              twoFactorEnabled: prefsData?.two_factor_enabled || false,\n              factorId: prefsData?.factor_id || null\n            };\n            \n            // Check if this is a demo account\n            const isDemo = userData.data.email.toLowerCase() === 'demo@healthsync.com' || \n                          userData.data.email.toLowerCase() === 'doctor@healthsync.com';\n            \n            setIsDemoAccount(isDemo);\n            \n            if (userData.data.is_doctor && userData.data.doctor) {\n              userObj.doctorId = userData.data.doctor_id;\n              userObj.specialty = userData.data.doctor.specialty;\n              userObj.doctorAvailability = userData.data.doctor.availability;\n              userObj.doctorRating = userData.data.doctor.rating;\n              \n              // Store doctor information for future reference\n              localStorage.setItem('is_doctor', 'true');\n              localStorage.setItem('doctor_id', `doctor-${userData.data.doctor_id}`);\n              \n              // Connect doctor to socket server ONLY if not a demo account\n              if (!isDemo) {\n                connectDoctorToSocket(userData.data.doctor_id);\n              }\n            } else {\n              localStorage.setItem('is_doctor', 'false');\n              localStorage.removeItem('doctor_id');\n            }\n            \n            setUser(userObj);\n            setIsAuthenticated(true);\n            \n            // Store in localStorage\n            localStorage.setItem('healthsync_auth', 'true');\n            localStorage.setItem('healthsync_user', JSON.stringify(userObj));\n            \n            // Log performance\n            const endTime = performance.now();\n            console.log(`Sign in completed in ${Math.round(endTime - startTime)}ms`);\n          }\n        }\n        \n        if (event === 'SIGNED_OUT') {\n          setUser(null);\n          setIsAuthenticated(false);\n          setIsDemoAccount(false);\n          localStorage.removeItem('healthsync_auth');\n          localStorage.removeItem('healthsync_user');\n          localStorage.setItem('is_doctor', 'false');\n          localStorage.removeItem('doctor_id');\n        }\n      }\n    );\n\n    checkUser();\n\n    // Clean up subscription\n    return () => {\n      if (authListener && authListener.subscription) {\n        authListener.subscription.unsubscribe();\n      }\n    };\n  }, []);\n\n  // Helper function for request timeouts\n  const fetchWithTimeout = async (promise, timeoutMs = 5000) => {\n    let timer;\n    const timeoutPromise = new Promise((_, reject) => {\n      timer = setTimeout(() => reject(new Error('Request timed out')), timeoutMs);\n    });\n    \n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timer);\n      return result;\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  };\n\n  // Function to connect a doctor to the socket server\n  const connectDoctorToSocket = (doctorId) => {\n    try {\n      if (!doctorId) return;\n      \n      const doctorSocketId = `doctor-${doctorId}`;\n      \n      // Initialize WebRTC service with doctor ID\n      if (webRTCService) {\n        // Set up callbacks\n        const callbacks = {\n          onIncomingCall: (callerId) => {\n            console.log(`Doctor ${doctorId} received incoming call from: ${callerId}`);\n          }\n        };\n        \n        // Initialize with doctor ID, but with a timeout\n        const initTimeoutId = setTimeout(() => {\n          console.log('WebRTC initialization timed out, continuing without it');\n        }, 5000);\n        \n        try {\n          webRTCService.initialize(doctorSocketId, callbacks);\n          clearTimeout(initTimeoutId);\n        } catch (err) {\n          console.error('WebRTC initialization error:', err);\n          clearTimeout(initTimeoutId);\n        }\n        \n        // Ensure the doctor is registered with the signaling server with timeout\n        setTimeout(() => {\n          const socketTimeoutId = setTimeout(() => {\n            console.log('Socket registration timed out, continuing without it');\n          }, 3000);\n          \n          try {\n            if (webRTCService.signalingService && \n                webRTCService.signalingService.isConnected()) {\n              webRTCService.signalingService.send('register', doctorSocketId);\n              console.log(`Doctor registered with socket server: ${doctorSocketId}`);\n              clearTimeout(socketTimeoutId);\n            } else {\n              console.log(\"Socket not connected yet, trying again in 1s\");\n              setTimeout(() => {\n                try {\n                  if (webRTCService.signalingService) {\n                    webRTCService.signalingService.send('register', doctorSocketId);\n                    console.log(`Delayed registration for doctor: ${doctorSocketId}`);\n                  }\n                  clearTimeout(socketTimeoutId);\n                } catch (e) {\n                  console.error(\"Error in delayed registration:\", e);\n                  clearTimeout(socketTimeoutId);\n                }\n              }, 1000);\n            }\n          } catch (e) {\n            console.error(\"Error in socket registration:\", e);\n            clearTimeout(socketTimeoutId);\n          }\n        }, 500);\n      } else {\n        console.error(\"WebRTCService not available\");\n      }\n    } catch (error) {\n      console.error(\"Error connecting doctor to socket:\", error);\n    }\n  };\n\n  // Helper function to send email verification\n  const sendVerificationEmail = async (email) => {\n    try {\n      const { error } = await supabase.auth.resend({\n        type: 'signup',\n        email: email\n      });\n      \n      if (error) throw error;\n      \n      return { \n        success: true, \n        message: 'Verification email sent! Please check your inbox.' \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error.message \n      };\n    }\n  };\n\n  // Sign out function\n  const signOut = async () => {\n    try {\n      await supabase.auth.signOut();\n      // Clear local storage\n      localStorage.removeItem('healthsync_auth');\n      localStorage.removeItem('healthsync_user');\n      localStorage.setItem('is_doctor', 'false');\n      localStorage.removeItem('doctor_id');\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsDemoAccount(false);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    }\n  };\n\n  // NEW: Two-Factor Authentication methods\n  const enrollMFA = async () => {\n    try {\n      // Start the enrollment process\n      const { data, error } = await supabase.auth.mfa.enroll({\n        factorType: 'totp',\n        issuer: 'HealthSync',\n        friendlyName: 'Mobile Authenticator'\n      });\n      \n      if (error) throw error;\n      \n      return {\n        success: true,\n        qrCode: data.totp.qr_code,\n        secret: data.totp.secret,\n        factorId: data.id\n      };\n    } catch (error) {\n      console.error('Error enrolling in MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  const verifyMFA = async (factorId, code) => {\n    try {\n      const { data, error } = await supabase.auth.mfa.challenge({\n        factorId: factorId\n      });\n      \n      if (error) throw error;\n      \n      // Verify the challenge\n      const { data: verifyData, error: verifyError } = await supabase.auth.mfa.verify({\n        factorId: factorId,\n        challengeId: data.id,\n        code: code\n      });\n      \n      if (verifyError) throw verifyError;\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error verifying MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  const unenrollMFA = async (factorId) => {\n    try {\n      const { error } = await supabase.auth.mfa.unenroll({\n        factorId: factorId\n      });\n      \n      if (error) throw error;\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error disabling MFA:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Generate backup codes for account recovery\n  const generateBackupCodes = async (userId) => {\n    try {\n      // Generate 10 random codes\n      const codes = Array.from({ length: 10 }, () => \n        Math.random().toString(36).substring(2, 8).toUpperCase()\n      );\n      \n      // Store the codes in your database (in a real app, you'd hash these)\n      const { error } = await supabase\n        .from('user_backup_codes')\n        .upsert(\n          codes.map(code => ({\n            user_id: userId,\n            code: code,\n            used: false\n          }))\n        );\n        \n      if (error) throw error;\n      \n      return { success: true, codes };\n    } catch (error) {\n      console.error('Error generating backup codes:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Update user profile method including 2FA status\n  const updateUserProfile = async (updates) => {\n    try {\n      if (!user) throw new Error('User not authenticated');\n      \n      // Update Supabase Auth if email is changing\n      if (updates.email && updates.email !== user.email) {\n        const { error: updateAuthError } = await supabase.auth.updateUser({\n          email: updates.email\n        });\n        \n        if (updateAuthError) throw updateAuthError;\n      }\n      \n      // Update database record\n      const dataToUpdate = {};\n      if (updates.name) dataToUpdate.name = updates.name;\n      if (updates.avatar) dataToUpdate.avatar_url = updates.avatar;\n      \n      if (Object.keys(dataToUpdate).length > 0) {\n        const { error: updateError } = await supabase\n          .from('users')\n          .update(dataToUpdate)\n          .eq('user_id', user.id);\n          \n        if (updateError) throw updateError;\n      }\n      \n      // Update user preferences including 2FA status\n      if (updates.twoFactorEnabled !== undefined || updates.factorId !== undefined) {\n        const { error: updatePrefsError } = await supabase\n          .from('user_preferences')\n          .upsert({\n            user_id: user.id,\n            two_factor_enabled: updates.twoFactorEnabled,\n            factor_id: updates.factorId\n          });\n          \n        if (updatePrefsError) throw updatePrefsError;\n      }\n      \n      // Update local user state\n      const updatedUser = { ...user };\n      if (updates.name) updatedUser.name = updates.name;\n      if (updates.email) updatedUser.email = updates.email;\n      if (updates.avatar) updatedUser.avatar = updates.avatar;\n      if (updates.twoFactorEnabled !== undefined) updatedUser.twoFactorEnabled = updates.twoFactorEnabled;\n      if (updates.factorId !== undefined) updatedUser.factorId = updates.factorId;\n      \n      setUser(updatedUser);\n      localStorage.setItem('healthsync_user', JSON.stringify(updatedUser));\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error updating profile:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  // Value to be provided to consuming components\n  const value = {\n    user,\n    isAuthenticated,\n    loading,\n    isDemoAccount,\n    signOut,\n    sendVerificationEmail,\n    updateUserProfile,\n    // 2FA methods\n    enrollMFA,\n    verifyMFA,\n    unenrollMFA,\n    generateBackupCodes\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}