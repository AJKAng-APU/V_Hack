{"ast":null,"code":"import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management and error handling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n\n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n\n    // ENHANCED: Centralized call state management\n    this.callState = 'idle'; // idle, connecting, active, ended\n\n    // Helper methods for state checking\n    this.isCallActive = () => ['connecting', 'active'].includes(this.callState);\n    this.isCallConnected = () => this.callState === 'active';\n\n    // ENHANCED: Simple event system for better component coordination\n    this.eventListeners = {};\n\n    // Connection stability enhancements\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.disconnectionTimer = null;\n    this.disconnectionFailureTimer = null; // ENHANCED: Added longer timeout timer\n    this.failureTimeout = null; // New timeout for failure conditions\n    this.lastOffer = null;\n    this.iceConnectionState = null; // ENHANCED: Track previous state\n\n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n    this.onUserNotOnline = null;\n    this.onCallDeclined = null;\n    this.onCallInProgress = null;\n\n    // Initialization state\n    this.isInitialized = false;\n  }\n\n  /**\n   * Log messages with timestamp and store in localStorage\n   */\n  log(message, data = null) {\n    const timestamp = new Date().toISOString().split('T')[1].substring(0, 8);\n    const prefix = `[WebRTC ${timestamp}]`;\n    if (data) {\n      console.log(prefix, message, data);\n    } else {\n      console.log(prefix, message);\n    }\n\n    // Store logs in localStorage for debugging across page refreshes\n    const logs = JSON.parse(localStorage.getItem('webrtc_logs') || '[]');\n    logs.push({\n      timestamp: new Date().toISOString(),\n      message,\n      data: data ? JSON.stringify(data) : null\n    });\n\n    // Keep only the last 100 logs\n    if (logs.length > 100) {\n      logs.shift();\n    }\n    localStorage.setItem('webrtc_logs', JSON.stringify(logs));\n  }\n\n  /**\n   * ENHANCED: Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.log(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n\n    // Emit error event for UI components to handle\n    this.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n\n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * ENHANCED: Event emission system\n   */\n  emit(event, data) {\n    if (this.eventListeners[event]) {\n      this.eventListeners[event].forEach(callback => callback(data));\n    }\n  }\n\n  /**\n   * ENHANCED: Event subscription system\n   * Returns a function to unsubscribe the listener\n   */\n  on(event, callback) {\n    if (!this.eventListeners[event]) {\n      this.eventListeners[event] = [];\n    }\n    this.eventListeners[event].push(callback);\n\n    // Return a function to remove the listener\n    return () => {\n      this.eventListeners[event] = this.eventListeners[event].filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * ENHANCED: Centralized call state management\n   */\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.log(`Call state changing from ${this.callState} to ${newState}`);\n      this.callState = newState;\n\n      // Emit event for UI components\n      this.emit('callStateChanged', newState);\n\n      // Trigger appropriate callbacks\n      if (newState === 'active' && this.onCallStarted) this.onCallStarted();\n      if (newState === 'ended' && this.onCallEnded) this.onCallEnded();\n      if (newState === 'connecting' && this.onCallConnecting) this.onCallConnecting();\n    }\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    this.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Set up callbacks\n    this.updateCallbacks(callbacks);\n\n    // Connect to the signaling server if not already connected\n    if (!this.socket || !this.socket.connected) {\n      // Use provided URL, fallback to production URL, then localhost as last resort\n      const signalingServer = serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001';\n      this.log('Connecting to signaling server:', signalingServer);\n      this.socket = io(signalingServer);\n\n      // Set up event listeners for signaling messages\n      this.setupSocketListeners();\n    }\n\n    // Register user ID with the signaling server\n    if (this.socket) {\n      this.socket.emit('register', userId);\n    }\n    this.isInitialized = true;\n  }\n\n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    // Only update provided callbacks, keep existing ones otherwise\n    if (callbacks.onLocalStream !== undefined) this.onLocalStream = callbacks.onLocalStream;\n    if (callbacks.onRemoteStream !== undefined) this.onRemoteStream = callbacks.onRemoteStream;\n    if (callbacks.onCallStarted !== undefined) this.onCallStarted = callbacks.onCallStarted;\n    if (callbacks.onCallEnded !== undefined) this.onCallEnded = callbacks.onCallEnded;\n    if (callbacks.onCallConnecting !== undefined) this.onCallConnecting = callbacks.onCallConnecting;\n    if (callbacks.onIncomingCall !== undefined) this.onIncomingCall = callbacks.onIncomingCall;\n    if (callbacks.onICEConnectionStateChange !== undefined) this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange;\n    if (callbacks.onUserNotOnline !== undefined) this.onUserNotOnline = callbacks.onUserNotOnline;\n    if (callbacks.onCallDeclined !== undefined) this.onCallDeclined = callbacks.onCallDeclined;\n    if (callbacks.onCallInProgress !== undefined) this.onCallInProgress = callbacks.onCallInProgress;\n\n    // Initialize default callback functions if not already set\n    this.onLocalStream = this.onLocalStream || (() => {});\n    this.onRemoteStream = this.onRemoteStream || (() => {});\n    this.onCallStarted = this.onCallStarted || (() => {});\n    this.onCallEnded = this.onCallEnded || (() => {});\n    this.onCallConnecting = this.onCallConnecting || (() => {});\n    this.onIncomingCall = this.onIncomingCall || (() => {});\n    this.onICEConnectionStateChange = this.onICEConnectionStateChange || (() => {});\n    this.onUserNotOnline = this.onUserNotOnline || (() => {});\n    this.onCallDeclined = this.onCallDeclined || (() => {});\n    this.onCallInProgress = this.onCallInProgress || (() => {});\n  }\n\n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({\n      callerUserId,\n      offerSDP\n    }) => {\n      this.log('Incoming call from:', callerUserId);\n\n      // If there's already an active call, ignore this one\n      if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n        this.log('Already in a call, ignoring incoming call');\n        // Explicitly decline the call so the caller knows\n        this.socket.emit('call-declined', {\n          targetUserId: callerUserId\n        });\n        return;\n      }\n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n\n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n\n      // Update call state\n      this.updateCallState('connecting');\n\n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n\n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({\n      answerSDP\n    }) => {\n      this.log('Call was answered, setting remote description');\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answerSDP));\n        }\n      } catch (error) {\n        this.handleError('setting remote description', error);\n      }\n    });\n    this.socket.on('call-in-progress', ({\n      callerUserId\n    }) => {\n      this.log('Call in progress on another device with:', callerUserId);\n      // You can notify the UI if desired\n      if (typeof this.onCallInProgress === 'function') {\n        this.onCallInProgress(callerUserId);\n      }\n    });\n\n    // Add handler for declined calls\n    this.socket.on('call-declined', () => {\n      this.log('Call was declined by the recipient');\n      this.updateCallState('ended');\n      this.endCall(false); // Don't notify the other person since they declined it\n\n      // Notify the application\n      if (typeof this.onCallDeclined === 'function') {\n        this.onCallDeclined();\n      }\n    });\n\n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({\n      candidate\n    }) => {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n          this.log('Added ICE candidate');\n        }\n      } catch (error) {\n        this.handleError('adding ICE candidate', error);\n      }\n    });\n\n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      this.log('Call ended remotely');\n      this.updateCallState('ended');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n\n    // Handle call failure\n    this.socket.on('call-failed', ({\n      message,\n      targetUserId\n    }) => {\n      this.log('Call failed:', message);\n\n      // Handle user not online case\n      if (message === 'User is not online') {\n        if (this.onUserNotOnline) {\n          this.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n      } else {\n        this.updateCallState('ended');\n      }\n      this.resetCallState();\n    });\n\n    // Handle user online status\n    this.socket.on('user-online-status', ({\n      userId,\n      isOnline,\n      responseId\n    }) => {\n      this.log('User online status received:', {\n        userId,\n        isOnline,\n        responseId\n      });\n      // The responseId is now used to match requests with responses\n      this.emit(`online-status-${responseId}`, {\n        userId,\n        isOnline\n      });\n    });\n  }\n  declineCall() {\n    if (this.targetUserId) {\n      this.log('Declining call from:', this.targetUserId);\n      this.socket.emit('call-declined', {\n        targetUserId: this.targetUserId\n      });\n      this.resetCallState();\n    }\n  }\n\n  /**\n   * ENHANCED: Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  checkUserOnline(userId) {\n    return new Promise(resolve => {\n      if (!this.socket || !this.socket.connected) {\n        this.log('Socket not connected, user is offline');\n        resolve(false);\n        return;\n      }\n\n      // Create a unique request ID to match the response\n      const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      this.log('Checking if user is online:', userId, 'with requestId:', requestId);\n      this.socket.emit('check-user-online', {\n        userId,\n        requestId\n      });\n\n      // Set up a one-time event listener specific to this request\n      const cleanupListener = this.on(`online-status-${requestId}`, ({\n        userId: responseUserId,\n        isOnline\n      }) => {\n        if (responseUserId === userId) {\n          clearTimeout(timeout);\n          this.log('User online status for', userId, ':', isOnline);\n          resolve(isOnline);\n        }\n      });\n\n      // Set a timeout in case we never get a response\n      const timeout = setTimeout(() => {\n        cleanupListener(); // Remove the listener\n        this.log('User online check timed out for:', userId);\n        resolve(false);\n      }, 5000);\n    });\n  }\n\n  /**\n   * ENHANCED: Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    this.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n    try {\n      if (!this.peerConnection) {\n        this.log('No peer connection to reconnect');\n        return;\n      }\n\n      // First try to restart ICE\n      this.peerConnection.restartIce();\n\n      // For more aggressive reconnection, try recreating the offer\n      if (aggressive || this.isCallInitiator) {\n        this.log('Creating new offer with ICE restart');\n        const offer = await this.peerConnection.createOffer({\n          iceRestart: true,\n          offerToReceiveAudio: true,\n          offerToReceiveVideo: true\n        });\n        await this.peerConnection.setLocalDescription(offer);\n\n        // Store the new offer\n        this.lastOffer = offer;\n\n        // Send the new offer to the other user\n        this.socket.emit('call-user', {\n          targetUserId: this.targetUserId,\n          offerSDP: offer,\n          callerUserId: this.userId\n        });\n        this.log('Sent new offer for reconnection');\n      }\n    } catch (error) {\n      this.handleError('reconnection attempt', error);\n    }\n  }\n\n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      if (!isOnline) {\n        this.log('Cannot make call - user is not online:', targetUserId);\n        if (this.onUserNotOnline) {\n          this.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        return;\n      }\n\n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      this.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n\n      // Create an offer (SDP)\n      this.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n\n      // Store offer for potential reconnection\n      this.lastOffer = offer;\n\n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n\n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      this.log('Call offer sent');\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      this.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create peer connection\n      this.initializePeerConnection();\n\n      // Set the remote description from the stored offer\n      this.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(new RTCSessionDescription(this.pendingOffer));\n\n      // Create an answer\n      this.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n\n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n\n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      this.log('Call accepted, answer sent');\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n\n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.log('Ending call, notify peer:', notifyPeer);\n\n    // Clear all timers first\n    [this.disconnectionTimer, this.disconnectionFailureTimer, this.failureTimeout].forEach(timer => {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    });\n\n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      // If the call is in connecting state, decline it instead of ending\n      if (!this.isCallConnected() && this.callState === 'connecting') {\n        this.socket.emit('call-declined', {\n          targetUserId: this.targetUserId\n        });\n      } else {\n        this.socket.emit('end-call', {\n          targetUserId: this.targetUserId\n        });\n      }\n    }\n\n    // Close peer connection with careful cleanup\n    if (this.peerConnection) {\n      // Remove all event listeners first\n      this.peerConnection.onicecandidate = null;\n      this.peerConnection.ontrack = null;\n      this.peerConnection.oniceconnectionstatechange = null;\n      this.peerConnection.onicegatheringstatechange = null;\n      this.peerConnection.onsignalingstatechange = null;\n      this.peerConnection.onconnectionstatechange = null;\n\n      // Close the connection\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n\n    // Update call state\n    this.updateCallState('ended');\n\n    // Reset state\n    this.resetCallState();\n  }\n\n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.reconnectionAttempts = 0;\n    this.iceConnectionState = null;\n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n      this.disconnectionTimer = null;\n    }\n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n      this.disconnectionFailureTimer = null;\n    }\n    if (this.failureTimeout) {\n      clearTimeout(this.failureTimeout);\n      this.failureTimeout = null;\n    }\n    this.lastOffer = null;\n  }\n\n  /**\n   * Initialize the WebRTC peer connection\n   */\n  initializePeerConnection() {\n    // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n    const configuration = {\n      iceServers: [\n      // Multiple STUN servers for better connectivity\n      {\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }, {\n        urls: 'stun:stun3.l.google.com:19302'\n      }, {\n        urls: 'stun:stun4.l.google.com:19302'\n      },\n      // Free TURN server (replace with your own in production)\n      {\n        urls: 'turn:openrelay.metered.ca:80',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      }, {\n        urls: 'turn:openrelay.metered.ca:443',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      },\n      // If environment variables exist, add them too\n      ...(process.env.REACT_APP_TURN_SERVER ? [{\n        urls: process.env.REACT_APP_TURN_SERVER,\n        username: process.env.REACT_APP_TURN_USERNAME || '',\n        credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n      }] : [])],\n      iceCandidatePoolSize: 10,\n      // The following helps with connection stability\n      sdpSemantics: 'unified-plan'\n    };\n    this.log('Initializing peer connection with configuration:', configuration);\n\n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n\n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = event => {\n      this.log('Received remote track:', event.track.kind);\n\n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n\n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        this.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n\n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        const candidateStr = event.candidate.candidate || '';\n        const candidateType = candidateStr.split(' ')[7] || 'unknown'; // Extract type (host, srflx, relay)\n        this.log('Generated ICE candidate of type:', candidateType);\n\n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Additional monitoring for ICE gathering state\n    this.peerConnection.onicegatheringstatechange = () => {\n      this.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      this.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.log('Connection state changed:', this.peerConnection.connectionState);\n    };\n\n    // ENHANCED: Improved ICE connection state handling with better state tracking\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      const previousState = this.iceConnectionState;\n      this.iceConnectionState = state;\n      this.log('ICE connection state changed to:', state, 'from:', previousState);\n      this.onICEConnectionStateChange(state);\n\n      // Handle connection establishment\n      if (state === 'connected' || state === 'completed') {\n        this.log('Call connected successfully!');\n        if (!this.isCallConnected()) {\n          this.updateCallState('active');\n\n          // Reset reconnection attempts\n          this.reconnectionAttempts = 0;\n\n          // Clear any pending timers\n          if (this.disconnectionTimer) {\n            clearTimeout(this.disconnectionTimer);\n            this.disconnectionTimer = null;\n          }\n          if (this.disconnectionFailureTimer) {\n            clearTimeout(this.disconnectionFailureTimer);\n            this.disconnectionFailureTimer = null;\n          }\n          if (this.failureTimeout) {\n            clearTimeout(this.failureTimeout);\n            this.failureTimeout = null;\n          }\n        }\n      }\n      // Add timeout check to avoid premature failure\n      else if (state === 'failed') {\n        this.log('Connection failed');\n        if (!this.failureTimeout) {\n          this.failureTimeout = setTimeout(() => {\n            if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n              // Attempt to restart ICE if possible before ending the call\n              if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n                this.reconnectionAttempts++;\n                this.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n\n                // Try to reconnect using our enhanced method\n                this.attemptReconnection(true);\n              } else {\n                this.log('Max reconnection attempts reached, ending call');\n                this.updateCallState('ended');\n                this.endCall(true);\n              }\n            }\n            this.failureTimeout = null;\n          }, 1000);\n        }\n      }\n      // For disconnected state, implement improved timer-based approach\n      else if (state === 'disconnected') {\n        this.log('Connection temporarily disconnected');\n\n        // Clear any existing timers first\n        if (this.disconnectionTimer) {\n          clearTimeout(this.disconnectionTimer);\n        }\n        if (this.disconnectionFailureTimer) {\n          clearTimeout(this.disconnectionFailureTimer);\n        }\n\n        // Start with a short timer for normal recovery\n        this.disconnectionTimer = setTimeout(() => {\n          // If still disconnected after short period, try recovery\n          if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n            this.log('Connection still disconnected, attempting recovery...');\n            this.attemptReconnection(false);\n          }\n          this.disconnectionTimer = null;\n        }, 2000); // Try recovery after 2 seconds\n\n        // Also set a longer timeout for full failure\n        this.disconnectionFailureTimer = setTimeout(() => {\n          if (this.peerConnection && (this.peerConnection.iceConnectionState === 'disconnected' || this.peerConnection.iceConnectionState === 'failed')) {\n            this.log('Connection remained disconnected for too long');\n            this.updateCallState('ended');\n            this.endCall(true);\n          }\n          this.disconnectionFailureTimer = null;\n        }, 15000); // End call after 15 seconds of disconnection\n      }\n      // Clear any timeout if state improves\n      else if ((state === 'checking' || state === 'connected') && (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n        // Clear timers if we've recovered\n        if (this.failureTimeout) {\n          clearTimeout(this.failureTimeout);\n          this.failureTimeout = null;\n        }\n        if (this.disconnectionTimer) {\n          clearTimeout(this.disconnectionTimer);\n          this.disconnectionTimer = null;\n        }\n        if (this.disconnectionFailureTimer) {\n          clearTimeout(this.disconnectionFailureTimer);\n          this.disconnectionFailureTimer = null;\n        }\n      }\n    };\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      this.log('Requesting access to local media with constraints:', {\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n\n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      this.log('Access to local media granted');\n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      // Classify and handle errors more specifically\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.handleError('media permissions', new Error('Camera or microphone access was denied'), true);\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.handleError('media devices', new Error('No camera or microphone found'), true);\n      } else {\n        this.handleError('accessing media devices', error, true);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n\n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    // Reset initialization status\n    this.isInitialized = false;\n\n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["io","WebRTCService","constructor","socket","peerConnection","localStream","remoteStream","userId","targetUserId","isCallInitiator","pendingOffer","callState","isCallActive","includes","isCallConnected","eventListeners","reconnectionAttempts","maxReconnectionAttempts","disconnectionTimer","disconnectionFailureTimer","failureTimeout","lastOffer","iceConnectionState","onLocalStream","onRemoteStream","onCallStarted","onCallEnded","onCallConnecting","onIncomingCall","onICEConnectionStateChange","onUserNotOnline","onCallDeclined","onCallInProgress","isInitialized","log","message","data","timestamp","Date","toISOString","split","substring","prefix","console","logs","JSON","parse","localStorage","getItem","push","stringify","length","shift","setItem","handleError","context","error","fatal","emit","updateCallState","endCall","event","forEach","callback","on","filter","cb","newState","initialize","callbacks","serverUrl","updateCallbacks","disconnect","connected","signalingServer","process","env","REACT_APP_SIGNALING_SERVER","setupSocketListeners","undefined","callerUserId","offerSDP","answerSDP","setRemoteDescription","RTCSessionDescription","candidate","addIceCandidate","RTCIceCandidate","resetCallState","isOnline","responseId","declineCall","checkUserOnline","Promise","resolve","requestId","now","Math","random","toString","cleanupListener","responseUserId","clearTimeout","timeout","setTimeout","attemptReconnection","aggressive","restartIce","offer","createOffer","iceRestart","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","makeCall","getLocalMedia","initializePeerConnection","acceptCall","answer","createAnswer","notifyPeer","timer","onicecandidate","ontrack","oniceconnectionstatechange","onicegatheringstatechange","onsignalingstatechange","onconnectionstatechange","close","getTracks","track","kind","stop","configuration","iceServers","urls","username","credential","REACT_APP_TURN_SERVER","REACT_APP_TURN_USERNAME","REACT_APP_TURN_CREDENTIAL","iceCandidatePoolSize","sdpSemantics","RTCPeerConnection","addTrack","MediaStream","streams","candidateStr","candidateType","iceGatheringState","signalingState","connectionState","state","previousState","videoConstraints","audioConstraints","video","audio","stream","navigator","mediaDevices","getUserMedia","name","Error","toggleAudio","muted","getAudioTracks","enabled","toggleVideo","videoOff","getVideoTracks","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["import io from 'socket.io-client';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management and error handling\n */\nclass WebRTCService {\n  constructor() {\n    // Connection objects\n    this.socket = null;\n    this.peerConnection = null;\n    \n    // Media streams\n    this.localStream = null;\n    this.remoteStream = null;\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    \n    // ENHANCED: Centralized call state management\n    this.callState = 'idle'; // idle, connecting, active, ended\n    \n    // Helper methods for state checking\n    this.isCallActive = () => ['connecting', 'active'].includes(this.callState);\n    this.isCallConnected = () => this.callState === 'active';\n    \n    // ENHANCED: Simple event system for better component coordination\n    this.eventListeners = {};\n    \n    // Connection stability enhancements\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.disconnectionTimer = null;\n    this.disconnectionFailureTimer = null; // ENHANCED: Added longer timeout timer\n    this.failureTimeout = null; // New timeout for failure conditions\n    this.lastOffer = null;\n    this.iceConnectionState = null; // ENHANCED: Track previous state\n    \n    // Callback functions\n    this.onLocalStream = null;\n    this.onRemoteStream = null;\n    this.onCallStarted = null;\n    this.onCallEnded = null;\n    this.onCallConnecting = null;\n    this.onIncomingCall = null;\n    this.onICEConnectionStateChange = null;\n    this.onUserNotOnline = null;\n    this.onCallDeclined = null;\n    this.onCallInProgress = null;\n    \n    // Initialization state\n    this.isInitialized = false;\n  }\n  \n  /**\n   * Log messages with timestamp and store in localStorage\n   */\n  log(message, data = null) {\n    const timestamp = new Date().toISOString().split('T')[1].substring(0, 8);\n    const prefix = `[WebRTC ${timestamp}]`;\n    \n    if (data) {\n      console.log(prefix, message, data);\n    } else {\n      console.log(prefix, message);\n    }\n    \n    // Store logs in localStorage for debugging across page refreshes\n    const logs = JSON.parse(localStorage.getItem('webrtc_logs') || '[]');\n    logs.push({\n      timestamp: new Date().toISOString(),\n      message,\n      data: data ? JSON.stringify(data) : null\n    });\n    \n    // Keep only the last 100 logs\n    if (logs.length > 100) {\n      logs.shift();\n    }\n    \n    localStorage.setItem('webrtc_logs', JSON.stringify(logs));\n  }\n  \n  /**\n   * ENHANCED: Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.log(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n    \n    // Emit error event for UI components to handle\n    this.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n    \n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * ENHANCED: Event emission system\n   */\n  emit(event, data) {\n    if (this.eventListeners[event]) {\n      this.eventListeners[event].forEach(callback => callback(data));\n    }\n  }\n  \n  /**\n   * ENHANCED: Event subscription system\n   * Returns a function to unsubscribe the listener\n   */\n  on(event, callback) {\n    if (!this.eventListeners[event]) {\n      this.eventListeners[event] = [];\n    }\n    this.eventListeners[event].push(callback);\n    \n    // Return a function to remove the listener\n    return () => {\n      this.eventListeners[event] = this.eventListeners[event].filter(cb => cb !== callback);\n    };\n  }\n  \n  /**\n   * ENHANCED: Centralized call state management\n   */\n  updateCallState(newState) {\n    if (this.callState !== newState) {\n      this.log(`Call state changing from ${this.callState} to ${newState}`);\n      this.callState = newState;\n      \n      // Emit event for UI components\n      this.emit('callStateChanged', newState);\n      \n      // Trigger appropriate callbacks\n      if (newState === 'active' && this.onCallStarted) this.onCallStarted();\n      if (newState === 'ended' && this.onCallEnded) this.onCallEnded();\n      if (newState === 'connecting' && this.onCallConnecting) this.onCallConnecting();\n    }\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n    \n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    \n    this.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Set up callbacks\n    this.updateCallbacks(callbacks);\n    \n    // Connect to the signaling server if not already connected\n    if (!this.socket || !this.socket.connected) {\n      // Use provided URL, fallback to production URL, then localhost as last resort\n      const signalingServer = serverUrl || \n                              (process.env.REACT_APP_SIGNALING_SERVER || \n                              'http://localhost:3001');\n      \n      this.log('Connecting to signaling server:', signalingServer);\n      this.socket = io(signalingServer);\n      \n      // Set up event listeners for signaling messages\n      this.setupSocketListeners();\n    }\n    \n    // Register user ID with the signaling server\n    if (this.socket) {\n      this.socket.emit('register', userId);\n    }\n    \n    this.isInitialized = true;\n  }\n  \n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    // Only update provided callbacks, keep existing ones otherwise\n    if (callbacks.onLocalStream !== undefined) \n      this.onLocalStream = callbacks.onLocalStream;\n    if (callbacks.onRemoteStream !== undefined) \n      this.onRemoteStream = callbacks.onRemoteStream;\n    if (callbacks.onCallStarted !== undefined) \n      this.onCallStarted = callbacks.onCallStarted;\n    if (callbacks.onCallEnded !== undefined) \n      this.onCallEnded = callbacks.onCallEnded;\n    if (callbacks.onCallConnecting !== undefined) \n      this.onCallConnecting = callbacks.onCallConnecting;\n    if (callbacks.onIncomingCall !== undefined) \n      this.onIncomingCall = callbacks.onIncomingCall;\n    if (callbacks.onICEConnectionStateChange !== undefined) \n      this.onICEConnectionStateChange = callbacks.onICEConnectionStateChange;\n    if (callbacks.onUserNotOnline !== undefined)\n      this.onUserNotOnline = callbacks.onUserNotOnline;\n    if (callbacks.onCallDeclined !== undefined)\n      this.onCallDeclined = callbacks.onCallDeclined;\n    if (callbacks.onCallInProgress !== undefined)\n      this.onCallInProgress = callbacks.onCallInProgress;\n    \n    // Initialize default callback functions if not already set\n    this.onLocalStream = this.onLocalStream || (() => {});\n    this.onRemoteStream = this.onRemoteStream || (() => {});\n    this.onCallStarted = this.onCallStarted || (() => {});\n    this.onCallEnded = this.onCallEnded || (() => {});\n    this.onCallConnecting = this.onCallConnecting || (() => {});\n    this.onIncomingCall = this.onIncomingCall || (() => {});\n    this.onICEConnectionStateChange = this.onICEConnectionStateChange || (() => {});\n    this.onUserNotOnline = this.onUserNotOnline || (() => {});\n    this.onCallDeclined = this.onCallDeclined || (() => {});\n    this.onCallInProgress = this.onCallInProgress || (() => {});\n  }\n  \n  /**\n   * Set up all socket event listeners for signaling\n   */\n  setupSocketListeners() {\n    // Handle incoming calls\n    this.socket.on('incoming-call', async ({ callerUserId, offerSDP }) => {\n      this.log('Incoming call from:', callerUserId);\n      \n      // If there's already an active call, ignore this one\n      if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n        this.log('Already in a call, ignoring incoming call');\n        // Explicitly decline the call so the caller knows\n        this.socket.emit('call-declined', { targetUserId: callerUserId });\n        return;\n      }\n      \n      this.targetUserId = callerUserId;\n      this.isCallInitiator = false;\n      \n      // Store the offer to use when call is accepted\n      this.pendingOffer = offerSDP;\n      \n      // Update call state\n      this.updateCallState('connecting');\n      \n      // Notify the application of the incoming call\n      this.onIncomingCall(callerUserId);\n    });\n    \n    // Handle when the other person answers our call\n    this.socket.on('call-answered', async ({ answerSDP }) => {\n      this.log('Call was answered, setting remote description');\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(\n            new RTCSessionDescription(answerSDP)\n          );\n        }\n      } catch (error) {\n        this.handleError('setting remote description', error);\n      }\n    });\n\n    this.socket.on('call-in-progress', ({ callerUserId }) => {\n      this.log('Call in progress on another device with:', callerUserId);\n      // You can notify the UI if desired\n      if (typeof this.onCallInProgress === 'function') {\n        this.onCallInProgress(callerUserId);\n      }\n    });\n    \n    // Add handler for declined calls\n    this.socket.on('call-declined', () => {\n      this.log('Call was declined by the recipient');\n      this.updateCallState('ended');\n      this.endCall(false); // Don't notify the other person since they declined it\n      \n      // Notify the application\n      if (typeof this.onCallDeclined === 'function') {\n        this.onCallDeclined();\n      }\n    });\n    \n    // Handle ICE candidates from the other peer\n    this.socket.on('ice-candidate', async ({ candidate }) => {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.addIceCandidate(\n            new RTCIceCandidate(candidate)\n          );\n          this.log('Added ICE candidate');\n        }\n      } catch (error) {\n        this.handleError('adding ICE candidate', error);\n      }\n    });\n    \n    // Handle the other person ending the call\n    this.socket.on('call-ended', () => {\n      this.log('Call ended remotely');\n      this.updateCallState('ended');\n      this.endCall(false); // Don't notify the other person since they ended it\n    });\n    \n    // Handle call failure\n    this.socket.on('call-failed', ({ message, targetUserId }) => {\n      this.log('Call failed:', message);\n      \n      // Handle user not online case\n      if (message === 'User is not online') {\n        if (this.onUserNotOnline) {\n          this.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n      } else {\n        this.updateCallState('ended');\n      }\n      \n      this.resetCallState();\n    });\n    \n    // Handle user online status\n    this.socket.on('user-online-status', ({ userId, isOnline, responseId }) => {\n      this.log('User online status received:', { userId, isOnline, responseId });\n      // The responseId is now used to match requests with responses\n      this.emit(`online-status-${responseId}`, { userId, isOnline });\n    });\n  }\n\n  declineCall() {\n    if (this.targetUserId) {\n      this.log('Declining call from:', this.targetUserId);\n      this.socket.emit('call-declined', { targetUserId: this.targetUserId });\n      this.resetCallState();\n    }\n  }\n  \n  /**\n   * ENHANCED: Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  checkUserOnline(userId) {\n    return new Promise((resolve) => {\n      if (!this.socket || !this.socket.connected) {\n        this.log('Socket not connected, user is offline');\n        resolve(false);\n        return;\n      }\n      \n      // Create a unique request ID to match the response\n      const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      this.log('Checking if user is online:', userId, 'with requestId:', requestId);\n      this.socket.emit('check-user-online', { userId, requestId });\n      \n      // Set up a one-time event listener specific to this request\n      const cleanupListener = this.on(`online-status-${requestId}`, ({ userId: responseUserId, isOnline }) => {\n        if (responseUserId === userId) {\n          clearTimeout(timeout);\n          this.log('User online status for', userId, ':', isOnline);\n          resolve(isOnline);\n        }\n      });\n      \n      // Set a timeout in case we never get a response\n      const timeout = setTimeout(() => {\n        cleanupListener(); // Remove the listener\n        this.log('User online check timed out for:', userId);\n        resolve(false);\n      }, 5000);\n    });\n  }\n  \n  /**\n   * ENHANCED: Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    this.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n    \n    try {\n      if (!this.peerConnection) {\n        this.log('No peer connection to reconnect');\n        return;\n      }\n      \n      // First try to restart ICE\n      this.peerConnection.restartIce();\n      \n      // For more aggressive reconnection, try recreating the offer\n      if (aggressive || this.isCallInitiator) {\n        this.log('Creating new offer with ICE restart');\n        const offer = await this.peerConnection.createOffer({ \n          iceRestart: true,\n          offerToReceiveAudio: true,\n          offerToReceiveVideo: true\n        });\n        \n        await this.peerConnection.setLocalDescription(offer);\n        \n        // Store the new offer\n        this.lastOffer = offer;\n        \n        // Send the new offer to the other user\n        this.socket.emit('call-user', {\n          targetUserId: this.targetUserId,\n          offerSDP: offer,\n          callerUserId: this.userId\n        });\n        \n        this.log('Sent new offer for reconnection');\n      }\n    } catch (error) {\n      this.handleError('reconnection attempt', error);\n    }\n  }\n  \n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      \n      if (!isOnline) {\n        this.log('Cannot make call - user is not online:', targetUserId);\n        \n        if (this.onUserNotOnline) {\n          this.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        \n        return;\n      }\n      \n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      \n      this.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.isCallInitiator = true;\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      // Create an offer (SDP)\n      this.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      \n      // Store offer for potential reconnection\n      this.lastOffer = offer;\n      \n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // Send the offer to the other user via signaling server\n      this.socket.emit('call-user', {\n        targetUserId: this.targetUserId,\n        offerSDP: offer,\n        callerUserId: this.userId\n      });\n      \n      this.log('Call offer sent');\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    try {\n      this.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create peer connection\n      this.initializePeerConnection();\n      \n      // Set the remote description from the stored offer\n      this.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(\n        new RTCSessionDescription(this.pendingOffer)\n      );\n      \n      // Create an answer\n      this.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n      \n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n      \n      // Send the answer to the caller\n      this.socket.emit('call-accepted', {\n        targetUserId: this.targetUserId,\n        answerSDP: answer\n      });\n      \n      this.log('Call accepted, answer sent');\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n  \n  /**\n   * End an ongoing call\n   * @param {boolean} notifyPeer - Whether to send end-call signal to the other user\n   */\n  endCall(notifyPeer = true) {\n    this.log('Ending call, notify peer:', notifyPeer);\n    \n    // Clear all timers first\n    [this.disconnectionTimer, this.disconnectionFailureTimer, this.failureTimeout].forEach(timer => {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    });\n    \n    // Notify the other peer if needed\n    if (notifyPeer && this.socket && this.targetUserId) {\n      // If the call is in connecting state, decline it instead of ending\n      if (!this.isCallConnected() && this.callState === 'connecting') {\n        this.socket.emit('call-declined', { targetUserId: this.targetUserId });\n      } else {\n        this.socket.emit('end-call', { targetUserId: this.targetUserId });\n      }\n    }\n    \n    // Close peer connection with careful cleanup\n    if (this.peerConnection) {\n      // Remove all event listeners first\n      this.peerConnection.onicecandidate = null;\n      this.peerConnection.ontrack = null;\n      this.peerConnection.oniceconnectionstatechange = null;\n      this.peerConnection.onicegatheringstatechange = null;\n      this.peerConnection.onsignalingstatechange = null;\n      this.peerConnection.onconnectionstatechange = null;\n      \n      // Close the connection\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    \n    // Stop all media tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n    \n    // Update call state\n    this.updateCallState('ended');\n    \n    // Reset state\n    this.resetCallState();\n  }\n  \n  /**\n   * Reset call state variables\n   */\n  resetCallState() {\n    this.log('Resetting call state');\n    this.remoteStream = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n    this.pendingOffer = null;\n    this.reconnectionAttempts = 0;\n    this.iceConnectionState = null;\n    \n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n      this.disconnectionTimer = null;\n    }\n    \n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n      this.disconnectionFailureTimer = null;\n    }\n    \n    if (this.failureTimeout) {\n      clearTimeout(this.failureTimeout);\n      this.failureTimeout = null;\n    }\n    \n    this.lastOffer = null;\n  }\n  \n  /**\n   * Initialize the WebRTC peer connection\n   */\n  initializePeerConnection() {\n    // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n    const configuration = {\n      iceServers: [\n        // Multiple STUN servers for better connectivity\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' },\n        { urls: 'stun:stun3.l.google.com:19302' },\n        { urls: 'stun:stun4.l.google.com:19302' },\n        // Free TURN server (replace with your own in production)\n        {\n          urls: 'turn:openrelay.metered.ca:80',\n          username: 'openrelayproject',\n          credential: 'openrelayproject'\n        },\n        {\n          urls: 'turn:openrelay.metered.ca:443',\n          username: 'openrelayproject',\n          credential: 'openrelayproject'\n        },\n        // If environment variables exist, add them too\n        ...(process.env.REACT_APP_TURN_SERVER ? [{\n          urls: process.env.REACT_APP_TURN_SERVER,\n          username: process.env.REACT_APP_TURN_USERNAME || '',\n          credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n        }] : [])\n      ],\n      iceCandidatePoolSize: 10,\n      // The following helps with connection stability\n      sdpSemantics: 'unified-plan'\n    };\n    \n    this.log('Initializing peer connection with configuration:', configuration);\n    \n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n    \n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n    \n    // Set up event handler for receiving remote media\n    this.peerConnection.ontrack = (event) => {\n      this.log('Received remote track:', event.track.kind);\n      \n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        this.onRemoteStream(this.remoteStream);\n      }\n      \n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        this.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n    };\n    \n    // Handle ICE candidates generated by our side\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        const candidateStr = event.candidate.candidate || '';\n        const candidateType = candidateStr.split(' ')[7] || 'unknown'; // Extract type (host, srflx, relay)\n        this.log('Generated ICE candidate of type:', candidateType);\n        \n        // Send our ICE candidate to the other peer\n        this.socket.emit('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      }\n    };\n    \n    // Additional monitoring for ICE gathering state\n    this.peerConnection.onicegatheringstatechange = () => {\n      this.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n    };\n    \n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      this.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n    \n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.log('Connection state changed:', this.peerConnection.connectionState);\n    };\n    \n    // ENHANCED: Improved ICE connection state handling with better state tracking\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const state = this.peerConnection.iceConnectionState;\n      const previousState = this.iceConnectionState;\n      this.iceConnectionState = state;\n      \n      this.log('ICE connection state changed to:', state, 'from:', previousState);\n      \n      this.onICEConnectionStateChange(state);\n      \n      // Handle connection establishment\n      if (state === 'connected' || state === 'completed') {\n        this.log('Call connected successfully!');\n        if (!this.isCallConnected()) {\n          this.updateCallState('active');\n          \n          // Reset reconnection attempts\n          this.reconnectionAttempts = 0;\n          \n          // Clear any pending timers\n          if (this.disconnectionTimer) {\n            clearTimeout(this.disconnectionTimer);\n            this.disconnectionTimer = null;\n          }\n          \n          if (this.disconnectionFailureTimer) {\n            clearTimeout(this.disconnectionFailureTimer);\n            this.disconnectionFailureTimer = null;\n          }\n          \n          if (this.failureTimeout) {\n            clearTimeout(this.failureTimeout);\n            this.failureTimeout = null;\n          }\n        }\n      } \n      // Add timeout check to avoid premature failure\n      else if (state === 'failed') {\n        this.log('Connection failed');\n        \n        if (!this.failureTimeout) {\n          this.failureTimeout = setTimeout(() => {\n            if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n              // Attempt to restart ICE if possible before ending the call\n              if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n                this.reconnectionAttempts++;\n                this.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n                \n                // Try to reconnect using our enhanced method\n                this.attemptReconnection(true);\n              } else {\n                this.log('Max reconnection attempts reached, ending call');\n                this.updateCallState('ended');\n                this.endCall(true);\n              }\n            }\n            this.failureTimeout = null;\n          }, 1000);\n        }\n      }\n      // For disconnected state, implement improved timer-based approach\n      else if (state === 'disconnected') {\n        this.log('Connection temporarily disconnected');\n        \n        // Clear any existing timers first\n        if (this.disconnectionTimer) {\n          clearTimeout(this.disconnectionTimer);\n        }\n        \n        if (this.disconnectionFailureTimer) {\n          clearTimeout(this.disconnectionFailureTimer);\n        }\n        \n        // Start with a short timer for normal recovery\n        this.disconnectionTimer = setTimeout(() => {\n          // If still disconnected after short period, try recovery\n          if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n            this.log('Connection still disconnected, attempting recovery...');\n            this.attemptReconnection(false);\n          }\n          this.disconnectionTimer = null;\n        }, 2000); // Try recovery after 2 seconds\n        \n        // Also set a longer timeout for full failure\n        this.disconnectionFailureTimer = setTimeout(() => {\n          if (this.peerConnection && \n              (this.peerConnection.iceConnectionState === 'disconnected' || \n               this.peerConnection.iceConnectionState === 'failed')) {\n            this.log('Connection remained disconnected for too long');\n            this.updateCallState('ended');\n            this.endCall(true);\n          }\n          this.disconnectionFailureTimer = null;\n        }, 15000); // End call after 15 seconds of disconnection\n      }\n      // Clear any timeout if state improves\n      else if ((state === 'checking' || state === 'connected') && \n              (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n        // Clear timers if we've recovered\n        if (this.failureTimeout) {\n          clearTimeout(this.failureTimeout);\n          this.failureTimeout = null;\n        }\n        \n        if (this.disconnectionTimer) {\n          clearTimeout(this.disconnectionTimer);\n          this.disconnectionTimer = null;\n        }\n        \n        if (this.disconnectionFailureTimer) {\n          clearTimeout(this.disconnectionFailureTimer);\n          this.disconnectionFailureTimer = null;\n        }\n      }\n    };\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      this.log('Requesting access to local media with constraints:', {\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      \n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      \n      this.log('Access to local media granted');\n      \n      this.localStream = stream;\n      this.onLocalStream(stream);\n      return stream;\n    } catch (error) {\n      // Classify and handle errors more specifically\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.handleError('media permissions', new Error('Camera or microphone access was denied'), true);\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.handleError('media devices', new Error('No camera or microphone found'), true);\n      } else {\n        this.handleError('accessing media devices', error, true);\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n  \n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Disconnect from signaling server\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    \n    // Reset initialization status\n    this.isInitialized = false;\n    \n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}