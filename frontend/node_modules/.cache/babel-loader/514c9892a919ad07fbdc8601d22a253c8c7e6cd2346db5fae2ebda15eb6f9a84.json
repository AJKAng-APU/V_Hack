{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectScreen = ({\n  colors,\n  setActiveScreen\n}) => {\n  _s();\n  const {\n    isDarkMode\n  } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n\n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(localStorage.getItem('is_doctor') === 'true');\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n\n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  const [pendingIncomingCall, setPendingIncomingCall] = useState(null);\n  const [doctorAnswerTimer, setDoctorAnswerTimer] = useState(null);\n\n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n\n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Sample doctors data\n  const doctors = [{\n    id: 1,\n    name: \"Dr. Johnson\",\n    specialty: \"Cardiologist\",\n    image: \"/User_1.png\",\n    availability: \"Available now\",\n    rating: 5\n  }, {\n    id: 2,\n    name: \"Dr. Smith\",\n    specialty: \"Primary Care\",\n    image: \"/User_2.jpg\",\n    availability: \"Available in 15m\",\n    rating: 4\n  }, {\n    id: 3,\n    name: \"Dr. Garcia\",\n    specialty: \"Endocrinologist\",\n    image: \"/User_3.png\",\n    availability: \"Available tomorrow\",\n    rating: 5\n  }, {\n    id: 4,\n    name: \"Dr. Chen\",\n    specialty: \"Neurologist\",\n    image: \"/User_4.png\",\n    availability: \"Available in 2h\",\n    rating: 4\n  }];\n  const generateDoctorId = () => {\n    return localStorage.getItem('doctor_id') || `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n  };\n\n  // FIXED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n            const doctorId = generateDoctorId();\n            localStorage.setItem('doctor_id', doctorId);\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n\n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n\n  // Track when call status changes to active\n  useEffect(() => {\n    const handleCallActive = () => {\n      console.log('Call is now active, clearing pending incoming call if any');\n\n      // If there's a pending incoming call waiting for doctor to answer, clear it\n      if (pendingIncomingCall) {\n        console.log('Clearing pending incoming call, doctor answered');\n        setPendingIncomingCall(null);\n\n        // Clear doctor answer timer if it exists\n        if (doctorAnswerTimer) {\n          clearTimeout(doctorAnswerTimer);\n          setDoctorAnswerTimer(null);\n        }\n      }\n    };\n\n    // Subscribe to call state changes\n    const unsubscribeCallState = webRTCService.on('callStateChanged', state => {\n      if (state === 'active') {\n        handleCallActive();\n      }\n    });\n    return () => {\n      if (typeof unsubscribeCallState === 'function') {\n        unsubscribeCallState();\n      }\n    };\n  }, [pendingIncomingCall, doctorAnswerTimer]);\n\n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    const callbacks = {\n      onIncomingCall: callerId => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n\n        // Store the incoming call information but don't display it immediately\n        // We'll wait to see if the doctor takes the call first\n        const callInfo = {\n          doctor: callingDoctor,\n          timestamp: Date.now(),\n          id: `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n        };\n\n        // Store the call info in pending state\n        setPendingIncomingCall(callInfo);\n\n        // Set a timer to wait for the doctor to answer the call (5 seconds)\n        // Only show notification to patient if doctor doesn't answer within this time\n        const timer = setTimeout(() => {\n          // Check if we still have a pending call (wasn't cleared by call becoming active)\n          if (pendingIncomingCall && pendingIncomingCall.id === callInfo.id) {\n            console.log('Doctor did not answer call within timeout, showing notification to patient');\n            displayIncomingCallAlert(callingDoctor, callInfo.id);\n          }\n        }, 5000); // 5 second delay to allow doctor to answer\n\n        setDoctorAnswerTimer(timer);\n      },\n      onUserNotOnline: userId => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        setConnectingDoctor(null);\n      },\n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n        setPendingIncomingCall(null);\n\n        // Clear doctor answer timer if it exists\n        if (doctorAnswerTimer) {\n          clearTimeout(doctorAnswerTimer);\n          setDoctorAnswerTimer(null);\n        }\n\n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {/* handle error */}\n          setRingtoneAudio(null);\n        }\n      },\n      onCallStarted: () => {\n        console.log('Call started callback');\n\n        // Clear pending incoming call if it exists\n        if (pendingIncomingCall) {\n          console.log('Clearing pending incoming call, call has started');\n          setPendingIncomingCall(null);\n\n          // Clear doctor answer timer if it exists\n          if (doctorAnswerTimer) {\n            clearTimeout(doctorAnswerTimer);\n            setDoctorAnswerTimer(null);\n          }\n        }\n      }\n    };\n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = generateDoctorId();\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Registered as ${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && webRTCService.signalingService.isConnected() && !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.signalingService.send('register', currentUserId);\n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = generateDoctorId();\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Re-registering as ${doctorId}`);\n        }\n      }\n    }, 5000);\n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', error => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      clearInterval(registerInterval);\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n      }\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {/* handle error */}\n      }\n      setIncomingCallInfo(null);\n      setPendingIncomingCall(null);\n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      webRTCService.disconnect();\n    };\n  }, []);\n\n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor, callId) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n\n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      cleanupPreviousCall();\n\n      // Use the provided callId or generate a new one\n      const callNotificationId = callId || `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          audio.addEventListener('error', e => {\n            console.error('Ringtone error:', e);\n          });\n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      playRingtone();\n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      setAutoAcceptTimer(timer);\n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    acceptIncomingCall: doctor => {\n      console.log('Accepting incoming call from:', doctor === null || doctor === void 0 ? void 0 : doctor.name);\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n\n      // Clear pending incoming call state\n      setPendingIncomingCall(null);\n\n      // Clear doctor answer timer if it exists\n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n        setDoctorAnswerTimer(null);\n      }\n      setIncomingCallInfo(null);\n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n\n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n\n      // Clear pending incoming call state\n      setPendingIncomingCall(null);\n\n      // Clear doctor answer timer if it exists\n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n        setDoctorAnswerTimer(null);\n      }\n      webRTCService.declineCall();\n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n\n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    checkDoctorOnline: async doctorId => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    initiateCall: async doctor => {\n      if (!webRTCService || !doctor) return;\n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n\n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n    handleConnectDoctor: async doctor => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  const {\n    displayIncomingCallAlert,\n    acceptIncomingCall,\n    rejectIncomingCall,\n    initiateCall,\n    handleConnectDoctor\n  } = callHandlers;\n\n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n\n  // Handle search filtering\n  const handleSearch = query => {\n    setSearchQuery(query);\n  };\n\n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery ? doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()) : true;\n    const matchesAvailability = filterActive ? doctor.availability.includes('Available') && !doctor.availability.includes('in') : true;\n    return matchesSearch && matchesAvailability;\n  });\n\n  // Improved toast display function\n  const displayToast = message => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n\n  // Process toast queue with improved timing\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      // Show the next toast in queue\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n\n      // Set a timer to clear the active toast after display time\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n\n        // Add a small delay before processing next toast\n        setTimeout(() => {\n          // Check if there are more toasts in queue and trigger reprocessing\n          if (toastQueue.length > 0) {\n            // Create a temporary state update to trigger the useEffect again\n            setToastQueue(prev => [...prev]);\n          }\n        }, 300); // Small delay between toasts\n      }, 3500); // Display duration reduced to 3.5 seconds\n\n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n\n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-6 pb-24 dark-mode-transition\",\n    style: {\n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)` : 'none'\n    },\n    children: [/*#__PURE__*/_jsxDEV(ConnectHeader, {\n      headerVisible: headerVisible,\n      notifications: notifications,\n      setNotifications: setNotifications,\n      colors: colors,\n      isDoctorMode: isDoctorMode,\n      setIsDoctorMode: setIsDoctorMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 657,\n      columnNumber: 7\n    }, this), incomingCallCounter > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 p-2 bg-red-100 rounded-md text-xs\",\n      children: [\"Incoming call events received: \", incomingCallCounter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 667,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(SearchBar, {\n      headerVisible: headerVisible,\n      searchFocused: searchFocused,\n      setSearchFocused: setSearchFocused,\n      searchQuery: searchQuery,\n      setSearchQuery: setSearchQuery,\n      handleSearch: handleSearch,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 672,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FilterChips, {\n      headerVisible: headerVisible,\n      filterActive: filterActive,\n      setFilterActive: setFilterActive,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 683,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DoctorsTeam, {\n      headerVisible: headerVisible,\n      doctors: filteredDoctors,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      handleConnectDoctor: handleConnectDoctor,\n      setSelectedDoctor: setSelectedDoctor,\n      setSchedulingDoctor: setSchedulingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 691,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(QuickConnectActions, {\n      headerVisible: headerVisible,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      initiateCall: initiateCall,\n      displayToast: displayToast,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 703,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RecentMessages, {\n      headerVisible: headerVisible,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 713,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MessageDialog, {\n      isOpen: showMessageDialog,\n      onClose: () => {\n        setShowMessageDialog(false);\n        setSchedulingDoctor(null);\n      },\n      colors: colors,\n      recipient: schedulingDoctor || connectingDoctor,\n      doctors: doctors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 719,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoCallScreen, {\n      isOpen: showVideoCall,\n      onClose: () => setShowVideoCall(false),\n      colors: colors,\n      doctor: connectingDoctor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 731,\n      columnNumber: 7\n    }, this), incomingCallInfo && /*#__PURE__*/_jsxDEV(IncomingCallUI, {\n      incomingCallInfo: incomingCallInfo,\n      colors: colors,\n      acceptIncomingCall: acceptIncomingCall,\n      rejectIncomingCall: rejectIncomingCall\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 740,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ToastNotification, {\n      activeToast: activeToast,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 749,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 755,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 650,\n    columnNumber: 5\n  }, this);\n};\n_s(ConnectScreen, \"9KopIYXqWfUa7TjrXa9jLKd60yg=\", false, function () {\n  return [useTheme];\n});\n_c = ConnectScreen;\nexport default ConnectScreen;\nvar _c;\n$RefreshReg$(_c, \"ConnectScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","MessageDialog","VideoCallScreen","ConnectHeader","SearchBar","FilterChips","DoctorsTeam","QuickConnectActions","RecentMessages","IncomingCallUI","ToastNotification","jsxDEV","_jsxDEV","ConnectScreen","colors","setActiveScreen","_s","isDarkMode","searchFocused","setSearchFocused","searchQuery","setSearchQuery","notifications","setNotifications","filterActive","setFilterActive","showMessageDialog","setShowMessageDialog","showVideoCall","setShowVideoCall","selectedDoctor","setSelectedDoctor","connectingDoctor","setConnectingDoctor","schedulingDoctor","setSchedulingDoctor","readyToConnect","setReadyToConnect","isDoctorMode","setIsDoctorMode","localStorage","getItem","toastQueue","setToastQueue","activeToast","setActiveToast","incomingCallInfo","setIncomingCallInfo","ringtoneAudio","setRingtoneAudio","autoAcceptTimer","setAutoAcceptTimer","pendingIncomingCall","setPendingIncomingCall","doctorAnswerTimer","setDoctorAnswerTimer","incomingCallCounter","setIncomingCallCounter","prevShowVideoCall","doctors","id","name","specialty","image","availability","rating","generateDoctorId","Math","floor","random","setItem","registerAsDoctor","signalingService","isConnected","doctorId","send","console","log","displayToast","replace","setTimeout","error","userId","handleCallActive","clearTimeout","unsubscribeCallState","on","state","generateUniqueId","storedId","newId","toString","substring","currentUserId","callbacks","onIncomingCall","callerId","prev","callingDoctor","find","doc","parseInt","callInfo","doctor","timestamp","Date","now","timer","displayIncomingCallAlert","onUserNotOnline","onCallInProgress","callerUserId","message","pause","currentTime","e","onCallStarted","serverUrl","process","env","REACT_APP_SIGNALING_SERVER","initialize","registerInterval","setInterval","isCallActive","unsubscribeError","fatal","clearInterval","disconnect","callHandlers","callId","cleanupPreviousCall","callNotificationId","playRingtone","audio","Audio","loop","volume","addEventListener","playPromise","play","undefined","then","catch","acceptIncomingCall","acceptCall","rejectIncomingCall","declineCall","checkDoctorOnline","attempt","isOnline","checkUserOnline","Promise","resolve","initiateCall","getLocalMedia","makeCall","handleConnectDoctor","current","handleSearch","query","filteredDoctors","filter","matchesSearch","toLowerCase","includes","matchesAvailability","length","slice","headerVisible","setHeaderVisible","className","style","backgroundColor","background","backgroundImage","primary","accent","children","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","onClose","recipient","jsx","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext'; \nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\n\nconst ConnectScreen = ({ colors, setActiveScreen }) => {\n  const { isDarkMode } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n  \n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n  \n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(\n    localStorage.getItem('is_doctor') === 'true'\n  );\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n  \n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  const [pendingIncomingCall, setPendingIncomingCall] = useState(null);\n  const [doctorAnswerTimer, setDoctorAnswerTimer] = useState(null);\n  \n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n  \n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n  \n  // Sample doctors data\n  const doctors = [\n    {\n      id: 1,\n      name: \"Dr. Johnson\",\n      specialty: \"Cardiologist\",\n      image: \"/User_1.png\",\n      availability: \"Available now\",\n      rating: 5\n    },\n    {\n      id: 2,\n      name: \"Dr. Smith\",\n      specialty: \"Primary Care\",\n      image: \"/User_2.jpg\",\n      availability: \"Available in 15m\",\n      rating: 4\n    },\n    {\n      id: 3,\n      name: \"Dr. Garcia\",\n      specialty: \"Endocrinologist\",\n      image: \"/User_3.png\",\n      availability: \"Available tomorrow\",\n      rating: 5\n    },\n    {\n      id: 4,\n      name: \"Dr. Chen\",\n      specialty: \"Neurologist\",\n      image: \"/User_4.png\",\n      availability: \"Available in 2h\",\n      rating: 4\n    },\n  ];\n\n  const generateDoctorId = () => {\n    return localStorage.getItem('doctor_id') || \n           `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n  };\n\n  // FIXED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    \n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && \n              webRTCService.signalingService.isConnected()) {\n            const doctorId = generateDoctorId();\n            localStorage.setItem('doctor_id', doctorId);\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      \n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && \n            webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n  \n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n  \n  // Track when call status changes to active\n  useEffect(() => {\n    const handleCallActive = () => {\n      console.log('Call is now active, clearing pending incoming call if any');\n      \n      // If there's a pending incoming call waiting for doctor to answer, clear it\n      if (pendingIncomingCall) {\n        console.log('Clearing pending incoming call, doctor answered');\n        setPendingIncomingCall(null);\n        \n        // Clear doctor answer timer if it exists\n        if (doctorAnswerTimer) {\n          clearTimeout(doctorAnswerTimer);\n          setDoctorAnswerTimer(null);\n        }\n      }\n    };\n    \n    // Subscribe to call state changes\n    const unsubscribeCallState = webRTCService.on('callStateChanged', (state) => {\n      if (state === 'active') {\n        handleCallActive();\n      }\n    });\n    \n    return () => {\n      if (typeof unsubscribeCallState === 'function') {\n        unsubscribeCallState();\n      }\n    };\n  }, [pendingIncomingCall, doctorAnswerTimer]);\n  \n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      \n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    \n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    \n    const callbacks = {\n      onIncomingCall: (callerId) => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n        \n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        \n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        \n        // Store the incoming call information but don't display it immediately\n        // We'll wait to see if the doctor takes the call first\n        const callInfo = {\n          doctor: callingDoctor,\n          timestamp: Date.now(),\n          id: `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n        };\n        \n        // Store the call info in pending state\n        setPendingIncomingCall(callInfo);\n        \n        // Set a timer to wait for the doctor to answer the call (5 seconds)\n        // Only show notification to patient if doctor doesn't answer within this time\n        const timer = setTimeout(() => {\n          // Check if we still have a pending call (wasn't cleared by call becoming active)\n          if (pendingIncomingCall && pendingIncomingCall.id === callInfo.id) {\n            console.log('Doctor did not answer call within timeout, showing notification to patient');\n            displayIncomingCallAlert(callingDoctor, callInfo.id);\n          }\n        }, 5000); // 5 second delay to allow doctor to answer\n        \n        setDoctorAnswerTimer(timer);\n      },\n      \n      onUserNotOnline: (userId) => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        \n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        \n        setConnectingDoctor(null);\n      },\n\n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n        setPendingIncomingCall(null);\n        \n        // Clear doctor answer timer if it exists\n        if (doctorAnswerTimer) {\n          clearTimeout(doctorAnswerTimer);\n          setDoctorAnswerTimer(null);\n        }\n        \n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) { /* handle error */ }\n          setRingtoneAudio(null);\n        }\n      },\n      \n      onCallStarted: () => {\n        console.log('Call started callback');\n        \n        // Clear pending incoming call if it exists\n        if (pendingIncomingCall) {\n          console.log('Clearing pending incoming call, call has started');\n          setPendingIncomingCall(null);\n          \n          // Clear doctor answer timer if it exists\n          if (doctorAnswerTimer) {\n            clearTimeout(doctorAnswerTimer);\n            setDoctorAnswerTimer(null);\n          }\n        }\n      }\n    };\n    \n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    \n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = generateDoctorId();\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Registered as ${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    \n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && \n          webRTCService.signalingService.isConnected() && \n          !webRTCService.isCallActive() && \n          !showVideoCall) {\n        \n        webRTCService.signalingService.send('register', currentUserId);\n        \n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = generateDoctorId();\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Re-registering as ${doctorId}`);\n        }\n      }\n    }, 5000);\n    \n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', (error) => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        \n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    \n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      \n      clearInterval(registerInterval);\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      \n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n      }\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) { /* handle error */ }\n      }\n      \n      setIncomingCallInfo(null);\n      setPendingIncomingCall(null);\n      \n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      \n      webRTCService.disconnect();\n    };\n  }, []);\n  \n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor, callId) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n      \n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        \n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        \n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      \n      cleanupPreviousCall();\n      \n      // Use the provided callId or generate a new one\n      const callNotificationId = callId || `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      \n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          \n          audio.addEventListener('error', (e) => {\n            console.error('Ringtone error:', e);\n          });\n          \n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      \n      playRingtone();\n      \n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      \n      setAutoAcceptTimer(timer);\n      \n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    \n    acceptIncomingCall: (doctor) => {\n      console.log('Accepting incoming call from:', doctor?.name);\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      // Clear pending incoming call state\n      setPendingIncomingCall(null);\n      \n      // Clear doctor answer timer if it exists\n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n        setDoctorAnswerTimer(null);\n      }\n      \n      setIncomingCallInfo(null);\n      \n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n      \n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    \n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      // Clear pending incoming call state\n      setPendingIncomingCall(null);\n      \n      // Clear doctor answer timer if it exists\n      if (doctorAnswerTimer) {\n        clearTimeout(doctorAnswerTimer);\n        setDoctorAnswerTimer(null);\n      }\n      \n      webRTCService.declineCall();\n      \n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      \n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    \n    checkDoctorOnline: async (doctorId) => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    \n    initiateCall: async (doctor) => {\n      if (!webRTCService || !doctor) return;\n    \n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n        \n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        \n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n      \n    handleConnectDoctor: async (doctor) => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      \n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        \n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        \n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        \n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  \n  const { displayIncomingCallAlert, acceptIncomingCall, rejectIncomingCall, initiateCall, handleConnectDoctor } = callHandlers;\n  \n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    \n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n  \n  // Handle search filtering\n  const handleSearch = (query) => {\n    setSearchQuery(query);\n  };\n  \n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery \n      ? (doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || \n         doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()))\n      : true;\n      \n    const matchesAvailability = filterActive \n      ? doctor.availability.includes('Available') && !doctor.availability.includes('in')\n      : true;\n      \n    return matchesSearch && matchesAvailability;\n  });\n  \n  // Improved toast display function\n  const displayToast = (message) => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n  \n  // Process toast queue with improved timing\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      // Show the next toast in queue\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      \n      // Set a timer to clear the active toast after display time\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n        \n        // Add a small delay before processing next toast\n        setTimeout(() => {\n          // Check if there are more toasts in queue and trigger reprocessing\n          if (toastQueue.length > 0) {\n            // Create a temporary state update to trigger the useEffect again\n            setToastQueue(prev => [...prev]);\n          }\n        }, 300); // Small delay between toasts\n      }, 3500); // Display duration reduced to 3.5 seconds\n      \n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n  \n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div className=\"p-6 pb-24 dark-mode-transition\" style={{ \n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode \n        ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)`\n        : 'none'\n    }}>\n      <ConnectHeader \n        headerVisible={headerVisible}\n        notifications={notifications}\n        setNotifications={setNotifications}\n        colors={colors}\n        isDoctorMode={isDoctorMode}\n        setIsDoctorMode={setIsDoctorMode}\n      />\n      \n      {incomingCallCounter > 0 && (\n      <div className=\"mb-2 p-2 bg-red-100 rounded-md text-xs\">\n        Incoming call events received: {incomingCallCounter}\n      </div>\n    )}\n      \n      <SearchBar \n        headerVisible={headerVisible}\n        searchFocused={searchFocused}\n        setSearchFocused={setSearchFocused}\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n        handleSearch={handleSearch}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <FilterChips \n        headerVisible={headerVisible}\n        filterActive={filterActive}\n        setFilterActive={setFilterActive}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <DoctorsTeam \n        headerVisible={headerVisible}\n        doctors={filteredDoctors}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        handleConnectDoctor={handleConnectDoctor}\n        setSelectedDoctor={setSelectedDoctor}\n        setSchedulingDoctor={setSchedulingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        isDarkMode={isDarkMode}\n      />\n      \n      <QuickConnectActions \n        headerVisible={headerVisible}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        initiateCall={initiateCall}\n        displayToast={displayToast}\n        isDarkMode={isDarkMode}\n      />\n      \n      <RecentMessages \n        headerVisible={headerVisible}\n        colors={colors}\n      />\n      \n      {/* Message Dialog */}\n      <MessageDialog \n        isOpen={showMessageDialog}\n        onClose={() => {\n          setShowMessageDialog(false);\n          setSchedulingDoctor(null);\n        }}\n        colors={colors}\n        recipient={schedulingDoctor || connectingDoctor}\n        doctors={doctors}\n      />\n      \n      {/* Video Call Screen */}\n      <VideoCallScreen \n        isOpen={showVideoCall}\n        onClose={() => setShowVideoCall(false)}\n        colors={colors}\n        doctor={connectingDoctor}\n      />\n      \n      {/* Incoming Call UI */}\n      {incomingCallInfo && (\n        <IncomingCallUI \n          incomingCallInfo={incomingCallInfo}\n          colors={colors}\n          acceptIncomingCall={acceptIncomingCall}\n          rejectIncomingCall={rejectIncomingCall}\n        />\n      )}\n      \n      {/* Toast Notification */}\n      <ToastNotification \n        activeToast={activeToast}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <style jsx>{`\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ConnectScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}