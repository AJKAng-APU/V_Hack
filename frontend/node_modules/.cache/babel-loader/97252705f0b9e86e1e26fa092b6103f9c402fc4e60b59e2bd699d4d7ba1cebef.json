{"ast":null,"code":"// File: services/WebRTC/WebRTCConnectionManager.js\n/**\n * Manages WebRTC peer connection\n */\nclass WebRTCConnectionManager {\n  constructor(signalingService, mediaManager, eventEmitter, logger, updateCallState) {\n    this.signalingService = signalingService;\n    this.mediaManager = mediaManager;\n    this.eventEmitter = eventEmitter;\n    this.logger = logger;\n    this.updateCallState = updateCallState;\n\n    // Connection\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.isCallInitiator = false;\n    this.targetUserId = null; // Add explicit tracking of target user\n\n    // Call reconnection state\n    this.pendingOffer = null;\n    this.pendingCandidates = []; // Add storage for pending candidates\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.iceConnectionState = null;\n\n    // Timers\n    this.disconnectionTimer = null;\n    this.disconnectionFailureTimer = null;\n    this.failureTimeout = null;\n\n    // Callbacks\n    this.callbacks = {\n      onRemoteStream: null,\n      onICEConnectionStateChange: null\n    };\n  }\n\n  /**\n   * Set callbacks for the connection manager\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Set pending offer for incoming call\n   * @param {RTCSessionDescriptionInit} offer - SDP offer\n   */\n  setPendingOffer(offer) {\n    this.pendingOffer = offer;\n  }\n\n  /**\n   * Set local stream to use for the call\n   * @param {MediaStream} stream - Local media stream\n   */\n  setLocalStream(stream) {\n    this.localStream = stream;\n\n    // Add tracks to peer connection if it exists\n    if (this.peerConnection && stream) {\n      stream.getTracks().forEach(track => {\n        this.logger.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, stream);\n      });\n    }\n  }\n\n  /**\n   * Initialize a call to another user\n   * @param {string} userId - Current user ID\n   * @param {string} targetUserId - Target user ID\n   */\n  async initiateCall(userId, targetUserId) {\n    this.isCallInitiator = true;\n    this.targetUserId = targetUserId;\n\n    // Create peer connection\n    this.createPeerConnection();\n\n    // Create an offer (SDP)\n    this.logger.log('Creating offer...');\n    const offer = await this.peerConnection.createOffer();\n\n    // Set the offer as our local description\n    await this.peerConnection.setLocalDescription(offer);\n\n    // Send the offer to the other user via signaling server\n    this.signalingService.send('call-user', {\n      targetUserId,\n      offerSDP: offer,\n      callerUserId: userId\n    });\n    this.logger.log('Call offer sent');\n  }\n\n  /**\n   * Accept an incoming call\n   * @param {string} targetUserId - ID of the caller\n   */\n  async acceptCall(targetUserId) {\n    this.targetUserId = targetUserId; // Set target ID here too\n    // Create peer connection\n    this.createPeerConnection();\n\n    // Set the remote description from the stored offer\n    this.logger.log('Setting remote description from offer');\n    await this.peerConnection.setRemoteDescription(new RTCSessionDescription(this.pendingOffer));\n\n    // Create an answer\n    this.logger.log('Creating answer...');\n    const answer = await this.peerConnection.createAnswer();\n\n    // Set the answer as our local description\n    await this.peerConnection.setLocalDescription(answer);\n\n    // Send the answer to the caller\n    this.signalingService.send('call-accepted', {\n      targetUserId,\n      answerSDP: answer\n    });\n    this.logger.log('Call accepted, answer sent');\n    this.sendPendingCandidates();\n  }\n\n  /**\n   * Set remote description for the peer connection\n   * @param {RTCSessionDescriptionInit} description - Remote description\n   */\n  async setRemoteDescription(description) {\n    try {\n      if (this.peerConnection) {\n        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(description));\n\n        // Apply any queued ICE candidates after remote description is set\n        this.logger.log('Remote description set, applying queued ICE candidates');\n        if (this.pendingCandidates && this.pendingCandidates.length > 0) {\n          this.logger.log(`Processing ${this.pendingCandidates.length} queued ICE candidates`);\n          const candidates = [...this.pendingCandidates];\n          this.pendingCandidates = [];\n          for (const candidate of candidates) {\n            try {\n              await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n              this.logger.log('Added queued ICE candidate');\n            } catch (err) {\n              this.logger.error('Error adding queued ICE candidate', err.message);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error setting remote description', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a remote ICE candidate\n   * @param {RTCIceCandidateInit} candidate - ICE candidate\n   */\n  async addRemoteIceCandidate(candidate) {\n    try {\n      // If peer connection doesn't exist yet or remote description is not set, \n      // store candidates for later\n      if (!this.peerConnection || !this.peerConnection.remoteDescription || !this.peerConnection.remoteDescription.type) {\n        this.logger.log('Remote description not set yet, queueing ICE candidate');\n        if (!this.pendingCandidates) this.pendingCandidates = [];\n        this.pendingCandidates.push(candidate);\n        return;\n      }\n      await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      this.logger.log('Added ICE candidate');\n    } catch (error) {\n      this.logger.error('Error adding ICE candidate', error.message);\n    }\n  }\n\n  /**\n   * Create WebRTC peer connection\n   */\n  createPeerConnection() {\n    // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n    const configuration = {\n      iceServers: [\n      // Multiple STUN servers for better connectivity\n      {\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }, {\n        urls: 'stun:stun3.l.google.com:19302'\n      }, {\n        urls: 'stun:stun4.l.google.com:19302'\n      },\n      // Free TURN server (replace with your own in production)\n      {\n        urls: 'turn:openrelay.metered.ca:80',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      }, {\n        urls: 'turn:openrelay.metered.ca:443',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      },\n      // If environment variables exist, add them too\n      ...(process.env.REACT_APP_TURN_SERVER ? [{\n        urls: process.env.REACT_APP_TURN_SERVER,\n        username: process.env.REACT_APP_TURN_USERNAME || '',\n        credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n      }] : [])],\n      iceCandidatePoolSize: 10,\n      // The following helps with connection stability\n      sdpSemantics: 'unified-plan'\n    };\n    this.logger.log('Initializing peer connection with configuration:', configuration);\n\n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n\n    // Set up event handlers\n    this.setupPeerConnectionEventHandlers();\n  }\n\n  /**\n   * Set up all event handlers for the peer connection\n   */\n  setupPeerConnectionEventHandlers() {\n    // Handle receiving remote media\n    this.peerConnection.ontrack = this.handleTrackEvent.bind(this);\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = this.handleIceCandidateEvent.bind(this);\n\n    // ICE gathering state\n    this.peerConnection.onicegatheringstatechange = () => {\n      this.logger.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n    };\n\n    // Signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      this.logger.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n\n    // Connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.logger.log('Connection state changed:', this.peerConnection.connectionState);\n    };\n\n    // ICE connection state\n    this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);\n  }\n\n  /**\n   * Handle track event (receiving remote tracks)\n   * @param {RTCTrackEvent} event - Track event\n   */\n  handleTrackEvent(event) {\n    this.logger.log('Received remote track:', event.track.kind);\n\n    // Create remote stream if it doesn't exist\n    if (!this.remoteStream) {\n      this.remoteStream = new MediaStream();\n      if (this.callbacks.onRemoteStream) {\n        this.callbacks.onRemoteStream(this.remoteStream);\n      }\n    }\n\n    // Add all tracks from the remote stream\n    event.streams[0].getTracks().forEach(track => {\n      this.logger.log('Adding remote track to remote stream:', track.kind);\n      this.remoteStream.addTrack(track);\n    });\n\n    // Check if we have both audio and video tracks\n    const hasAudioTrack = this.remoteStream.getAudioTracks().length > 0;\n    const hasVideoTrack = this.remoteStream.getVideoTracks().length > 0;\n    if ((hasAudioTrack || hasVideoTrack) && this.peerConnection) {\n      // Set a timer to update state if we have at least one media type\n      setTimeout(() => {\n        this.logger.log('Media is flowing, considering call as active');\n        this.updateCallState('active');\n\n        // Also notify the other peer\n        if (this.signalingService && this.targetUserId) {\n          this.signalingService.send('media-connected', {\n            targetUserId: this.targetUserId\n          });\n        }\n      }, 1000);\n    }\n  }\n\n  /**\n   * Handle ICE candidate event\n   * @param {RTCPeerConnectionIceEvent} event - ICE event\n   */\n  handleIceCandidateEvent(event) {\n    if (event.candidate && this.targetUserId) {\n      // Check if targetUserId exists\n      const candidateStr = event.candidate.candidate || '';\n      const candidateType = candidateStr.split(' ')[7] || 'unknown';\n      this.logger.log('Generated ICE candidate of type:', candidateType);\n      this.signalingService.send('ice-candidate', {\n        targetUserId: this.targetUserId,\n        candidate: event.candidate\n      });\n    } else if (event.candidate) {\n      // Store candidates temporarily if connection not ready\n      if (!this.pendingCandidates) this.pendingCandidates = [];\n      this.pendingCandidates.push(event.candidate);\n      this.logger.log('Storing ICE candidate for later');\n    }\n  }\n  sendPendingCandidates() {\n    if (this.pendingCandidates && this.pendingCandidates.length > 0 && this.targetUserId) {\n      this.logger.log(`Sending ${this.pendingCandidates.length} pending ICE candidates`);\n      this.pendingCandidates.forEach(candidate => {\n        this.signalingService.send('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: candidate\n        });\n      });\n      this.pendingCandidates = [];\n    }\n  }\n\n  /**\n   * Handle ICE connection state change\n   */\n  handleIceConnectionStateChange() {\n    const state = this.peerConnection.iceConnectionState;\n    this.logger.log('ICE connection state changed to:', state);\n    const previousState = this.iceConnectionState;\n    this.iceConnectionState = state;\n    this.logger.log('ICE connection state changed to:', state, 'from:', previousState);\n\n    // Notify callbacks\n    if (this.callbacks.onICEConnectionStateChange) {\n      this.callbacks.onICEConnectionStateChange(state);\n    }\n\n    // Handle connection establishment\n    if (state === 'connected' || state === 'completed') {\n      this.handleConnectionEstablished();\n    }\n    // Handle connection failure\n    else if (state === 'failed') {\n      this.handleConnectionFailure();\n    }\n    // Handle disconnection\n    else if (state === 'disconnected') {\n      this.handleConnectionDisconnected();\n    }\n    // Clear timers if state improves\n    else if ((state === 'checking' || state === 'connected') && (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n      this.clearConnectionTimers();\n    }\n  }\n\n  /**\n   * Handle successful connection establishment\n   */\n  handleConnectionEstablished() {\n    this.logger.log('Call connected successfully!');\n    this.updateCallState('active');\n\n    // Reset reconnection attempts\n    this.reconnectionAttempts = 0;\n\n    // Clear any pending timers\n    this.clearConnectionTimers();\n\n    // Notify the other peer that media is flowing on our side\n    if (this.signalingService && this.targetUserId) {\n      this.signalingService.send('media-connected', {\n        targetUserId: this.targetUserId\n      });\n    }\n  }\n\n  /**\n   * Handle connection failure\n   */\n  handleConnectionFailure() {\n    this.logger.log('Connection failed');\n    if (!this.failureTimeout) {\n      this.failureTimeout = setTimeout(() => {\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n          // Attempt to restart ICE if possible before ending the call\n          if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n            this.reconnectionAttempts++;\n            this.logger.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n\n            // Try to reconnect using our enhanced method\n            this.attemptReconnection(true);\n          } else {\n            this.logger.log('Max reconnection attempts reached, ending call');\n            this.updateCallState('ended');\n            // This would trigger call end in the main service\n          }\n        }\n        this.failureTimeout = null;\n      }, 1000);\n    }\n  }\n\n  /**\n   * Handle temporary disconnection\n   */\n  handleConnectionDisconnected() {\n    this.logger.log('Connection temporarily disconnected');\n\n    // Clear any existing timers first\n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n    }\n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n    }\n\n    // Start with a short timer for normal recovery\n    this.disconnectionTimer = setTimeout(() => {\n      // If still disconnected after short period, try recovery\n      if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n        this.logger.log('Connection still disconnected, attempting recovery...');\n        this.attemptReconnection(false);\n      }\n      this.disconnectionTimer = null;\n    }, 2000); // Try recovery after 2 seconds\n\n    // Also set a longer timeout for full failure\n    this.disconnectionFailureTimer = setTimeout(() => {\n      if (this.peerConnection && (this.peerConnection.iceConnectionState === 'disconnected' || this.peerConnection.iceConnectionState === 'failed')) {\n        this.logger.log('Connection remained disconnected for too long');\n        this.updateCallState('ended');\n        // This would trigger call end in the main service\n      }\n      this.disconnectionFailureTimer = null;\n    }, 15000); // End call after 15 seconds of disconnection\n  }\n\n  /**\n   * Clear all connection timers\n   */\n  clearConnectionTimers() {\n    if (this.failureTimeout) {\n      clearTimeout(this.failureTimeout);\n      this.failureTimeout = null;\n    }\n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n      this.disconnectionTimer = null;\n    }\n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n      this.disconnectionFailureTimer = null;\n    }\n  }\n\n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    this.logger.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n    try {\n      if (!this.peerConnection) {\n        this.logger.log('No peer connection to reconnect');\n        return;\n      }\n\n      // First try to restart ICE\n      this.peerConnection.restartIce();\n\n      // For more aggressive reconnection, try recreating the offer\n      if (aggressive || this.isCallInitiator) {\n        this.logger.log('Creating new offer with ICE restart');\n        const offer = await this.peerConnection.createOffer({\n          iceRestart: true,\n          offerToReceiveAudio: true,\n          offerToReceiveVideo: true\n        });\n        await this.peerConnection.setLocalDescription(offer);\n\n        // Send the new offer to the other user\n        this.signalingService.send('call-user', {\n          targetUserId: this.targetUserId,\n          offerSDP: offer,\n          callerUserId: this.userId\n        });\n        this.logger.log('Sent new offer for reconnection');\n      }\n    } catch (error) {\n      this.logger.error('Error during reconnection attempt', error.message);\n    }\n  }\n\n  /**\n   * Close the peer connection\n   */\n  closeConnection() {\n    // Clear all timers first\n    this.clearConnectionTimers();\n\n    // Close peer connection with careful cleanup\n    if (this.peerConnection) {\n      // Remove all event listeners first\n      this.peerConnection.onicecandidate = null;\n      this.peerConnection.ontrack = null;\n      this.peerConnection.oniceconnectionstatechange = null;\n      this.peerConnection.onicegatheringstatechange = null;\n      this.peerConnection.onsignalingstatechange = null;\n      this.peerConnection.onconnectionstatechange = null;\n\n      // Close the connection\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    // Clear the remote stream\n    this.remoteStream = null;\n  }\n\n  /**\n   * Reset the connection manager state\n   */\n  reset() {\n    this.remoteStream = null;\n    this.reconnectionAttempts = 0;\n    this.iceConnectionState = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n    this.clearConnectionTimers();\n  }\n\n  /**\n   * Clean up all resources\n   */\n  cleanup() {\n    this.closeConnection();\n    this.reset();\n  }\n}\nexport default WebRTCConnectionManager;","map":{"version":3,"names":["WebRTCConnectionManager","constructor","signalingService","mediaManager","eventEmitter","logger","updateCallState","peerConnection","remoteStream","isCallInitiator","targetUserId","pendingOffer","pendingCandidates","reconnectionAttempts","maxReconnectionAttempts","iceConnectionState","disconnectionTimer","disconnectionFailureTimer","failureTimeout","callbacks","onRemoteStream","onICEConnectionStateChange","setCallbacks","setPendingOffer","offer","setLocalStream","stream","localStream","getTracks","forEach","track","log","kind","addTrack","initiateCall","userId","createPeerConnection","createOffer","setLocalDescription","send","offerSDP","callerUserId","acceptCall","setRemoteDescription","RTCSessionDescription","answer","createAnswer","answerSDP","sendPendingCandidates","description","length","candidates","candidate","addIceCandidate","RTCIceCandidate","err","error","message","addRemoteIceCandidate","remoteDescription","type","push","configuration","iceServers","urls","username","credential","process","env","REACT_APP_TURN_SERVER","REACT_APP_TURN_USERNAME","REACT_APP_TURN_CREDENTIAL","iceCandidatePoolSize","sdpSemantics","RTCPeerConnection","setupPeerConnectionEventHandlers","ontrack","handleTrackEvent","bind","onicecandidate","handleIceCandidateEvent","onicegatheringstatechange","iceGatheringState","onsignalingstatechange","signalingState","onconnectionstatechange","connectionState","oniceconnectionstatechange","handleIceConnectionStateChange","event","MediaStream","streams","hasAudioTrack","getAudioTracks","hasVideoTrack","getVideoTracks","setTimeout","candidateStr","candidateType","split","state","previousState","handleConnectionEstablished","handleConnectionFailure","handleConnectionDisconnected","clearConnectionTimers","attemptReconnection","clearTimeout","aggressive","restartIce","iceRestart","offerToReceiveAudio","offerToReceiveVideo","closeConnection","close","reset","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCConnectionManager.js"],"sourcesContent":["// File: services/WebRTC/WebRTCConnectionManager.js\n/**\n * Manages WebRTC peer connection\n */\nclass WebRTCConnectionManager {\n  constructor(signalingService, mediaManager, eventEmitter, logger, updateCallState) {\n    this.signalingService = signalingService;\n    this.mediaManager = mediaManager;\n    this.eventEmitter = eventEmitter;\n    this.logger = logger;\n    this.updateCallState = updateCallState;\n    \n    // Connection\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.isCallInitiator = false;\n    this.targetUserId = null; // Add explicit tracking of target user\n    \n    // Call reconnection state\n    this.pendingOffer = null;\n    this.pendingCandidates = []; // Add storage for pending candidates\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.iceConnectionState = null;\n      \n      // Timers\n      this.disconnectionTimer = null;\n      this.disconnectionFailureTimer = null;\n      this.failureTimeout = null;\n      \n      // Callbacks\n      this.callbacks = {\n        onRemoteStream: null,\n        onICEConnectionStateChange: null\n      };\n    }\n    \n    /**\n     * Set callbacks for the connection manager\n     * @param {object} callbacks - Callback functions\n     */\n    setCallbacks(callbacks) {\n      this.callbacks = {\n        ...this.callbacks,\n        ...callbacks\n      };\n    }\n    \n    /**\n     * Set pending offer for incoming call\n     * @param {RTCSessionDescriptionInit} offer - SDP offer\n     */\n    setPendingOffer(offer) {\n      this.pendingOffer = offer;\n    }\n    \n    /**\n     * Set local stream to use for the call\n     * @param {MediaStream} stream - Local media stream\n     */\n    setLocalStream(stream) {\n      this.localStream = stream;\n      \n      // Add tracks to peer connection if it exists\n      if (this.peerConnection && stream) {\n        stream.getTracks().forEach(track => {\n          this.logger.log('Adding local track to peer connection:', track.kind);\n          this.peerConnection.addTrack(track, stream);\n        });\n      }\n    }\n    \n    /**\n     * Initialize a call to another user\n     * @param {string} userId - Current user ID\n     * @param {string} targetUserId - Target user ID\n     */\n    async initiateCall(userId, targetUserId) {\n      this.isCallInitiator = true;\n      this.targetUserId = targetUserId;\n      \n      // Create peer connection\n      this.createPeerConnection();\n      \n      // Create an offer (SDP)\n      this.logger.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      \n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // Send the offer to the other user via signaling server\n      this.signalingService.send('call-user', {\n        targetUserId,\n        offerSDP: offer,\n        callerUserId: userId\n      });\n      \n      this.logger.log('Call offer sent');\n    }\n    \n    /**\n     * Accept an incoming call\n     * @param {string} targetUserId - ID of the caller\n     */\n    async acceptCall(targetUserId) {\n      this.targetUserId = targetUserId; // Set target ID here too\n      // Create peer connection\n      this.createPeerConnection();\n      \n      // Set the remote description from the stored offer\n      this.logger.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(\n        new RTCSessionDescription(this.pendingOffer)\n      );\n      \n      // Create an answer\n      this.logger.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n      \n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n      \n      // Send the answer to the caller\n      this.signalingService.send('call-accepted', {\n        targetUserId,\n        answerSDP: answer\n      });\n      \n      this.logger.log('Call accepted, answer sent');\n      this.sendPendingCandidates();\n    }\n    \n    /**\n     * Set remote description for the peer connection\n     * @param {RTCSessionDescriptionInit} description - Remote description\n     */\n    async setRemoteDescription(description) {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(\n            new RTCSessionDescription(description)\n          );\n          \n          // Apply any queued ICE candidates after remote description is set\n          this.logger.log('Remote description set, applying queued ICE candidates');\n          if (this.pendingCandidates && this.pendingCandidates.length > 0) {\n            this.logger.log(`Processing ${this.pendingCandidates.length} queued ICE candidates`);\n            \n            const candidates = [...this.pendingCandidates];\n            this.pendingCandidates = [];\n            \n            for (const candidate of candidates) {\n              try {\n                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n                this.logger.log('Added queued ICE candidate');\n              } catch (err) {\n                this.logger.error('Error adding queued ICE candidate', err.message);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        this.logger.error('Error setting remote description', error.message);\n        throw error;\n      }\n    }\n    \n    /**\n     * Add a remote ICE candidate\n     * @param {RTCIceCandidateInit} candidate - ICE candidate\n     */\n    async addRemoteIceCandidate(candidate) {\n      try {\n        // If peer connection doesn't exist yet or remote description is not set, \n        // store candidates for later\n        if (!this.peerConnection || \n            !this.peerConnection.remoteDescription || \n            !this.peerConnection.remoteDescription.type) {\n          \n          this.logger.log('Remote description not set yet, queueing ICE candidate');\n          if (!this.pendingCandidates) this.pendingCandidates = [];\n          this.pendingCandidates.push(candidate);\n          return;\n        }\n        \n        await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        this.logger.log('Added ICE candidate');\n      } catch (error) {\n        this.logger.error('Error adding ICE candidate', error.message);\n      }\n    }\n    \n    /**\n     * Create WebRTC peer connection\n     */\n    createPeerConnection() {\n      // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n      const configuration = {\n        iceServers: [\n          // Multiple STUN servers for better connectivity\n          { urls: 'stun:stun.l.google.com:19302' },\n          { urls: 'stun:stun1.l.google.com:19302' },\n          { urls: 'stun:stun2.l.google.com:19302' },\n          { urls: 'stun:stun3.l.google.com:19302' },\n          { urls: 'stun:stun4.l.google.com:19302' },\n          // Free TURN server (replace with your own in production)\n          {\n            urls: 'turn:openrelay.metered.ca:80',\n            username: 'openrelayproject',\n            credential: 'openrelayproject'\n          },\n          {\n            urls: 'turn:openrelay.metered.ca:443',\n            username: 'openrelayproject',\n            credential: 'openrelayproject'\n          },\n          // If environment variables exist, add them too\n          ...(process.env.REACT_APP_TURN_SERVER ? [{\n            urls: process.env.REACT_APP_TURN_SERVER,\n            username: process.env.REACT_APP_TURN_USERNAME || '',\n            credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n          }] : [])\n        ],\n        iceCandidatePoolSize: 10,\n        // The following helps with connection stability\n        sdpSemantics: 'unified-plan'\n      };\n      \n      this.logger.log('Initializing peer connection with configuration:', configuration);\n      \n      // Create the RTCPeerConnection\n      this.peerConnection = new RTCPeerConnection(configuration);\n      \n      // Add local media tracks to the connection if we have them\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.logger.log('Adding local track to peer connection:', track.kind);\n          this.peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Set up event handlers\n      this.setupPeerConnectionEventHandlers();\n    }\n    \n    /**\n     * Set up all event handlers for the peer connection\n     */\n    setupPeerConnectionEventHandlers() {\n      // Handle receiving remote media\n      this.peerConnection.ontrack = this.handleTrackEvent.bind(this);\n      \n      // Handle ICE candidates\n      this.peerConnection.onicecandidate = this.handleIceCandidateEvent.bind(this);\n      \n      // ICE gathering state\n      this.peerConnection.onicegatheringstatechange = () => {\n        this.logger.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n      };\n      \n      // Signaling state\n      this.peerConnection.onsignalingstatechange = () => {\n        this.logger.log('Signaling state changed:', this.peerConnection.signalingState);\n      };\n      \n      // Connection state\n      this.peerConnection.onconnectionstatechange = () => {\n        this.logger.log('Connection state changed:', this.peerConnection.connectionState);\n      };\n      \n      // ICE connection state\n      this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);\n    }\n    \n    /**\n     * Handle track event (receiving remote tracks)\n     * @param {RTCTrackEvent} event - Track event\n     */\n    handleTrackEvent(event) {\n      this.logger.log('Received remote track:', event.track.kind);\n      \n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.remoteStream = new MediaStream();\n        if (this.callbacks.onRemoteStream) {\n          this.callbacks.onRemoteStream(this.remoteStream);\n        }\n      }\n      \n      // Add all tracks from the remote stream\n      event.streams[0].getTracks().forEach(track => {\n        this.logger.log('Adding remote track to remote stream:', track.kind);\n        this.remoteStream.addTrack(track);\n      });\n      \n      // Check if we have both audio and video tracks\n      const hasAudioTrack = this.remoteStream.getAudioTracks().length > 0;\n      const hasVideoTrack = this.remoteStream.getVideoTracks().length > 0;\n      \n      if ((hasAudioTrack || hasVideoTrack) && this.peerConnection) {\n        // Set a timer to update state if we have at least one media type\n        setTimeout(() => {\n          this.logger.log('Media is flowing, considering call as active');\n          this.updateCallState('active');\n          \n          // Also notify the other peer\n          if (this.signalingService && this.targetUserId) {\n            this.signalingService.send('media-connected', {\n              targetUserId: this.targetUserId\n            });\n          }\n        }, 1000);\n      }\n    }\n    \n    /**\n     * Handle ICE candidate event\n     * @param {RTCPeerConnectionIceEvent} event - ICE event\n     */\n    handleIceCandidateEvent(event) {\n      if (event.candidate && this.targetUserId) { // Check if targetUserId exists\n        const candidateStr = event.candidate.candidate || '';\n        const candidateType = candidateStr.split(' ')[7] || 'unknown';\n        this.logger.log('Generated ICE candidate of type:', candidateType);\n        \n        this.signalingService.send('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      } else if (event.candidate) {\n        // Store candidates temporarily if connection not ready\n        if (!this.pendingCandidates) this.pendingCandidates = [];\n        this.pendingCandidates.push(event.candidate);\n        this.logger.log('Storing ICE candidate for later');\n      }\n    }\n\n    sendPendingCandidates() {\n      if (this.pendingCandidates && this.pendingCandidates.length > 0 && this.targetUserId) {\n        this.logger.log(`Sending ${this.pendingCandidates.length} pending ICE candidates`);\n        this.pendingCandidates.forEach(candidate => {\n          this.signalingService.send('ice-candidate', {\n            targetUserId: this.targetUserId,\n            candidate: candidate\n          });\n        });\n        this.pendingCandidates = [];\n      }\n    }\n    \n    /**\n     * Handle ICE connection state change\n     */\n    handleIceConnectionStateChange() {\n      const state = this.peerConnection.iceConnectionState;\n      this.logger.log('ICE connection state changed to:', state);\n      const previousState = this.iceConnectionState;\n      this.iceConnectionState = state;\n      \n      this.logger.log('ICE connection state changed to:', state, 'from:', previousState);\n      \n      // Notify callbacks\n      if (this.callbacks.onICEConnectionStateChange) {\n        this.callbacks.onICEConnectionStateChange(state);\n      }\n      \n      // Handle connection establishment\n      if (state === 'connected' || state === 'completed') {\n        this.handleConnectionEstablished();\n      } \n      // Handle connection failure\n      else if (state === 'failed') {\n        this.handleConnectionFailure();\n      }\n      // Handle disconnection\n      else if (state === 'disconnected') {\n        this.handleConnectionDisconnected();\n      }\n      // Clear timers if state improves\n      else if ((state === 'checking' || state === 'connected') && \n              (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n        this.clearConnectionTimers();\n      }\n    }\n    \n    /**\n     * Handle successful connection establishment\n     */\n    handleConnectionEstablished() {\n      this.logger.log('Call connected successfully!');\n      this.updateCallState('active');\n      \n      // Reset reconnection attempts\n      this.reconnectionAttempts = 0;\n      \n      // Clear any pending timers\n      this.clearConnectionTimers();\n      \n      // Notify the other peer that media is flowing on our side\n      if (this.signalingService && this.targetUserId) {\n        this.signalingService.send('media-connected', {\n          targetUserId: this.targetUserId\n        });\n      }\n    }\n    \n    /**\n     * Handle connection failure\n     */\n    handleConnectionFailure() {\n      this.logger.log('Connection failed');\n      \n      if (!this.failureTimeout) {\n        this.failureTimeout = setTimeout(() => {\n          if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n            // Attempt to restart ICE if possible before ending the call\n            if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n              this.reconnectionAttempts++;\n              this.logger.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n              \n              // Try to reconnect using our enhanced method\n              this.attemptReconnection(true);\n            } else {\n              this.logger.log('Max reconnection attempts reached, ending call');\n              this.updateCallState('ended');\n              // This would trigger call end in the main service\n            }\n          }\n          this.failureTimeout = null;\n        }, 1000);\n      }\n    }\n    \n    /**\n     * Handle temporary disconnection\n     */\n    handleConnectionDisconnected() {\n      this.logger.log('Connection temporarily disconnected');\n      \n      // Clear any existing timers first\n      if (this.disconnectionTimer) {\n        clearTimeout(this.disconnectionTimer);\n      }\n      \n      if (this.disconnectionFailureTimer) {\n        clearTimeout(this.disconnectionFailureTimer);\n      }\n      \n      // Start with a short timer for normal recovery\n      this.disconnectionTimer = setTimeout(() => {\n        // If still disconnected after short period, try recovery\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n          this.logger.log('Connection still disconnected, attempting recovery...');\n          this.attemptReconnection(false);\n        }\n        this.disconnectionTimer = null;\n      }, 2000); // Try recovery after 2 seconds\n      \n      // Also set a longer timeout for full failure\n      this.disconnectionFailureTimer = setTimeout(() => {\n        if (this.peerConnection && \n            (this.peerConnection.iceConnectionState === 'disconnected' || \n             this.peerConnection.iceConnectionState === 'failed')) {\n          this.logger.log('Connection remained disconnected for too long');\n          this.updateCallState('ended');\n          // This would trigger call end in the main service\n        }\n        this.disconnectionFailureTimer = null;\n      }, 15000); // End call after 15 seconds of disconnection\n    }\n    \n    /**\n     * Clear all connection timers\n     */\n    clearConnectionTimers() {\n      if (this.failureTimeout) {\n        clearTimeout(this.failureTimeout);\n        this.failureTimeout = null;\n      }\n      \n      if (this.disconnectionTimer) {\n        clearTimeout(this.disconnectionTimer);\n        this.disconnectionTimer = null;\n      }\n      \n      if (this.disconnectionFailureTimer) {\n        clearTimeout(this.disconnectionFailureTimer);\n        this.disconnectionFailureTimer = null;\n      }\n    }\n    \n    /**\n     * Attempt to reconnect during call problems\n     * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n     */\n    async attemptReconnection(aggressive = false) {\n      this.logger.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n      \n      try {\n        if (!this.peerConnection) {\n          this.logger.log('No peer connection to reconnect');\n          return;\n        }\n        \n        // First try to restart ICE\n        this.peerConnection.restartIce();\n        \n        // For more aggressive reconnection, try recreating the offer\n        if (aggressive || this.isCallInitiator) {\n          this.logger.log('Creating new offer with ICE restart');\n          const offer = await this.peerConnection.createOffer({ \n            iceRestart: true,\n            offerToReceiveAudio: true,\n            offerToReceiveVideo: true\n          });\n          \n          await this.peerConnection.setLocalDescription(offer);\n          \n          // Send the new offer to the other user\n          this.signalingService.send('call-user', {\n            targetUserId: this.targetUserId,\n            offerSDP: offer,\n            callerUserId: this.userId\n          });\n          \n          this.logger.log('Sent new offer for reconnection');\n        }\n      } catch (error) {\n        this.logger.error('Error during reconnection attempt', error.message);\n      }\n    }\n    \n    /**\n     * Close the peer connection\n     */\n    closeConnection() {\n      // Clear all timers first\n      this.clearConnectionTimers();\n      \n      // Close peer connection with careful cleanup\n      if (this.peerConnection) {\n        // Remove all event listeners first\n        this.peerConnection.onicecandidate = null;\n        this.peerConnection.ontrack = null;\n        this.peerConnection.oniceconnectionstatechange = null;\n        this.peerConnection.onicegatheringstatechange = null;\n        this.peerConnection.onsignalingstatechange = null;\n        this.peerConnection.onconnectionstatechange = null;\n        \n        // Close the connection\n        this.peerConnection.close();\n        this.peerConnection = null;\n      }\n      \n      // Clear the remote stream\n      this.remoteStream = null;\n    }\n    \n    /**\n     * Reset the connection manager state\n     */\n    reset() {\n      this.remoteStream = null;\n      this.reconnectionAttempts = 0;\n      this.iceConnectionState = null;\n      this.pendingOffer = null;\n      this.isCallInitiator = false;\n      \n      this.clearConnectionTimers();\n    }\n    \n    /**\n     * Clean up all resources\n     */\n    cleanup() {\n      this.closeConnection();\n      this.reset();\n    }\n  }\n  \n  export default WebRTCConnectionManager;\n  \n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}