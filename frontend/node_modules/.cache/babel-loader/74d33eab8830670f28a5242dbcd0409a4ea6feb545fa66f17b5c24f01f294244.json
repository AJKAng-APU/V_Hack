{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectScreen = ({\n  colors,\n  setActiveScreen\n}) => {\n  _s();\n  const {\n    isDarkMode\n  } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n\n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(localStorage.getItem('is_doctor') === 'true');\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n\n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n\n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n\n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Sample doctors data\n  const doctors = [{\n    id: 1,\n    name: \"Dr. Johnson\",\n    specialty: \"Cardiologist\",\n    image: \"/User_1.png\",\n    availability: \"Available now\",\n    rating: 5\n  }, {\n    id: 2,\n    name: \"Dr. Smith\",\n    specialty: \"Primary Care\",\n    image: \"/User_2.jpg\",\n    availability: \"Available in 15m\",\n    rating: 4\n  }, {\n    id: 3,\n    name: \"Dr. Garcia\",\n    specialty: \"Endocrinologist\",\n    image: \"/User_3.png\",\n    availability: \"Available tomorrow\",\n    rating: 5\n  }, {\n    id: 4,\n    name: \"Dr. Chen\",\n    specialty: \"Neurologist\",\n    image: \"/User_4.png\",\n    availability: \"Available in 2h\",\n    rating: 4\n  }];\n\n  // FIXED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    console.log(\"Doctor mode changed to:\", isDoctorMode ? \"ON\" : \"OFF\");\n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          // FIXED: Proper signaling service access\n          if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n            const doctorId = 1;\n            // FIXED: Use the send method instead of directly accessing socket\n            webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n            console.log(`ðŸ©º Successfully registered as doctor-${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n\n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n\n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    const callbacks = {\n      onIncomingCall: callerId => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      onUserNotOnline: userId => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        setConnectingDoctor(null);\n      }\n    };\n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && webRTCService.signalingService.isConnected() && !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.signalingService.send('register', currentUserId);\n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', error => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      clearInterval(registerInterval);\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {/* handle error */}\n      }\n      setIncomingCallInfo(null);\n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      webRTCService.disconnect();\n    };\n  }, []);\n\n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: doctor => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n\n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      cleanupPreviousCall();\n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          audio.addEventListener('error', e => {\n            console.error('Ringtone error:', e);\n          });\n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      playRingtone();\n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      setAutoAcceptTimer(timer);\n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    acceptIncomingCall: doctor => {\n      console.log('Accepting incoming call from:', doctor === null || doctor === void 0 ? void 0 : doctor.name);\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      setIncomingCallInfo(null);\n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      webRTCService.declineCall();\n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      displayToast('Call rejected');\n    },\n    checkDoctorOnline: async doctorId => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    // FIXED: initiateCall method with proper state checks\n    initiateCall: async doctor => {\n      if (!webRTCService || !doctor) return;\n      try {\n        // FIXED: Use webRTCService.isCallActive() instead of callState\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n\n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n    handleConnectDoctor: async doctor => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  const {\n    displayIncomingCallAlert,\n    acceptIncomingCall,\n    rejectIncomingCall,\n    initiateCall,\n    handleConnectDoctor\n  } = callHandlers;\n\n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n\n  // Handle search filtering\n  const handleSearch = query => {\n    setSearchQuery(query);\n  };\n\n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery ? doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()) : true;\n    const matchesAvailability = filterActive ? doctor.availability.includes('Available') && !doctor.availability.includes('in') : true;\n    return matchesSearch && matchesAvailability;\n  });\n\n  // Improved toast display function\n  const displayToast = message => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n\n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n\n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-6 pb-24 dark-mode-transition\",\n    style: {\n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)` : 'none'\n    },\n    children: [/*#__PURE__*/_jsxDEV(ConnectHeader, {\n      headerVisible: headerVisible,\n      notifications: notifications,\n      setNotifications: setNotifications,\n      colors: colors,\n      isDoctorMode: isDoctorMode,\n      setIsDoctorMode: setIsDoctorMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 539,\n      columnNumber: 7\n    }, this), incomingCallCounter > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 p-2 bg-red-100 rounded-md text-xs\",\n      children: [\"Incoming call events received: \", incomingCallCounter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 549,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(SearchBar, {\n      headerVisible: headerVisible,\n      searchFocused: searchFocused,\n      setSearchFocused: setSearchFocused,\n      searchQuery: searchQuery,\n      setSearchQuery: setSearchQuery,\n      handleSearch: handleSearch,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 554,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FilterChips, {\n      headerVisible: headerVisible,\n      filterActive: filterActive,\n      setFilterActive: setFilterActive,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 565,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DoctorsTeam, {\n      headerVisible: headerVisible,\n      doctors: filteredDoctors,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      handleConnectDoctor: handleConnectDoctor,\n      setSelectedDoctor: setSelectedDoctor,\n      setSchedulingDoctor: setSchedulingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 573,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(QuickConnectActions, {\n      headerVisible: headerVisible,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      initiateCall: initiateCall,\n      displayToast: displayToast,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 585,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RecentMessages, {\n      headerVisible: headerVisible,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 595,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MessageDialog, {\n      isOpen: showMessageDialog,\n      onClose: () => {\n        setShowMessageDialog(false);\n        setSchedulingDoctor(null);\n      },\n      colors: colors,\n      recipient: schedulingDoctor || connectingDoctor,\n      doctors: doctors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 601,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoCallScreen, {\n      isOpen: showVideoCall,\n      onClose: () => setShowVideoCall(false),\n      colors: colors,\n      doctor: connectingDoctor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 613,\n      columnNumber: 7\n    }, this), incomingCallInfo && /*#__PURE__*/_jsxDEV(IncomingCallUI, {\n      incomingCallInfo: incomingCallInfo,\n      colors: colors,\n      acceptIncomingCall: acceptIncomingCall,\n      rejectIncomingCall: rejectIncomingCall\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 622,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ToastNotification, {\n      activeToast: activeToast,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 631,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 637,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 532,\n    columnNumber: 5\n  }, this);\n};\n_s(ConnectScreen, \"kyZTdQukLxV/Hiq0PzZgaXBQPg0=\", false, function () {\n  return [useTheme];\n});\n_c = ConnectScreen;\nexport default ConnectScreen;\nvar _c;\n$RefreshReg$(_c, \"ConnectScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","MessageDialog","VideoCallScreen","ConnectHeader","SearchBar","FilterChips","DoctorsTeam","QuickConnectActions","RecentMessages","IncomingCallUI","ToastNotification","jsxDEV","_jsxDEV","ConnectScreen","colors","setActiveScreen","_s","isDarkMode","searchFocused","setSearchFocused","searchQuery","setSearchQuery","notifications","setNotifications","filterActive","setFilterActive","showMessageDialog","setShowMessageDialog","showVideoCall","setShowVideoCall","selectedDoctor","setSelectedDoctor","connectingDoctor","setConnectingDoctor","schedulingDoctor","setSchedulingDoctor","readyToConnect","setReadyToConnect","isDoctorMode","setIsDoctorMode","localStorage","getItem","toastQueue","setToastQueue","activeToast","setActiveToast","incomingCallInfo","setIncomingCallInfo","ringtoneAudio","setRingtoneAudio","autoAcceptTimer","setAutoAcceptTimer","incomingCallCounter","setIncomingCallCounter","prevShowVideoCall","doctors","id","name","specialty","image","availability","rating","setItem","console","log","registerAsDoctor","signalingService","isConnected","doctorId","send","displayToast","setTimeout","error","userId","generateUniqueId","storedId","newId","Math","random","toString","substring","currentUserId","callbacks","onIncomingCall","callerId","prev","callingDoctor","find","doc","parseInt","replace","displayIncomingCallAlert","onUserNotOnline","doctor","serverUrl","process","env","REACT_APP_SIGNALING_SERVER","initialize","registerInterval","setInterval","isCallActive","unsubscribeError","on","message","fatal","clearInterval","clearTimeout","pause","currentTime","e","disconnect","callHandlers","cleanupPreviousCall","callNotificationId","Date","now","timestamp","playRingtone","audio","Audio","loop","volume","addEventListener","playPromise","play","undefined","then","catch","timer","acceptIncomingCall","acceptCall","rejectIncomingCall","declineCall","checkDoctorOnline","attempt","isOnline","checkUserOnline","Promise","resolve","initiateCall","getLocalMedia","makeCall","handleConnectDoctor","current","handleSearch","query","filteredDoctors","filter","matchesSearch","toLowerCase","includes","matchesAvailability","length","slice","headerVisible","setHeaderVisible","className","style","backgroundColor","background","backgroundImage","primary","accent","children","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","onClose","recipient","jsx","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext'; \nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\n\nconst ConnectScreen = ({ colors, setActiveScreen }) => {\n  const { isDarkMode } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n  \n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(\n    localStorage.getItem('is_doctor') === 'true'\n  );\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n  \n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  \n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n  \n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n  \n  // Sample doctors data\n  const doctors = [\n    {\n      id: 1,\n      name: \"Dr. Johnson\",\n      specialty: \"Cardiologist\",\n      image: \"/User_1.png\",\n      availability: \"Available now\",\n      rating: 5\n    },\n    {\n      id: 2,\n      name: \"Dr. Smith\",\n      specialty: \"Primary Care\",\n      image: \"/User_2.jpg\",\n      availability: \"Available in 15m\",\n      rating: 4\n    },\n    {\n      id: 3,\n      name: \"Dr. Garcia\",\n      specialty: \"Endocrinologist\",\n      image: \"/User_3.png\",\n      availability: \"Available tomorrow\",\n      rating: 5\n    },\n    {\n      id: 4,\n      name: \"Dr. Chen\",\n      specialty: \"Neurologist\",\n      image: \"/User_4.png\",\n      availability: \"Available in 2h\",\n      rating: 4\n    },\n  ];\n\n  // FIXED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    console.log(\"Doctor mode changed to:\", isDoctorMode ? \"ON\" : \"OFF\");\n    \n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          // FIXED: Proper signaling service access\n          if (webRTCService.signalingService && \n              webRTCService.signalingService.isConnected()) {\n            const doctorId = 1;\n            // FIXED: Use the send method instead of directly accessing socket\n            webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n            console.log(`ðŸ©º Successfully registered as doctor-${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      \n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && \n            webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n  \n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n  \n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      \n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    \n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    \n    const callbacks = {\n      onIncomingCall: (callerId) => {\n        console.log('Incoming call received from:', callerId);\n        \n        setIncomingCallCounter(prev => prev + 1);\n        \n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        \n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        \n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      \n      onUserNotOnline: (userId) => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        \n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        \n        setConnectingDoctor(null);\n      }\n    };\n    \n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    \n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    \n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && \n          webRTCService.signalingService.isConnected() && \n          !webRTCService.isCallActive() && \n          !showVideoCall) {\n        \n        webRTCService.signalingService.send('register', currentUserId);\n        \n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    \n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', (error) => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        \n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    \n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      \n      clearInterval(registerInterval);\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) { /* handle error */ }\n      }\n      \n      setIncomingCallInfo(null);\n      \n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      \n      webRTCService.disconnect();\n    };\n  }, []);\n  \n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n      \n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        \n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        \n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      \n      cleanupPreviousCall();\n      \n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      \n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          \n          audio.addEventListener('error', (e) => {\n            console.error('Ringtone error:', e);\n          });\n          \n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      \n      playRingtone();\n      \n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      \n      setAutoAcceptTimer(timer);\n      \n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    \n    acceptIncomingCall: (doctor) => {\n      console.log('Accepting incoming call from:', doctor?.name);\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      setIncomingCallInfo(null);\n      \n      webRTCService.acceptCall();\n      \n      setShowVideoCall(true);\n      \n      displayToast(`Connected with ${doctor.name}`);\n    },\n    \n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      webRTCService.declineCall();\n      \n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      \n      displayToast('Call rejected');\n    },\n    \n    checkDoctorOnline: async (doctorId) => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    \n    // FIXED: initiateCall method with proper state checks\n    initiateCall: async (doctor) => {\n      if (!webRTCService || !doctor) return;\n  \n      try {\n        // FIXED: Use webRTCService.isCallActive() instead of callState\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          \n          setShowVideoCall(true);\n          return;\n        }\n        \n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        \n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        \n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n      \n    handleConnectDoctor: async (doctor) => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      \n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        \n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        \n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        \n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  \n  const { displayIncomingCallAlert, acceptIncomingCall, rejectIncomingCall, initiateCall, handleConnectDoctor } = callHandlers;\n  \n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    \n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n  \n  // Handle search filtering\n  const handleSearch = (query) => {\n    setSearchQuery(query);\n  };\n  \n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery \n      ? (doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || \n         doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()))\n      : true;\n      \n    const matchesAvailability = filterActive \n      ? doctor.availability.includes('Available') && !doctor.availability.includes('in')\n      : true;\n      \n    return matchesSearch && matchesAvailability;\n  });\n  \n  // Improved toast display function\n  const displayToast = (message) => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n  \n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      \n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n  \n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div className=\"p-6 pb-24 dark-mode-transition\" style={{ \n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode \n        ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)`\n        : 'none'\n    }}>\n      <ConnectHeader \n        headerVisible={headerVisible}\n        notifications={notifications}\n        setNotifications={setNotifications}\n        colors={colors}\n        isDoctorMode={isDoctorMode}\n        setIsDoctorMode={setIsDoctorMode}\n      />\n      \n      {incomingCallCounter > 0 && (\n        <div className=\"mb-2 p-2 bg-red-100 rounded-md text-xs\">\n          Incoming call events received: {incomingCallCounter}\n        </div>\n      )}\n      \n      <SearchBar \n        headerVisible={headerVisible}\n        searchFocused={searchFocused}\n        setSearchFocused={setSearchFocused}\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n        handleSearch={handleSearch}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <FilterChips \n        headerVisible={headerVisible}\n        filterActive={filterActive}\n        setFilterActive={setFilterActive}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <DoctorsTeam \n        headerVisible={headerVisible}\n        doctors={filteredDoctors}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        handleConnectDoctor={handleConnectDoctor}\n        setSelectedDoctor={setSelectedDoctor}\n        setSchedulingDoctor={setSchedulingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        isDarkMode={isDarkMode}\n      />\n      \n      <QuickConnectActions \n        headerVisible={headerVisible}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        initiateCall={initiateCall}\n        displayToast={displayToast}\n        isDarkMode={isDarkMode}\n      />\n      \n      <RecentMessages \n        headerVisible={headerVisible}\n        colors={colors}\n      />\n      \n      {/* Message Dialog */}\n      <MessageDialog \n        isOpen={showMessageDialog}\n        onClose={() => {\n          setShowMessageDialog(false);\n          setSchedulingDoctor(null);\n        }}\n        colors={colors}\n        recipient={schedulingDoctor || connectingDoctor}\n        doctors={doctors}\n      />\n      \n      {/* Video Call Screen */}\n      <VideoCallScreen \n        isOpen={showVideoCall}\n        onClose={() => setShowVideoCall(false)}\n        colors={colors}\n        doctor={connectingDoctor}\n      />\n      \n      {/* Incoming Call UI */}\n      {incomingCallInfo && (\n        <IncomingCallUI \n          incomingCallInfo={incomingCallInfo}\n          colors={colors}\n          acceptIncomingCall={acceptIncomingCall}\n          rejectIncomingCall={rejectIncomingCall}\n        />\n      )}\n      \n      {/* Toast Notification */}\n      <ToastNotification \n        activeToast={activeToast}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <style jsx>{`\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ConnectScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}