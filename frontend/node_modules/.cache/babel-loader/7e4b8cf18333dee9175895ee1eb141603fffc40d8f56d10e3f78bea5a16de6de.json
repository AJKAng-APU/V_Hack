{"ast":null,"code":"// File: services/WebRTC/WebRTCConnectionManager.js\n/**\n * Manages WebRTC peer connection\n */\nclass WebRTCConnectionManager {\n  constructor(signalingService, mediaManager, eventEmitter, logger, updateCallState) {\n    this.signalingService = signalingService;\n    this.mediaManager = mediaManager;\n    this.eventEmitter = eventEmitter;\n    this.logger = logger;\n    this.updateCallState = updateCallState;\n\n    // Connection\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.isCallInitiator = false;\n    this.targetUserId = null; // Add explicit tracking of target user\n\n    // Call reconnection state\n    this.pendingOffer = null;\n    this.pendingCandidates = []; // Add storage for pending candidates\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.iceConnectionState = null;\n\n    // Timers\n    this.disconnectionTimer = null;\n    this.disconnectionFailureTimer = null;\n    this.failureTimeout = null;\n\n    // Callbacks\n    this.callbacks = {\n      onRemoteStream: null,\n      onICEConnectionStateChange: null\n    };\n  }\n\n  /**\n   * Set callbacks for the connection manager\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Set pending offer for incoming call\n   * @param {RTCSessionDescriptionInit} offer - SDP offer\n   */\n  setPendingOffer(offer) {\n    this.pendingOffer = offer;\n  }\n\n  /**\n   * Set local stream to use for the call\n   * @param {MediaStream} stream - Local media stream\n   */\n  setLocalStream(stream) {\n    this.localStream = stream;\n\n    // Add tracks to peer connection if it exists\n    if (this.peerConnection && stream) {\n      stream.getTracks().forEach(track => {\n        this.logger.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, stream);\n      });\n    }\n  }\n\n  /**\n   * Initialize a call to another user\n   * @param {string} userId - Current user ID\n   * @param {string} targetUserId - Target user ID\n   */\n  async initiateCall(userId, targetUserId) {\n    this.isCallInitiator = true;\n    this.targetUserId = targetUserId;\n\n    // Create peer connection\n    this.createPeerConnection();\n\n    // Create an offer (SDP)\n    this.logger.log('Creating offer...');\n    const offer = await this.peerConnection.createOffer();\n\n    // Set the offer as our local description\n    await this.peerConnection.setLocalDescription(offer);\n\n    // Send the offer to the other user via signaling server\n    this.signalingService.send('call-user', {\n      targetUserId,\n      offerSDP: offer,\n      callerUserId: userId\n    });\n    this.logger.log('Call offer sent');\n  }\n\n  /**\n   * Accept an incoming call\n   * @param {string} targetUserId - ID of the caller\n   */\n  async acceptCall(targetUserId) {\n    this.targetUserId = targetUserId; // Set target ID here too\n    // Create peer connection\n    this.createPeerConnection();\n\n    // Set the remote description from the stored offer\n    this.logger.log('Setting remote description from offer');\n    await this.peerConnection.setRemoteDescription(new RTCSessionDescription(this.pendingOffer));\n\n    // Create an answer\n    this.logger.log('Creating answer...');\n    const answer = await this.peerConnection.createAnswer();\n\n    // Set the answer as our local description\n    await this.peerConnection.setLocalDescription(answer);\n\n    // Send the answer to the caller\n    this.signalingService.send('call-accepted', {\n      targetUserId,\n      answerSDP: answer\n    });\n    this.logger.log('Call accepted, answer sent');\n    this.sendPendingCandidates();\n  }\n\n  /**\n   * Set remote description for the peer connection\n   * @param {RTCSessionDescriptionInit} description - Remote description\n   */\n  async setRemoteDescription(description) {\n    try {\n      if (this.peerConnection) {\n        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(description));\n\n        // Apply any queued ICE candidates after remote description is set\n        this.logger.log('Remote description set, applying queued ICE candidates');\n        if (this.pendingCandidates && this.pendingCandidates.length > 0) {\n          this.logger.log(`Processing ${this.pendingCandidates.length} queued ICE candidates`);\n          const candidates = [...this.pendingCandidates];\n          this.pendingCandidates = [];\n          for (const candidate of candidates) {\n            try {\n              await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n              this.logger.log('Added queued ICE candidate');\n            } catch (err) {\n              this.logger.error('Error adding queued ICE candidate', err.message);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error setting remote description', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a remote ICE candidate\n   * @param {RTCIceCandidateInit} candidate - ICE candidate\n   */\n  async addRemoteIceCandidate(candidate) {\n    try {\n      // If peer connection doesn't exist yet or remote description is not set, \n      // store candidates for later\n      if (!this.peerConnection || !this.peerConnection.remoteDescription || !this.peerConnection.remoteDescription.type) {\n        this.logger.log('Remote description not set yet, queueing ICE candidate');\n        if (!this.pendingCandidates) this.pendingCandidates = [];\n        this.pendingCandidates.push(candidate);\n        return;\n      }\n      await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      this.logger.log('Added ICE candidate');\n    } catch (error) {\n      this.logger.error('Error adding ICE candidate', error.message);\n    }\n  }\n\n  /**\n   * Create WebRTC peer connection\n   */\n  createPeerConnection() {\n    // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n    const configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }, {\n        urls: 'stun:stun3.l.google.com:19302'\n      }, {\n        urls: 'stun:stun4.l.google.com:19302'\n      },\n      // Free TURN server (replace with your own in production)\n      {\n        urls: 'turn:openrelay.metered.ca:80',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      }, {\n        urls: 'turn:openrelay.metered.ca:443',\n        username: 'openrelayproject',\n        credential: 'openrelayproject'\n      },\n      // If environment variables exist, add them too\n      ...(process.env.REACT_APP_TURN_SERVER ? [{\n        urls: process.env.REACT_APP_TURN_SERVER,\n        username: process.env.REACT_APP_TURN_USERNAME || '',\n        credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n      }] : [])],\n      iceCandidatePoolSize: 10,\n      // The following helps with connection stability\n      sdpSemantics: 'unified-plan'\n    };\n    this.logger.log('Initializing peer connection with configuration:', configuration);\n\n    // Create the RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Add local media tracks to the connection if we have them\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Adding local track to peer connection:', track.kind);\n        this.peerConnection.addTrack(track, this.localStream);\n      });\n    }\n\n    // Set up event handlers\n    this.setupPeerConnectionEventHandlers();\n  }\n\n  /**\n   * Set up all event handlers for the peer connection\n   */\n  setupPeerConnectionEventHandlers() {\n    // Handle receiving remote media\n    this.peerConnection.ontrack = this.handleTrackEvent.bind(this);\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = this.handleIceCandidateEvent.bind(this);\n\n    // ICE gathering state\n    this.peerConnection.onicegatheringstatechange = () => {\n      this.logger.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n    };\n\n    // Signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      this.logger.log('Signaling state changed:', this.peerConnection.signalingState);\n    };\n\n    // Connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      this.logger.log('Connection state changed:', this.peerConnection.connectionState);\n    };\n\n    // ICE connection state\n    this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);\n  }\n\n  /**\n   * Handle track event (receiving remote tracks)\n   * @param {RTCTrackEvent} event - Track event\n   */\n  // Add to WebRTCConnectionManager.js\n  handleTrackEvent(event) {\n    this.logger.log('Received remote track:', event.track.kind);\n\n    // Always log received track details\n    this.logger.log(`Track details - ID: ${event.track.id}, Kind: ${event.track.kind}, Enabled: ${event.track.enabled}, ReadyState: ${event.track.readyState}`);\n\n    // Create remote stream if it doesn't exist\n    if (!this.remoteStream) {\n      this.logger.log('Creating new MediaStream for remote tracks');\n      this.remoteStream = new MediaStream();\n\n      // IMPORTANT: Always update call state to active when we get tracks\n      this.logger.log('Setting call state to active due to received tracks');\n      this.updateCallState('active');\n      if (this.callbacks.onRemoteStream) {\n        this.callbacks.onRemoteStream(this.remoteStream);\n      }\n    }\n\n    // IMPROVED: Check if track already exists in the stream before adding\n    const existingTrack = this.remoteStream.getTracks().find(t => t.id === event.track.id);\n    if (!existingTrack) {\n      // Add the track to our remote stream\n      this.remoteStream.addTrack(event.track);\n      this.logger.log(`Added new track to remote stream: ${event.track.kind}`);\n    } else {\n      this.logger.log(`Track already exists in remote stream: ${event.track.kind}`);\n    }\n\n    // Force update the call state again\n    this.logger.log('Force updating call state to active after handling tracks');\n    this.updateCallState('active');\n\n    // IMPROVED: Add delay before notification to ensure state is updated\n    setTimeout(() => {\n      // Make sure we still have a valid remote stream with tracks\n      if (this.remoteStream && this.remoteStream.getTracks().length > 0) {\n        // Notify the other peer that we've received their media\n        if (this.targetUserId && this.signalingService) {\n          this.signalingService.send('media-connected', {\n            targetUserId: this.targetUserId\n          });\n        }\n\n        // Also notify again after a longer delay as a fallback\n        setTimeout(() => {\n          if (this.targetUserId && this.signalingService) {\n            this.logger.log('Sending delayed media-connected notification');\n            this.signalingService.send('media-connected', {\n              targetUserId: this.targetUserId\n            });\n          }\n        }, 2000);\n      }\n    }, 500);\n\n    // Verify video is working by checking tracks\n    const videoTracks = this.remoteStream.getVideoTracks();\n    if (videoTracks.length > 0) {\n      this.logger.log(`Remote stream has ${videoTracks.length} video tracks`);\n      videoTracks.forEach(track => {\n        this.logger.log(`Video track: Enabled=${track.enabled}, ReadyState=${track.readyState}`);\n\n        // Ensure video track is enabled\n        if (!track.enabled) {\n          this.logger.log('Enabling disabled video track');\n          track.enabled = true;\n        }\n      });\n    } else {\n      this.logger.log('WARNING: Remote stream has no video tracks, only audio may be working');\n    }\n  }\n\n  /**\n   * Handle ICE candidate event\n   * @param {RTCPeerConnectionIceEvent} event - ICE event\n   */\n  handleIceCandidateEvent(event) {\n    if (event.candidate && this.targetUserId) {\n      // Check if targetUserId exists\n      const candidateStr = event.candidate.candidate || '';\n      const candidateType = candidateStr.split(' ')[7] || 'unknown';\n      this.logger.log('Generated ICE candidate of type:', candidateType);\n      this.signalingService.send('ice-candidate', {\n        targetUserId: this.targetUserId,\n        candidate: event.candidate\n      });\n    } else if (event.candidate) {\n      // Store candidates temporarily if connection not ready\n      if (!this.pendingCandidates) this.pendingCandidates = [];\n      this.pendingCandidates.push(event.candidate);\n      this.logger.log('Storing ICE candidate for later');\n    }\n  }\n  sendPendingCandidates() {\n    if (this.pendingCandidates && this.pendingCandidates.length > 0 && this.targetUserId) {\n      this.logger.log(`Sending ${this.pendingCandidates.length} pending ICE candidates`);\n      this.pendingCandidates.forEach(candidate => {\n        this.signalingService.send('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: candidate\n        });\n      });\n      this.pendingCandidates = [];\n    }\n  }\n\n  /**\n   * Handle ICE connection state change\n   */\n  handleIceConnectionStateChange() {\n    const state = this.peerConnection.iceConnectionState;\n    this.logger.log('ICE connection state changed to:', state);\n    const previousState = this.iceConnectionState;\n    this.iceConnectionState = state;\n    this.logger.log('ICE connection state changed to:', state, 'from:', previousState);\n\n    // Notify callbacks\n    if (this.callbacks.onICEConnectionStateChange) {\n      this.callbacks.onICEConnectionStateChange(state);\n    }\n\n    // Handle connection establishment\n    if (state === 'connected' || state === 'completed') {\n      this.handleConnectionEstablished();\n    }\n    // Handle connection failure with more aggressive behavior\n    else if (state === 'failed') {\n      this.handleConnectionFailure();\n\n      // Force end after a timeout if still in failed state\n      setTimeout(() => {\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n          this.logger.log('Connection remains failed, forcing call end');\n          this.forceEndCall();\n        }\n      }, 5000);\n    }\n    // Handle disconnection with more aggressive behavior\n    else if (state === 'disconnected') {\n      this.handleConnectionDisconnected();\n\n      // Force end after a timeout if still disconnected\n      setTimeout(() => {\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n          this.logger.log('Connection remains disconnected, forcing call end');\n          this.forceEndCall();\n        }\n      }, 8000);\n    }\n    // Clear timers if state improves\n    else if ((state === 'checking' || state === 'connected') && (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n      this.clearConnectionTimers();\n    }\n  }\n\n  /**\n   * Handle successful connection establishment\n   */\n  handleConnectionEstablished() {\n    this.logger.log('Call connected successfully!');\n    this.updateCallState('active');\n\n    // Reset reconnection attempts\n    this.reconnectionAttempts = 0;\n\n    // Clear any pending timers\n    this.clearConnectionTimers();\n\n    // Notify the other peer that media is flowing on our side\n    if (this.signalingService && this.targetUserId) {\n      this.signalingService.send('media-connected', {\n        targetUserId: this.targetUserId\n      });\n    }\n  }\n\n  /**\n   * Handle connection failure\n   */\n  handleConnectionFailure() {\n    this.logger.log('Connection failed');\n    if (!this.failureTimeout) {\n      this.failureTimeout = setTimeout(() => {\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n          // Attempt to restart ICE if possible before ending the call\n          if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n            this.reconnectionAttempts++;\n            this.logger.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n\n            // Try to reconnect using our enhanced method\n            this.attemptReconnection(true);\n          } else {\n            this.logger.log('Max reconnection attempts reached, ending call');\n            this.updateCallState('ended');\n            // This would trigger call end in the main service\n          }\n        }\n        this.failureTimeout = null;\n      }, 1000);\n    }\n  }\n\n  /**\n   * Handle temporary disconnection\n   */\n  handleConnectionDisconnected() {\n    this.logger.log('Connection temporarily disconnected');\n\n    // Clear any existing timers first\n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n    }\n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n    }\n\n    // Start with a short timer for normal recovery\n    this.disconnectionTimer = setTimeout(() => {\n      // If still disconnected after short period, try recovery\n      if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n        this.logger.log('Connection still disconnected, attempting recovery...');\n        this.attemptReconnection(false);\n      }\n      this.disconnectionTimer = null;\n    }, 2000); // Try recovery after 2 seconds\n\n    // Also set a longer timeout for full failure\n    this.disconnectionFailureTimer = setTimeout(() => {\n      if (this.peerConnection && (this.peerConnection.iceConnectionState === 'disconnected' || this.peerConnection.iceConnectionState === 'failed')) {\n        this.logger.log('Connection remained disconnected for too long');\n        this.updateCallState('ended');\n        // This would trigger call end in the main service\n      }\n      this.disconnectionFailureTimer = null;\n    }, 15000); // End call after 15 seconds of disconnection\n  }\n\n  /**\n   * Clear all connection timers\n   */\n  clearConnectionTimers() {\n    if (this.failureTimeout) {\n      clearTimeout(this.failureTimeout);\n      this.failureTimeout = null;\n    }\n    if (this.disconnectionTimer) {\n      clearTimeout(this.disconnectionTimer);\n      this.disconnectionTimer = null;\n    }\n    if (this.disconnectionFailureTimer) {\n      clearTimeout(this.disconnectionFailureTimer);\n      this.disconnectionFailureTimer = null;\n    }\n  }\n\n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    this.logger.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n    try {\n      if (!this.peerConnection) {\n        this.logger.log('No peer connection to reconnect');\n        return;\n      }\n\n      // First try to restart ICE\n      this.peerConnection.restartIce();\n\n      // For more aggressive reconnection, try recreating the offer\n      if (aggressive || this.isCallInitiator) {\n        this.logger.log('Creating new offer with ICE restart');\n        const offer = await this.peerConnection.createOffer({\n          iceRestart: true,\n          offerToReceiveAudio: true,\n          offerToReceiveVideo: true\n        });\n        await this.peerConnection.setLocalDescription(offer);\n\n        // Send the new offer to the other user\n        this.signalingService.send('call-user', {\n          targetUserId: this.targetUserId,\n          offerSDP: offer,\n          callerUserId: this.userId\n        });\n        this.logger.log('Sent new offer for reconnection');\n      }\n    } catch (error) {\n      this.logger.error('Error during reconnection attempt', error.message);\n    }\n  }\n\n  /**\n   * Close the peer connection\n   */\n  closeConnection() {\n    // Clear all timers first\n    this.clearConnectionTimers();\n\n    // Check if we have a peer connection to close\n    if (this.peerConnection) {\n      try {\n        // Close any remaining data channels\n        if (this.peerConnection.dataChannel) {\n          this.peerConnection.dataChannel.close();\n        }\n\n        // Stop all transceivers if supported\n        if (this.peerConnection.getTransceivers) {\n          const transceivers = this.peerConnection.getTransceivers();\n          transceivers.forEach(transceiver => {\n            if (transceiver.stop) {\n              try {\n                transceiver.stop();\n              } catch (e) {\n                this.logger.log('Error stopping transceiver:', e);\n              }\n            }\n          });\n        }\n\n        // Stop all tracks from remote stream\n        if (this.remoteStream) {\n          this.remoteStream.getTracks().forEach(track => {\n            this.logger.log(`Stopping remote track: ${track.kind}`);\n            track.stop();\n          });\n        }\n\n        // Cleanup listeners first to prevent any callbacks\n        this.peerConnection.onicecandidate = null;\n        this.peerConnection.ontrack = null;\n        this.peerConnection.oniceconnectionstatechange = null;\n        this.peerConnection.onicegatheringstatechange = null;\n        this.peerConnection.onsignalingstatechange = null;\n        this.peerConnection.onconnectionstatechange = null;\n\n        // Close the connection\n        this.peerConnection.close();\n        this.logger.log('Peer connection closed successfully');\n      } catch (error) {\n        this.logger.error('Error during connection close:', error.message);\n      }\n      this.peerConnection = null;\n    }\n\n    // Clear the remote stream\n    if (this.remoteStream) {\n      try {\n        const tracks = this.remoteStream.getTracks();\n        tracks.forEach(track => {\n          track.stop();\n          this.remoteStream.removeTrack(track);\n        });\n      } catch (e) {\n        this.logger.error('Error cleaning up remote stream:', e.message);\n      }\n      this.remoteStream = null;\n    }\n\n    // Notify that the connection is fully closed\n    if (this.updateCallState) {\n      this.updateCallState('ended');\n    }\n  }\n  forceEndCall() {\n    this.logger.log('Forcing call end due to potential lingering connection');\n\n    // Close peer connection\n    this.closeConnection();\n\n    // Ensure call state is updated\n    if (this.updateCallState) {\n      this.updateCallState('ended');\n    }\n  }\n\n  /**\n   * Reset the connection manager state\n   */\n  reset() {\n    this.remoteStream = null;\n    this.reconnectionAttempts = 0;\n    this.iceConnectionState = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n    this.clearConnectionTimers();\n  }\n\n  /**\n   * Clean up all resources\n   */\n  cleanup() {\n    this.closeConnection();\n    this.reset();\n  }\n}\nexport default WebRTCConnectionManager;","map":{"version":3,"names":["WebRTCConnectionManager","constructor","signalingService","mediaManager","eventEmitter","logger","updateCallState","peerConnection","remoteStream","isCallInitiator","targetUserId","pendingOffer","pendingCandidates","reconnectionAttempts","maxReconnectionAttempts","iceConnectionState","disconnectionTimer","disconnectionFailureTimer","failureTimeout","callbacks","onRemoteStream","onICEConnectionStateChange","setCallbacks","setPendingOffer","offer","setLocalStream","stream","localStream","getTracks","forEach","track","log","kind","addTrack","initiateCall","userId","createPeerConnection","createOffer","setLocalDescription","send","offerSDP","callerUserId","acceptCall","setRemoteDescription","RTCSessionDescription","answer","createAnswer","answerSDP","sendPendingCandidates","description","length","candidates","candidate","addIceCandidate","RTCIceCandidate","err","error","message","addRemoteIceCandidate","remoteDescription","type","push","configuration","iceServers","urls","username","credential","process","env","REACT_APP_TURN_SERVER","REACT_APP_TURN_USERNAME","REACT_APP_TURN_CREDENTIAL","iceCandidatePoolSize","sdpSemantics","RTCPeerConnection","setupPeerConnectionEventHandlers","ontrack","handleTrackEvent","bind","onicecandidate","handleIceCandidateEvent","onicegatheringstatechange","iceGatheringState","onsignalingstatechange","signalingState","onconnectionstatechange","connectionState","oniceconnectionstatechange","handleIceConnectionStateChange","event","id","enabled","readyState","MediaStream","existingTrack","find","t","setTimeout","videoTracks","getVideoTracks","candidateStr","candidateType","split","state","previousState","handleConnectionEstablished","handleConnectionFailure","forceEndCall","handleConnectionDisconnected","clearConnectionTimers","attemptReconnection","clearTimeout","aggressive","restartIce","iceRestart","offerToReceiveAudio","offerToReceiveVideo","closeConnection","dataChannel","close","getTransceivers","transceivers","transceiver","stop","e","tracks","removeTrack","reset","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCConnectionManager.js"],"sourcesContent":["// File: services/WebRTC/WebRTCConnectionManager.js\n/**\n * Manages WebRTC peer connection\n */\nclass WebRTCConnectionManager {\n  constructor(signalingService, mediaManager, eventEmitter, logger, updateCallState) {\n    this.signalingService = signalingService;\n    this.mediaManager = mediaManager;\n    this.eventEmitter = eventEmitter;\n    this.logger = logger;\n    this.updateCallState = updateCallState;\n    \n    // Connection\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.isCallInitiator = false;\n    this.targetUserId = null; // Add explicit tracking of target user\n    \n    // Call reconnection state\n    this.pendingOffer = null;\n    this.pendingCandidates = []; // Add storage for pending candidates\n    this.reconnectionAttempts = 0;\n    this.maxReconnectionAttempts = 3;\n    this.iceConnectionState = null;\n      \n      // Timers\n      this.disconnectionTimer = null;\n      this.disconnectionFailureTimer = null;\n      this.failureTimeout = null;\n      \n      // Callbacks\n      this.callbacks = {\n        onRemoteStream: null,\n        onICEConnectionStateChange: null\n      };\n    }\n    \n    /**\n     * Set callbacks for the connection manager\n     * @param {object} callbacks - Callback functions\n     */\n    setCallbacks(callbacks) {\n      this.callbacks = {\n        ...this.callbacks,\n        ...callbacks\n      };\n    }\n    \n    /**\n     * Set pending offer for incoming call\n     * @param {RTCSessionDescriptionInit} offer - SDP offer\n     */\n    setPendingOffer(offer) {\n      this.pendingOffer = offer;\n    }\n    \n    /**\n     * Set local stream to use for the call\n     * @param {MediaStream} stream - Local media stream\n     */\n    setLocalStream(stream) {\n      this.localStream = stream;\n      \n      // Add tracks to peer connection if it exists\n      if (this.peerConnection && stream) {\n        stream.getTracks().forEach(track => {\n          this.logger.log('Adding local track to peer connection:', track.kind);\n          this.peerConnection.addTrack(track, stream);\n        });\n      }\n    }\n    \n    /**\n     * Initialize a call to another user\n     * @param {string} userId - Current user ID\n     * @param {string} targetUserId - Target user ID\n     */\n    async initiateCall(userId, targetUserId) {\n      this.isCallInitiator = true;\n      this.targetUserId = targetUserId;\n      \n      // Create peer connection\n      this.createPeerConnection();\n      \n      // Create an offer (SDP)\n      this.logger.log('Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      \n      // Set the offer as our local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // Send the offer to the other user via signaling server\n      this.signalingService.send('call-user', {\n        targetUserId,\n        offerSDP: offer,\n        callerUserId: userId\n      });\n      \n      this.logger.log('Call offer sent');\n    }\n    \n    /**\n     * Accept an incoming call\n     * @param {string} targetUserId - ID of the caller\n     */\n    async acceptCall(targetUserId) {\n      this.targetUserId = targetUserId; // Set target ID here too\n      // Create peer connection\n      this.createPeerConnection();\n      \n      // Set the remote description from the stored offer\n      this.logger.log('Setting remote description from offer');\n      await this.peerConnection.setRemoteDescription(\n        new RTCSessionDescription(this.pendingOffer)\n      );\n      \n      // Create an answer\n      this.logger.log('Creating answer...');\n      const answer = await this.peerConnection.createAnswer();\n      \n      // Set the answer as our local description\n      await this.peerConnection.setLocalDescription(answer);\n      \n      // Send the answer to the caller\n      this.signalingService.send('call-accepted', {\n        targetUserId,\n        answerSDP: answer\n      });\n      \n      this.logger.log('Call accepted, answer sent');\n      this.sendPendingCandidates();\n    }\n    \n    /**\n     * Set remote description for the peer connection\n     * @param {RTCSessionDescriptionInit} description - Remote description\n     */\n    async setRemoteDescription(description) {\n      try {\n        if (this.peerConnection) {\n          await this.peerConnection.setRemoteDescription(\n            new RTCSessionDescription(description)\n          );\n          \n          // Apply any queued ICE candidates after remote description is set\n          this.logger.log('Remote description set, applying queued ICE candidates');\n          if (this.pendingCandidates && this.pendingCandidates.length > 0) {\n            this.logger.log(`Processing ${this.pendingCandidates.length} queued ICE candidates`);\n            \n            const candidates = [...this.pendingCandidates];\n            this.pendingCandidates = [];\n            \n            for (const candidate of candidates) {\n              try {\n                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n                this.logger.log('Added queued ICE candidate');\n              } catch (err) {\n                this.logger.error('Error adding queued ICE candidate', err.message);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        this.logger.error('Error setting remote description', error.message);\n        throw error;\n      }\n    }\n    \n    /**\n     * Add a remote ICE candidate\n     * @param {RTCIceCandidateInit} candidate - ICE candidate\n     */\n    async addRemoteIceCandidate(candidate) {\n      try {\n        // If peer connection doesn't exist yet or remote description is not set, \n        // store candidates for later\n        if (!this.peerConnection || \n            !this.peerConnection.remoteDescription || \n            !this.peerConnection.remoteDescription.type) {\n          \n          this.logger.log('Remote description not set yet, queueing ICE candidate');\n          if (!this.pendingCandidates) this.pendingCandidates = [];\n          this.pendingCandidates.push(candidate);\n          return;\n        }\n        \n        await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        this.logger.log('Added ICE candidate');\n      } catch (error) {\n        this.logger.error('Error adding ICE candidate', error.message);\n      }\n    }\n    \n    /**\n     * Create WebRTC peer connection\n     */\n    createPeerConnection() {\n      // Enhanced ICE servers configuration with multiple STUN servers and free TURN servers\n      const configuration = {\n        iceServers: [\n          { urls: 'stun:stun.l.google.com:19302' },\n          { urls: 'stun:stun1.l.google.com:19302' },\n          { urls: 'stun:stun2.l.google.com:19302' },\n          { urls: 'stun:stun3.l.google.com:19302' },\n          { urls: 'stun:stun4.l.google.com:19302' },\n          // Free TURN server (replace with your own in production)\n          {\n            urls: 'turn:openrelay.metered.ca:80',\n            username: 'openrelayproject',\n            credential: 'openrelayproject'\n          },\n          {\n            urls: 'turn:openrelay.metered.ca:443',\n            username: 'openrelayproject',\n            credential: 'openrelayproject'\n          },\n          // If environment variables exist, add them too\n          ...(process.env.REACT_APP_TURN_SERVER ? [{\n            urls: process.env.REACT_APP_TURN_SERVER,\n            username: process.env.REACT_APP_TURN_USERNAME || '',\n            credential: process.env.REACT_APP_TURN_CREDENTIAL || ''\n          }] : [])\n        ],\n        iceCandidatePoolSize: 10,\n        // The following helps with connection stability\n        sdpSemantics: 'unified-plan'\n      };\n      \n      this.logger.log('Initializing peer connection with configuration:', configuration);\n      \n      // Create the RTCPeerConnection\n      this.peerConnection = new RTCPeerConnection(configuration);\n      \n      // Add local media tracks to the connection if we have them\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.logger.log('Adding local track to peer connection:', track.kind);\n          this.peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Set up event handlers\n      this.setupPeerConnectionEventHandlers();\n    }\n    \n    /**\n     * Set up all event handlers for the peer connection\n     */\n    setupPeerConnectionEventHandlers() {\n      // Handle receiving remote media\n      this.peerConnection.ontrack = this.handleTrackEvent.bind(this);\n      \n      // Handle ICE candidates\n      this.peerConnection.onicecandidate = this.handleIceCandidateEvent.bind(this);\n      \n      // ICE gathering state\n      this.peerConnection.onicegatheringstatechange = () => {\n        this.logger.log('ICE gathering state changed:', this.peerConnection.iceGatheringState);\n      };\n      \n      // Signaling state\n      this.peerConnection.onsignalingstatechange = () => {\n        this.logger.log('Signaling state changed:', this.peerConnection.signalingState);\n      };\n      \n      // Connection state\n      this.peerConnection.onconnectionstatechange = () => {\n        this.logger.log('Connection state changed:', this.peerConnection.connectionState);\n      };\n      \n      // ICE connection state\n      this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);\n    }\n    \n    /**\n     * Handle track event (receiving remote tracks)\n     * @param {RTCTrackEvent} event - Track event\n     */\n    // Add to WebRTCConnectionManager.js\n    handleTrackEvent(event) {\n      this.logger.log('Received remote track:', event.track.kind);\n      \n      // Always log received track details\n      this.logger.log(`Track details - ID: ${event.track.id}, Kind: ${event.track.kind}, Enabled: ${event.track.enabled}, ReadyState: ${event.track.readyState}`);\n      \n      // Create remote stream if it doesn't exist\n      if (!this.remoteStream) {\n        this.logger.log('Creating new MediaStream for remote tracks');\n        this.remoteStream = new MediaStream();\n        \n        // IMPORTANT: Always update call state to active when we get tracks\n        this.logger.log('Setting call state to active due to received tracks');\n        this.updateCallState('active');\n        \n        if (this.callbacks.onRemoteStream) {\n          this.callbacks.onRemoteStream(this.remoteStream);\n        }\n      }\n      \n      // IMPROVED: Check if track already exists in the stream before adding\n      const existingTrack = this.remoteStream.getTracks().find(t => t.id === event.track.id);\n      if (!existingTrack) {\n        // Add the track to our remote stream\n        this.remoteStream.addTrack(event.track);\n        this.logger.log(`Added new track to remote stream: ${event.track.kind}`);\n      } else {\n        this.logger.log(`Track already exists in remote stream: ${event.track.kind}`);\n      }\n      \n      // Force update the call state again\n      this.logger.log('Force updating call state to active after handling tracks');\n      this.updateCallState('active');\n      \n      // IMPROVED: Add delay before notification to ensure state is updated\n      setTimeout(() => {\n        // Make sure we still have a valid remote stream with tracks\n        if (this.remoteStream && this.remoteStream.getTracks().length > 0) {\n          // Notify the other peer that we've received their media\n          if (this.targetUserId && this.signalingService) {\n            this.signalingService.send('media-connected', {\n              targetUserId: this.targetUserId\n            });\n          }\n          \n          // Also notify again after a longer delay as a fallback\n          setTimeout(() => {\n            if (this.targetUserId && this.signalingService) {\n              this.logger.log('Sending delayed media-connected notification');\n              this.signalingService.send('media-connected', {\n                targetUserId: this.targetUserId\n              });\n            }\n          }, 2000);\n        }\n      }, 500);\n      \n      // Verify video is working by checking tracks\n      const videoTracks = this.remoteStream.getVideoTracks();\n      if (videoTracks.length > 0) {\n        this.logger.log(`Remote stream has ${videoTracks.length} video tracks`);\n        videoTracks.forEach(track => {\n          this.logger.log(`Video track: Enabled=${track.enabled}, ReadyState=${track.readyState}`);\n          \n          // Ensure video track is enabled\n          if (!track.enabled) {\n            this.logger.log('Enabling disabled video track');\n            track.enabled = true;\n          }\n        });\n      } else {\n        this.logger.log('WARNING: Remote stream has no video tracks, only audio may be working');\n      }    \n    }\n    \n    /**\n     * Handle ICE candidate event\n     * @param {RTCPeerConnectionIceEvent} event - ICE event\n     */\n    handleIceCandidateEvent(event) {\n      if (event.candidate && this.targetUserId) { // Check if targetUserId exists\n        const candidateStr = event.candidate.candidate || '';\n        const candidateType = candidateStr.split(' ')[7] || 'unknown';\n        this.logger.log('Generated ICE candidate of type:', candidateType);\n        \n        this.signalingService.send('ice-candidate', {\n          targetUserId: this.targetUserId,\n          candidate: event.candidate\n        });\n      } else if (event.candidate) {\n        // Store candidates temporarily if connection not ready\n        if (!this.pendingCandidates) this.pendingCandidates = [];\n        this.pendingCandidates.push(event.candidate);\n        this.logger.log('Storing ICE candidate for later');\n      }\n    }\n\n    sendPendingCandidates() {\n      if (this.pendingCandidates && this.pendingCandidates.length > 0 && this.targetUserId) {\n        this.logger.log(`Sending ${this.pendingCandidates.length} pending ICE candidates`);\n        this.pendingCandidates.forEach(candidate => {\n          this.signalingService.send('ice-candidate', {\n            targetUserId: this.targetUserId,\n            candidate: candidate\n          });\n        });\n        this.pendingCandidates = [];\n      }\n    }\n    \n    /**\n     * Handle ICE connection state change\n     */\n    handleIceConnectionStateChange() {\n      const state = this.peerConnection.iceConnectionState;\n      this.logger.log('ICE connection state changed to:', state);\n      const previousState = this.iceConnectionState;\n      this.iceConnectionState = state;\n      \n      this.logger.log('ICE connection state changed to:', state, 'from:', previousState);\n      \n      // Notify callbacks\n      if (this.callbacks.onICEConnectionStateChange) {\n        this.callbacks.onICEConnectionStateChange(state);\n      }\n      \n      // Handle connection establishment\n      if (state === 'connected' || state === 'completed') {\n        this.handleConnectionEstablished();\n      } \n      // Handle connection failure with more aggressive behavior\n      else if (state === 'failed') {\n        this.handleConnectionFailure();\n        \n        // Force end after a timeout if still in failed state\n        setTimeout(() => {\n          if (this.peerConnection && \n              this.peerConnection.iceConnectionState === 'failed') {\n            this.logger.log('Connection remains failed, forcing call end');\n            this.forceEndCall();\n          }\n        }, 5000);\n      }\n      // Handle disconnection with more aggressive behavior\n      else if (state === 'disconnected') {\n        this.handleConnectionDisconnected();\n        \n        // Force end after a timeout if still disconnected\n        setTimeout(() => {\n          if (this.peerConnection && \n              this.peerConnection.iceConnectionState === 'disconnected') {\n            this.logger.log('Connection remains disconnected, forcing call end');\n            this.forceEndCall();\n          }\n        }, 8000);\n      }\n      // Clear timers if state improves\n      else if ((state === 'checking' || state === 'connected') && \n              (this.failureTimeout || this.disconnectionTimer || this.disconnectionFailureTimer)) {\n        this.clearConnectionTimers();\n      }\n    }\n    \n    /**\n     * Handle successful connection establishment\n     */\n    handleConnectionEstablished() {\n      this.logger.log('Call connected successfully!');\n      this.updateCallState('active');\n      \n      // Reset reconnection attempts\n      this.reconnectionAttempts = 0;\n      \n      // Clear any pending timers\n      this.clearConnectionTimers();\n      \n      // Notify the other peer that media is flowing on our side\n      if (this.signalingService && this.targetUserId) {\n        this.signalingService.send('media-connected', {\n          targetUserId: this.targetUserId\n        });\n      }\n    }\n    \n    /**\n     * Handle connection failure\n     */\n    handleConnectionFailure() {\n      this.logger.log('Connection failed');\n      \n      if (!this.failureTimeout) {\n        this.failureTimeout = setTimeout(() => {\n          if (this.peerConnection && this.peerConnection.iceConnectionState === 'failed') {\n            // Attempt to restart ICE if possible before ending the call\n            if (this.reconnectionAttempts < this.maxReconnectionAttempts) {\n              this.reconnectionAttempts++;\n              this.logger.log(`Trying to reconnect (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);\n              \n              // Try to reconnect using our enhanced method\n              this.attemptReconnection(true);\n            } else {\n              this.logger.log('Max reconnection attempts reached, ending call');\n              this.updateCallState('ended');\n              // This would trigger call end in the main service\n            }\n          }\n          this.failureTimeout = null;\n        }, 1000);\n      }\n    }\n    \n    /**\n     * Handle temporary disconnection\n     */\n    handleConnectionDisconnected() {\n      this.logger.log('Connection temporarily disconnected');\n      \n      // Clear any existing timers first\n      if (this.disconnectionTimer) {\n        clearTimeout(this.disconnectionTimer);\n      }\n      \n      if (this.disconnectionFailureTimer) {\n        clearTimeout(this.disconnectionFailureTimer);\n      }\n      \n      // Start with a short timer for normal recovery\n      this.disconnectionTimer = setTimeout(() => {\n        // If still disconnected after short period, try recovery\n        if (this.peerConnection && this.peerConnection.iceConnectionState === 'disconnected') {\n          this.logger.log('Connection still disconnected, attempting recovery...');\n          this.attemptReconnection(false);\n        }\n        this.disconnectionTimer = null;\n      }, 2000); // Try recovery after 2 seconds\n      \n      // Also set a longer timeout for full failure\n      this.disconnectionFailureTimer = setTimeout(() => {\n        if (this.peerConnection && \n            (this.peerConnection.iceConnectionState === 'disconnected' || \n             this.peerConnection.iceConnectionState === 'failed')) {\n          this.logger.log('Connection remained disconnected for too long');\n          this.updateCallState('ended');\n          // This would trigger call end in the main service\n        }\n        this.disconnectionFailureTimer = null;\n      }, 15000); // End call after 15 seconds of disconnection\n    }\n    \n    /**\n     * Clear all connection timers\n     */\n    clearConnectionTimers() {\n      if (this.failureTimeout) {\n        clearTimeout(this.failureTimeout);\n        this.failureTimeout = null;\n      }\n      \n      if (this.disconnectionTimer) {\n        clearTimeout(this.disconnectionTimer);\n        this.disconnectionTimer = null;\n      }\n      \n      if (this.disconnectionFailureTimer) {\n        clearTimeout(this.disconnectionFailureTimer);\n        this.disconnectionFailureTimer = null;\n      }\n    }\n    \n    /**\n     * Attempt to reconnect during call problems\n     * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n     */\n    async attemptReconnection(aggressive = false) {\n      this.logger.log(`Attempting ${aggressive ? 'aggressive' : 'standard'} reconnection`);\n      \n      try {\n        if (!this.peerConnection) {\n          this.logger.log('No peer connection to reconnect');\n          return;\n        }\n        \n        // First try to restart ICE\n        this.peerConnection.restartIce();\n        \n        // For more aggressive reconnection, try recreating the offer\n        if (aggressive || this.isCallInitiator) {\n          this.logger.log('Creating new offer with ICE restart');\n          const offer = await this.peerConnection.createOffer({ \n            iceRestart: true,\n            offerToReceiveAudio: true,\n            offerToReceiveVideo: true\n          });\n          \n          await this.peerConnection.setLocalDescription(offer);\n          \n          // Send the new offer to the other user\n          this.signalingService.send('call-user', {\n            targetUserId: this.targetUserId,\n            offerSDP: offer,\n            callerUserId: this.userId\n          });\n          \n          this.logger.log('Sent new offer for reconnection');\n        }\n      } catch (error) {\n        this.logger.error('Error during reconnection attempt', error.message);\n      }\n    }\n    \n    /**\n     * Close the peer connection\n     */\n    closeConnection() {\n      // Clear all timers first\n      this.clearConnectionTimers();\n      \n      // Check if we have a peer connection to close\n      if (this.peerConnection) {\n        try {\n          // Close any remaining data channels\n          if (this.peerConnection.dataChannel) {\n            this.peerConnection.dataChannel.close();\n          }\n          \n          // Stop all transceivers if supported\n          if (this.peerConnection.getTransceivers) {\n            const transceivers = this.peerConnection.getTransceivers();\n            transceivers.forEach(transceiver => {\n              if (transceiver.stop) {\n                try {\n                  transceiver.stop();\n                } catch (e) {\n                  this.logger.log('Error stopping transceiver:', e);\n                }\n              }\n            });\n          }\n          \n          // Stop all tracks from remote stream\n          if (this.remoteStream) {\n            this.remoteStream.getTracks().forEach(track => {\n              this.logger.log(`Stopping remote track: ${track.kind}`);\n              track.stop();\n            });\n          }\n          \n          // Cleanup listeners first to prevent any callbacks\n          this.peerConnection.onicecandidate = null;\n          this.peerConnection.ontrack = null;\n          this.peerConnection.oniceconnectionstatechange = null;\n          this.peerConnection.onicegatheringstatechange = null;\n          this.peerConnection.onsignalingstatechange = null;\n          this.peerConnection.onconnectionstatechange = null;\n          \n          // Close the connection\n          this.peerConnection.close();\n          this.logger.log('Peer connection closed successfully');\n        } catch (error) {\n          this.logger.error('Error during connection close:', error.message);\n        }\n        \n        this.peerConnection = null;\n      }\n      \n      // Clear the remote stream\n      if (this.remoteStream) {\n        try {\n          const tracks = this.remoteStream.getTracks();\n          tracks.forEach(track => {\n            track.stop();\n            this.remoteStream.removeTrack(track);\n          });\n        } catch (e) {\n          this.logger.error('Error cleaning up remote stream:', e.message);\n        }\n        \n        this.remoteStream = null;\n      }\n      \n      // Notify that the connection is fully closed\n      if (this.updateCallState) {\n        this.updateCallState('ended');\n      }\n    }\n    \n    forceEndCall() {\n      this.logger.log('Forcing call end due to potential lingering connection');\n      \n      // Close peer connection\n      this.closeConnection();\n      \n      // Ensure call state is updated\n      if (this.updateCallState) {\n        this.updateCallState('ended');\n      }\n    }\n\n    /**\n     * Reset the connection manager state\n     */\n    reset() {\n      this.remoteStream = null;\n      this.reconnectionAttempts = 0;\n      this.iceConnectionState = null;\n      this.pendingOffer = null;\n      this.isCallInitiator = false;\n      \n      this.clearConnectionTimers();\n    }\n    \n    /**\n     * Clean up all resources\n     */\n    cleanup() {\n      this.closeConnection();\n      this.reset();\n    }\n  }\n  \n  export default WebRTCConnectionManager;\n  \n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}