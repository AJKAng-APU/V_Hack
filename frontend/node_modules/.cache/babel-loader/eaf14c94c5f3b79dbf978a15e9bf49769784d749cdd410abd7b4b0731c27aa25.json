{"ast":null,"code":"// BiorhythmEngine.js - A production-ready biorhythm calculation system\n// This can be exported as a separate utility for use across your app\n\n/**\n * Comprehensive biorhythm calculation engine with optimized performance \n * and caching for production applications\n */\nexport class BiorhythmEngine {\n  constructor(options = {}) {\n    // Default configurations - can be overridden\n    this.config = {\n      // Peak hours for different rhythms (based on chronobiology research)\n      peakHours: {\n        physical: options.physicalPeak || 11,\n        // Peaks mid-morning\n        emotional: options.emotionalPeak || 16,\n        // Peaks afternoon\n        intellectual: options.intellectualPeak || 10,\n        // Peaks early morning\n        metabolic: options.metabolicPeak || 12 // Peaks at noon\n      },\n      // Amplitude determines the strength of the rhythm variation\n      amplitudes: {\n        physical: options.physicalAmplitude || 0.8,\n        emotional: options.emotionalAmplitude || 0.7,\n        intellectual: options.intellectualAmplitude || 0.9,\n        metabolic: options.metabolicAmplitude || 0.75\n      },\n      // Threshold settings for different activities\n      thresholds: {\n        medication: {\n          min: options.medicationMinThreshold || 0.6,\n          max: options.medicationMaxThreshold || 0.8\n        },\n        exercise: {\n          min: options.exerciseMinThreshold || 0.7,\n          max: options.exerciseMaxThreshold || 1.0\n        },\n        meals: {\n          min: options.mealsMinThreshold || 0.7,\n          max: options.mealsMaxThreshold || 1.0\n        },\n        focus: {\n          min: options.focusMinThreshold || 0.8,\n          max: options.focusMaxThreshold || 1.0\n        },\n        sleep: {\n          physical: options.sleepPhysicalThreshold || 0.4,\n          emotional: options.sleepEmotionalThreshold || 0.5\n        }\n      },\n      // Weight factors for calculating the overall score\n      weights: {\n        physical: options.physicalWeight || 0.3,\n        emotional: options.emotionalWeight || 0.2,\n        intellectual: options.intellectualWeight || 0.2,\n        metabolic: options.metabolicWeight || 0.3\n      },\n      // Personal chronotype adjustment (-12 to 12, negative = early bird, positive = night owl)\n      chronotypeAdjustment: options.chronotypeAdjustment || 0,\n      cacheResults: options.cacheResults !== undefined ? options.cacheResults : true\n    };\n\n    // Results cache to avoid redundant calculations\n    this.cache = {\n      hourlyData: null,\n      lastCalculationDate: null\n    };\n  }\n\n  /**\n   * Calculate biorhythm value for a specific rhythm at a given hour\n   * @param {number} hour - Hour of day (0-23)\n   * @param {string} rhythmType - Type of rhythm (physical, emotional, intellectual, metabolic)\n   * @returns {number} Normalized biorhythm value (0-1)\n   */\n  calculateRhythmValue(hour, rhythmType) {\n    if (!this.config.peakHours[rhythmType]) {\n      console.warn(`Unknown rhythm type: ${rhythmType}. Using physical rhythm as fallback.`);\n      rhythmType = 'physical';\n    }\n\n    // Adjust hour based on chronotype\n    const adjustedHour = (hour + this.config.chronotypeAdjustment + 24) % 24;\n\n    // Get peak hour and amplitude for this rhythm\n    const peakHour = this.config.peakHours[rhythmType];\n    const amplitude = this.config.amplitudes[rhythmType];\n\n    // Convert to radians (full cycle over 24 hours)\n    const radians = (adjustedHour - peakHour) / 24 * 2 * Math.PI;\n\n    // Cosine function gives oscillation, amplitude controls height, add offset to make positive\n    return (Math.cos(radians) * amplitude + 1) / 2;\n  }\n\n  /**\n   * Calculate full day's biorhythm data\n   * @param {Date} [date=new Date()] - Date to calculate biorhythms for\n   * @returns {Array<Object>} Hourly biorhythm data\n   */\n  calculateHourlyData(date = new Date()) {\n    // Check cache to avoid redundant calculations (only if date matches)\n    const dateString = date.toDateString();\n    if (this.config.cacheResults && this.cache.hourlyData && this.cache.lastCalculationDate === dateString) {\n      return this.cache.hourlyData;\n    }\n\n    // Generate hourly data\n    const hourlyData = [];\n    for (let i = 0; i < 24; i++) {\n      const physical = this.calculateRhythmValue(i, 'physical');\n      const emotional = this.calculateRhythmValue(i, 'emotional');\n      const intellectual = this.calculateRhythmValue(i, 'intellectual');\n      const metabolic = this.calculateRhythmValue(i, 'metabolic');\n\n      // Calculate overall score using weighted average\n      const overall = physical * this.config.weights.physical + emotional * this.config.weights.emotional + intellectual * this.config.weights.intellectual + metabolic * this.config.weights.metabolic;\n      hourlyData.push({\n        hour: i,\n        physical,\n        emotional,\n        intellectual,\n        metabolic,\n        overall\n      });\n    }\n\n    // Update cache\n    if (this.config.cacheResults) {\n      this.cache.hourlyData = hourlyData;\n      this.cache.lastCalculationDate = dateString;\n    }\n    return hourlyData;\n  }\n\n  /**\n   * Get current biorhythm scores\n   * @param {Date} [date=new Date()] - Date to calculate for\n   * @returns {Object} Current biorhythm scores (0-100)\n   */\n  getCurrentScores(date = new Date()) {\n    const hour = date.getHours();\n    const hourlyData = this.calculateHourlyData(date);\n    const currentHourData = hourlyData.find(data => data.hour === hour) || hourlyData[0];\n    return {\n      overall: parseFloat((currentHourData.overall * 100).toFixed(1)),\n      physical: parseFloat((currentHourData.physical * 100).toFixed(1)),\n      emotional: parseFloat((currentHourData.emotional * 100).toFixed(1)),\n      intellectual: parseFloat((currentHourData.intellectual * 100).toFixed(1)),\n      metabolic: parseFloat((currentHourData.metabolic * 100).toFixed(1))\n    };\n  }\n\n  /**\n   * Find optimal time windows for specific activities\n   * @param {string} activityType - Type of activity (medication, exercise, meals, focus, sleep)\n   * @param {Date} [date=new Date()] - Date to calculate for\n   * @returns {Array<number>} Hours that are optimal for the activity\n   */\n  getOptimalTimes(activityType, date = new Date()) {\n    const hourlyData = this.calculateHourlyData(date);\n    switch (activityType) {\n      case 'medication':\n        return this._getTimesBasedOnThreshold(hourlyData, 'metabolic', this.config.thresholds.medication.min, this.config.thresholds.medication.max);\n      case 'exercise':\n        return this._getTimesBasedOnThreshold(hourlyData, 'physical', this.config.thresholds.exercise.min, this.config.thresholds.exercise.max);\n      case 'meals':\n        return this._getTimesBasedOnThreshold(hourlyData, 'metabolic', this.config.thresholds.meals.min, this.config.thresholds.meals.max);\n      case 'focus':\n        return this._getTimesBasedOnThreshold(hourlyData, 'intellectual', this.config.thresholds.focus.min, this.config.thresholds.focus.max);\n      case 'sleep':\n        return hourlyData.filter(item => item.physical < this.config.thresholds.sleep.physical && item.emotional < this.config.thresholds.sleep.emotional).map(item => item.hour);\n      default:\n        console.warn(`Unknown activity type: ${activityType}`);\n        return [];\n    }\n  }\n\n  /**\n   * Get biorhythm-based recommendations\n   * @param {Date} [date=new Date()] - Date to calculate for \n   * @returns {Object} Complete set of biorhythm recommendations\n   */\n  getRecommendations(date = new Date()) {\n    return {\n      currentScore: this.getCurrentScores(date),\n      hourlyData: this.calculateHourlyData(date),\n      recommendations: {\n        medicationTiming: this.getOptimalTimes('medication', date),\n        exerciseTiming: this.getOptimalTimes('exercise', date),\n        mealTiming: this.getOptimalTimes('meals', date),\n        focusTiming: this.getOptimalTimes('focus', date),\n        sleepTiming: this.getOptimalTimes('sleep', date)\n      },\n      dominantRhythm: this._getDominantRhythm(date),\n      nextTransition: this._getNextTransition(date)\n    };\n  }\n\n  /**\n   * Find the dominant rhythm at current time\n   * @param {Date} [date=new Date()] - Date to calculate for\n   * @returns {Object} Dominant rhythm information\n   */\n  _getDominantRhythm(date = new Date()) {\n    const scores = this.getCurrentScores(date);\n    const rhythms = [{\n      type: 'physical',\n      value: scores.physical\n    }, {\n      type: 'emotional',\n      value: scores.emotional\n    }, {\n      type: 'intellectual',\n      value: scores.intellectual\n    }, {\n      type: 'metabolic',\n      value: scores.metabolic\n    }];\n    rhythms.sort((a, b) => b.value - a.value);\n    return rhythms[0];\n  }\n\n  /**\n   * Calculate when the next significant biorhythm transition will occur\n   * @param {Date} [date=new Date()] - Starting date\n   * @returns {Object} Next transition information\n   */\n  _getNextTransition(date = new Date()) {\n    const currentHour = date.getHours();\n    const currentDominant = this._getDominantRhythm(date).type;\n\n    // Check future hours for a change in dominant rhythm\n    for (let i = 1; i <= 24; i++) {\n      const futureDate = new Date(date);\n      futureDate.setHours(currentHour + i);\n      const futureDominant = this._getDominantRhythm(futureDate).type;\n      if (futureDominant !== currentDominant) {\n        return {\n          from: currentDominant,\n          to: futureDominant,\n          hoursFromNow: i,\n          time: `${(currentHour + i) % 24}:00`\n        };\n      }\n    }\n\n    // If no transition found within 24 hours\n    return null;\n  }\n\n  /**\n   * Helper to find times based on threshold values\n   * @private\n   */\n  _getTimesBasedOnThreshold(hourlyData, rhythmType, minThreshold, maxThreshold) {\n    return hourlyData.filter(item => item[rhythmType] >= minThreshold && item[rhythmType] <= maxThreshold).map(item => item.hour);\n  }\n\n  /**\n   * Update engine configuration\n   * @param {Object} newConfig - New configuration parameters\n   */\n  updateConfig(newConfig) {\n    // Deep merge the new config with existing config\n    this.config = this._deepMerge(this.config, newConfig);\n\n    // Clear cache when config changes\n    this.clearCache();\n  }\n\n  /**\n   * Clear cached calculations\n   */\n  clearCache() {\n    this.cache = {\n      hourlyData: null,\n      lastCalculationDate: null\n    };\n  }\n\n  /**\n   * Utility method for deep merging objects\n   * @private\n   */\n  _deepMerge(target, source) {\n    const output = Object.assign({}, target);\n    if (this._isObject(target) && this._isObject(source)) {\n      Object.keys(source).forEach(key => {\n        if (this._isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = this._deepMerge(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      });\n    }\n    return output;\n  }\n\n  /**\n   * Check if value is an object\n   * @private\n   */\n  _isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n  }\n}\n\n/**\n * Format time window for display\n * @param {Array<number>} hours - Array of hours\n * @returns {string} Formatted time windows\n */\nexport function formatTimeWindows(hours) {\n  if (!hours || hours.length === 0) return \"No optimal times found\";\n\n  // Sort hours\n  hours.sort((a, b) => a - b);\n\n  // Group consecutive hours\n  const windows = [];\n  let start = hours[0];\n  let end = hours[0];\n  for (let i = 1; i < hours.length; i++) {\n    if (hours[i] === end + 1) {\n      end = hours[i];\n    } else {\n      windows.push({\n        start,\n        end\n      });\n      start = hours[i];\n      end = hours[i];\n    }\n  }\n  windows.push({\n    start,\n    end\n  });\n\n  // Format windows as strings\n  return windows.map(window => {\n    if (window.start === window.end) {\n      return formatHour(window.start);\n    } else {\n      return `${formatHour(window.start)} - ${formatHour(window.end)}`;\n    }\n  }).join(\", \");\n}\n\n/**\n * Format hour for display\n * @param {number} hour - Hour (0-23)\n * @returns {string} Formatted hour (e.g. \"2 PM\")\n */\nexport function formatHour(hour) {\n  if (hour === 0) return \"12 AM\";\n  if (hour === 12) return \"12 PM\";\n  return hour < 12 ? `${hour} AM` : `${hour - 12} PM`;\n}\n\n/**\n * Generates sassy biorhythm comments based on time of day\n * @param {Date} date - Current date\n * @returns {string} Sassy comment\n */\nexport function getSassyRecommendation(date = new Date()) {\n  const hour = date.getHours();\n  if (hour >= 5 && hour < 8) {\n    return \"Morning person or still awake? Either way, your metabolism is barely online. Coffee first, decisions later.\";\n  } else if (hour >= 8 && hour < 11) {\n    return \"Your brain's finally booting up! Perfect time to solve problems before your coworkers ruin your flow.\";\n  } else if (hour >= 11 && hour < 14) {\n    return \"Physical energy peaking! Perfect for a workout, unless lunch food coma claims you first.\";\n  } else if (hour >= 14 && hour < 17) {\n    return \"Afternoon slump who? Your emotional intelligence is peaking. Time for that difficult conversation you've been avoiding.\";\n  } else if (hour >= 17 && hour < 20) {\n    return \"Metabolism slowing down. Maybe don't inhale that entire pizza? Just a biorhythmic suggestion.\";\n  } else if (hour >= 20 && hour < 23) {\n    return \"Your brain's winding down. Netflix algorithms make more sense than your decision-making right now.\";\n  } else {\n    return \"It's literally the middle of the night. Even your biorhythms are judging your life choices right now.\";\n  }\n}\n\n// Export a singleton instance with default settings for easy use\nexport const biorhythmEngine = new BiorhythmEngine();\n\n// Example usage:\n// import { biorhythmEngine, formatTimeWindows, getSassyRecommendation } from './BiorhythmEngine';\n//\n// // Get all biorhythm data\n// const bioData = biorhythmEngine.getRecommendations();\n//\n// // Customize for an early bird\n// biorhythmEngine.updateConfig({ chronotypeAdjustment: -2 });\n//\n// // Get specific recommendations\n// const medicationTimes = biorhythmEngine.getOptimalTimes('medication');\n// console.log(`Best times to take medication: ${formatTimeWindows(medicationTimes)}`);","map":{"version":3,"names":["BiorhythmEngine","constructor","options","config","peakHours","physical","physicalPeak","emotional","emotionalPeak","intellectual","intellectualPeak","metabolic","metabolicPeak","amplitudes","physicalAmplitude","emotionalAmplitude","intellectualAmplitude","metabolicAmplitude","thresholds","medication","min","medicationMinThreshold","max","medicationMaxThreshold","exercise","exerciseMinThreshold","exerciseMaxThreshold","meals","mealsMinThreshold","mealsMaxThreshold","focus","focusMinThreshold","focusMaxThreshold","sleep","sleepPhysicalThreshold","sleepEmotionalThreshold","weights","physicalWeight","emotionalWeight","intellectualWeight","metabolicWeight","chronotypeAdjustment","cacheResults","undefined","cache","hourlyData","lastCalculationDate","calculateRhythmValue","hour","rhythmType","console","warn","adjustedHour","peakHour","amplitude","radians","Math","PI","cos","calculateHourlyData","date","Date","dateString","toDateString","i","overall","push","getCurrentScores","getHours","currentHourData","find","data","parseFloat","toFixed","getOptimalTimes","activityType","_getTimesBasedOnThreshold","filter","item","map","getRecommendations","currentScore","recommendations","medicationTiming","exerciseTiming","mealTiming","focusTiming","sleepTiming","dominantRhythm","_getDominantRhythm","nextTransition","_getNextTransition","scores","rhythms","type","value","sort","a","b","currentHour","currentDominant","futureDate","setHours","futureDominant","from","to","hoursFromNow","time","minThreshold","maxThreshold","updateConfig","newConfig","_deepMerge","clearCache","target","source","output","Object","assign","_isObject","keys","forEach","key","Array","isArray","formatTimeWindows","hours","length","windows","start","end","window","formatHour","join","getSassyRecommendation","biorhythmEngine"],"sources":["/Users/ang/V_Hack_Ver4/frontend2/src/components/services/BiorhythmEngine.js"],"sourcesContent":["// BiorhythmEngine.js - A production-ready biorhythm calculation system\n// This can be exported as a separate utility for use across your app\n\n/**\n * Comprehensive biorhythm calculation engine with optimized performance \n * and caching for production applications\n */\nexport class BiorhythmEngine {\n    constructor(options = {}) {\n      // Default configurations - can be overridden\n      this.config = {\n        // Peak hours for different rhythms (based on chronobiology research)\n        peakHours: {\n          physical: options.physicalPeak || 11, // Peaks mid-morning\n          emotional: options.emotionalPeak || 16, // Peaks afternoon\n          intellectual: options.intellectualPeak || 10, // Peaks early morning\n          metabolic: options.metabolicPeak || 12, // Peaks at noon\n        },\n        // Amplitude determines the strength of the rhythm variation\n        amplitudes: {\n          physical: options.physicalAmplitude || 0.8,\n          emotional: options.emotionalAmplitude || 0.7,\n          intellectual: options.intellectualAmplitude || 0.9,\n          metabolic: options.metabolicAmplitude || 0.75,\n        },\n        // Threshold settings for different activities\n        thresholds: {\n          medication: { min: options.medicationMinThreshold || 0.6, max: options.medicationMaxThreshold || 0.8 },\n          exercise: { min: options.exerciseMinThreshold || 0.7, max: options.exerciseMaxThreshold || 1.0 },\n          meals: { min: options.mealsMinThreshold || 0.7, max: options.mealsMaxThreshold || 1.0 },\n          focus: { min: options.focusMinThreshold || 0.8, max: options.focusMaxThreshold || 1.0 },\n          sleep: { physical: options.sleepPhysicalThreshold || 0.4, emotional: options.sleepEmotionalThreshold || 0.5 }\n        },\n        // Weight factors for calculating the overall score\n        weights: {\n          physical: options.physicalWeight || 0.3,\n          emotional: options.emotionalWeight || 0.2, \n          intellectual: options.intellectualWeight || 0.2,\n          metabolic: options.metabolicWeight || 0.3\n        },\n        // Personal chronotype adjustment (-12 to 12, negative = early bird, positive = night owl)\n        chronotypeAdjustment: options.chronotypeAdjustment || 0,\n        cacheResults: options.cacheResults !== undefined ? options.cacheResults : true\n      };\n      \n      // Results cache to avoid redundant calculations\n      this.cache = {\n        hourlyData: null,\n        lastCalculationDate: null\n      };\n    }\n    \n    /**\n     * Calculate biorhythm value for a specific rhythm at a given hour\n     * @param {number} hour - Hour of day (0-23)\n     * @param {string} rhythmType - Type of rhythm (physical, emotional, intellectual, metabolic)\n     * @returns {number} Normalized biorhythm value (0-1)\n     */\n    calculateRhythmValue(hour, rhythmType) {\n      if (!this.config.peakHours[rhythmType]) {\n        console.warn(`Unknown rhythm type: ${rhythmType}. Using physical rhythm as fallback.`);\n        rhythmType = 'physical';\n      }\n      \n      // Adjust hour based on chronotype\n      const adjustedHour = (hour + this.config.chronotypeAdjustment + 24) % 24;\n      \n      // Get peak hour and amplitude for this rhythm\n      const peakHour = this.config.peakHours[rhythmType];\n      const amplitude = this.config.amplitudes[rhythmType];\n      \n      // Convert to radians (full cycle over 24 hours)\n      const radians = ((adjustedHour - peakHour) / 24) * 2 * Math.PI;\n      \n      // Cosine function gives oscillation, amplitude controls height, add offset to make positive\n      return ((Math.cos(radians) * amplitude) + 1) / 2;\n    }\n    \n    /**\n     * Calculate full day's biorhythm data\n     * @param {Date} [date=new Date()] - Date to calculate biorhythms for\n     * @returns {Array<Object>} Hourly biorhythm data\n     */\n    calculateHourlyData(date = new Date()) {\n      // Check cache to avoid redundant calculations (only if date matches)\n      const dateString = date.toDateString();\n      if (this.config.cacheResults && \n          this.cache.hourlyData && \n          this.cache.lastCalculationDate === dateString) {\n        return this.cache.hourlyData;\n      }\n      \n      // Generate hourly data\n      const hourlyData = [];\n      for (let i = 0; i < 24; i++) {\n        const physical = this.calculateRhythmValue(i, 'physical');\n        const emotional = this.calculateRhythmValue(i, 'emotional');\n        const intellectual = this.calculateRhythmValue(i, 'intellectual');\n        const metabolic = this.calculateRhythmValue(i, 'metabolic');\n        \n        // Calculate overall score using weighted average\n        const overall = (\n          physical * this.config.weights.physical +\n          emotional * this.config.weights.emotional +\n          intellectual * this.config.weights.intellectual +\n          metabolic * this.config.weights.metabolic\n        );\n        \n        hourlyData.push({\n          hour: i,\n          physical,\n          emotional, \n          intellectual,\n          metabolic,\n          overall\n        });\n      }\n      \n      // Update cache\n      if (this.config.cacheResults) {\n        this.cache.hourlyData = hourlyData;\n        this.cache.lastCalculationDate = dateString;\n      }\n      \n      return hourlyData;\n    }\n    \n    /**\n     * Get current biorhythm scores\n     * @param {Date} [date=new Date()] - Date to calculate for\n     * @returns {Object} Current biorhythm scores (0-100)\n     */\n    getCurrentScores(date = new Date()) {\n      const hour = date.getHours();\n      const hourlyData = this.calculateHourlyData(date);\n      const currentHourData = hourlyData.find(data => data.hour === hour) || hourlyData[0];\n      \n      return {\n        overall: parseFloat((currentHourData.overall * 100).toFixed(1)),\n        physical: parseFloat((currentHourData.physical * 100).toFixed(1)),\n        emotional: parseFloat((currentHourData.emotional * 100).toFixed(1)),\n        intellectual: parseFloat((currentHourData.intellectual * 100).toFixed(1)),\n        metabolic: parseFloat((currentHourData.metabolic * 100).toFixed(1))\n      };\n    }\n    \n    /**\n     * Find optimal time windows for specific activities\n     * @param {string} activityType - Type of activity (medication, exercise, meals, focus, sleep)\n     * @param {Date} [date=new Date()] - Date to calculate for\n     * @returns {Array<number>} Hours that are optimal for the activity\n     */\n    getOptimalTimes(activityType, date = new Date()) {\n      const hourlyData = this.calculateHourlyData(date);\n      \n      switch(activityType) {\n        case 'medication':\n          return this._getTimesBasedOnThreshold(\n            hourlyData, \n            'metabolic', \n            this.config.thresholds.medication.min, \n            this.config.thresholds.medication.max\n          );\n          \n        case 'exercise':\n          return this._getTimesBasedOnThreshold(\n            hourlyData, \n            'physical', \n            this.config.thresholds.exercise.min, \n            this.config.thresholds.exercise.max\n          );\n          \n        case 'meals':\n          return this._getTimesBasedOnThreshold(\n            hourlyData, \n            'metabolic', \n            this.config.thresholds.meals.min, \n            this.config.thresholds.meals.max\n          );\n          \n        case 'focus':\n          return this._getTimesBasedOnThreshold(\n            hourlyData, \n            'intellectual', \n            this.config.thresholds.focus.min, \n            this.config.thresholds.focus.max\n          );\n          \n        case 'sleep':\n          return hourlyData\n            .filter(item => \n              item.physical < this.config.thresholds.sleep.physical && \n              item.emotional < this.config.thresholds.sleep.emotional\n            )\n            .map(item => item.hour);\n            \n        default:\n          console.warn(`Unknown activity type: ${activityType}`);\n          return [];\n      }\n    }\n    \n    /**\n     * Get biorhythm-based recommendations\n     * @param {Date} [date=new Date()] - Date to calculate for \n     * @returns {Object} Complete set of biorhythm recommendations\n     */\n    getRecommendations(date = new Date()) {\n      return {\n        currentScore: this.getCurrentScores(date),\n        hourlyData: this.calculateHourlyData(date),\n        recommendations: {\n          medicationTiming: this.getOptimalTimes('medication', date),\n          exerciseTiming: this.getOptimalTimes('exercise', date),\n          mealTiming: this.getOptimalTimes('meals', date),\n          focusTiming: this.getOptimalTimes('focus', date),\n          sleepTiming: this.getOptimalTimes('sleep', date)\n        },\n        dominantRhythm: this._getDominantRhythm(date),\n        nextTransition: this._getNextTransition(date)\n      };\n    }\n    \n    /**\n     * Find the dominant rhythm at current time\n     * @param {Date} [date=new Date()] - Date to calculate for\n     * @returns {Object} Dominant rhythm information\n     */\n    _getDominantRhythm(date = new Date()) {\n      const scores = this.getCurrentScores(date);\n      const rhythms = [\n        { type: 'physical', value: scores.physical },\n        { type: 'emotional', value: scores.emotional },\n        { type: 'intellectual', value: scores.intellectual },\n        { type: 'metabolic', value: scores.metabolic }\n      ];\n      \n      rhythms.sort((a, b) => b.value - a.value);\n      return rhythms[0];\n    }\n    \n    /**\n     * Calculate when the next significant biorhythm transition will occur\n     * @param {Date} [date=new Date()] - Starting date\n     * @returns {Object} Next transition information\n     */\n    _getNextTransition(date = new Date()) {\n      const currentHour = date.getHours();\n      const currentDominant = this._getDominantRhythm(date).type;\n      \n      // Check future hours for a change in dominant rhythm\n      for (let i = 1; i <= 24; i++) {\n        const futureDate = new Date(date);\n        futureDate.setHours(currentHour + i);\n        \n        const futureDominant = this._getDominantRhythm(futureDate).type;\n        if (futureDominant !== currentDominant) {\n          return {\n            from: currentDominant,\n            to: futureDominant,\n            hoursFromNow: i,\n            time: `${(currentHour + i) % 24}:00`\n          };\n        }\n      }\n      \n      // If no transition found within 24 hours\n      return null;\n    }\n    \n    /**\n     * Helper to find times based on threshold values\n     * @private\n     */\n    _getTimesBasedOnThreshold(hourlyData, rhythmType, minThreshold, maxThreshold) {\n      return hourlyData\n        .filter(item => item[rhythmType] >= minThreshold && item[rhythmType] <= maxThreshold)\n        .map(item => item.hour);\n    }\n    \n    /**\n     * Update engine configuration\n     * @param {Object} newConfig - New configuration parameters\n     */\n    updateConfig(newConfig) {\n      // Deep merge the new config with existing config\n      this.config = this._deepMerge(this.config, newConfig);\n      \n      // Clear cache when config changes\n      this.clearCache();\n    }\n    \n    /**\n     * Clear cached calculations\n     */\n    clearCache() {\n      this.cache = {\n        hourlyData: null,\n        lastCalculationDate: null\n      };\n    }\n    \n    /**\n     * Utility method for deep merging objects\n     * @private\n     */\n    _deepMerge(target, source) {\n      const output = Object.assign({}, target);\n      \n      if (this._isObject(target) && this._isObject(source)) {\n        Object.keys(source).forEach(key => {\n          if (this._isObject(source[key])) {\n            if (!(key in target)) {\n              Object.assign(output, { [key]: source[key] });\n            } else {\n              output[key] = this._deepMerge(target[key], source[key]);\n            }\n          } else {\n            Object.assign(output, { [key]: source[key] });\n          }\n        });\n      }\n      \n      return output;\n    }\n    \n    /**\n     * Check if value is an object\n     * @private\n     */\n    _isObject(item) {\n      return (item && typeof item === 'object' && !Array.isArray(item));\n    }\n  }\n  \n  /**\n   * Format time window for display\n   * @param {Array<number>} hours - Array of hours\n   * @returns {string} Formatted time windows\n   */\n  export function formatTimeWindows(hours) {\n    if (!hours || hours.length === 0) return \"No optimal times found\";\n    \n    // Sort hours\n    hours.sort((a, b) => a - b);\n    \n    // Group consecutive hours\n    const windows = [];\n    let start = hours[0];\n    let end = hours[0];\n    \n    for (let i = 1; i < hours.length; i++) {\n      if (hours[i] === end + 1) {\n        end = hours[i];\n      } else {\n        windows.push({ start, end });\n        start = hours[i];\n        end = hours[i];\n      }\n    }\n    windows.push({ start, end });\n    \n    // Format windows as strings\n    return windows.map(window => {\n      if (window.start === window.end) {\n        return formatHour(window.start);\n      } else {\n        return `${formatHour(window.start)} - ${formatHour(window.end)}`;\n      }\n    }).join(\", \");\n  }\n  \n  /**\n   * Format hour for display\n   * @param {number} hour - Hour (0-23)\n   * @returns {string} Formatted hour (e.g. \"2 PM\")\n   */\n  export function formatHour(hour) {\n    if (hour === 0) return \"12 AM\";\n    if (hour === 12) return \"12 PM\";\n    return hour < 12 ? `${hour} AM` : `${hour - 12} PM`;\n  }\n  \n  /**\n   * Generates sassy biorhythm comments based on time of day\n   * @param {Date} date - Current date\n   * @returns {string} Sassy comment\n   */\n  export function getSassyRecommendation(date = new Date()) {\n    const hour = date.getHours();\n    \n    if (hour >= 5 && hour < 8) {\n      return \"Morning person or still awake? Either way, your metabolism is barely online. Coffee first, decisions later.\";\n    } else if (hour >= 8 && hour < 11) {\n      return \"Your brain's finally booting up! Perfect time to solve problems before your coworkers ruin your flow.\";\n    } else if (hour >= 11 && hour < 14) {\n      return \"Physical energy peaking! Perfect for a workout, unless lunch food coma claims you first.\";\n    } else if (hour >= 14 && hour < 17) {\n      return \"Afternoon slump who? Your emotional intelligence is peaking. Time for that difficult conversation you've been avoiding.\";\n    } else if (hour >= 17 && hour < 20) {\n      return \"Metabolism slowing down. Maybe don't inhale that entire pizza? Just a biorhythmic suggestion.\";\n    } else if (hour >= 20 && hour < 23) {\n      return \"Your brain's winding down. Netflix algorithms make more sense than your decision-making right now.\";\n    } else {\n      return \"It's literally the middle of the night. Even your biorhythms are judging your life choices right now.\";\n    }\n  }\n  \n  // Export a singleton instance with default settings for easy use\n  export const biorhythmEngine = new BiorhythmEngine();\n  \n  // Example usage:\n  // import { biorhythmEngine, formatTimeWindows, getSassyRecommendation } from './BiorhythmEngine';\n  //\n  // // Get all biorhythm data\n  // const bioData = biorhythmEngine.getRecommendations();\n  //\n  // // Customize for an early bird\n  // biorhythmEngine.updateConfig({ chronotypeAdjustment: -2 });\n  //\n  // // Get specific recommendations\n  // const medicationTimes = biorhythmEngine.getOptimalTimes('medication');\n  // console.log(`Best times to take medication: ${formatTimeWindows(medicationTimes)}`);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}