{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectScreen = ({\n  colors,\n  setActiveScreen\n}) => {\n  _s();\n  const {\n    isDarkMode\n  } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n\n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(localStorage.getItem('is_doctor') === 'true');\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n\n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n\n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n\n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Sample doctors data\n  const doctors = [{\n    id: 1,\n    name: \"Dr. Johnson\",\n    specialty: \"Cardiologist\",\n    image: \"/User_1.png\",\n    availability: \"Available now\",\n    rating: 5\n  }, {\n    id: 2,\n    name: \"Dr. Smith\",\n    specialty: \"Primary Care\",\n    image: \"/User_2.jpg\",\n    availability: \"Available in 15m\",\n    rating: 4\n  }, {\n    id: 3,\n    name: \"Dr. Garcia\",\n    specialty: \"Endocrinologist\",\n    image: \"/User_3.png\",\n    availability: \"Available tomorrow\",\n    rating: 5\n  }, {\n    id: 4,\n    name: \"Dr. Chen\",\n    specialty: \"Neurologist\",\n    image: \"/User_4.png\",\n    availability: \"Available in 2h\",\n    rating: 4\n  }];\n\n  // ENHANCED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    if (isDoctorMode && webRTCService.socket && webRTCService.socket.connected) {\n      const doctorId = 1;\n      const doctorExists = doctors.find(doc => doc.id === doctorId);\n      if (doctorExists) {\n        webRTCService.socket.emit('register', `doctor-${doctorId}`);\n        console.log(`Registered as doctor-${doctorId} via toggle`);\n      } else {\n        console.error(`Doctor with ID ${doctorId} not found in doctors array`);\n      }\n    }\n  }, [isDoctorMode, doctors]);\n\n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n\n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    const callbacks = {\n      onIncomingCall: callerId => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      onUserNotOnline: userId => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        setConnectingDoctor(null);\n      }\n    };\n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        if (webRTCService.socket && webRTCService.socket.connected) {\n          const doctorId = 1;\n          webRTCService.socket.emit('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n    const registerInterval = setInterval(() => {\n      if (webRTCService.socket && webRTCService.socket.connected && !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.socket.emit('register', currentUserId);\n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.socket.emit('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', error => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    if (webRTCService.socket) {\n      webRTCService.socket.on('incoming-call', ({\n        callerUserId\n      }) => {\n        console.log('DIRECT SOCKET: Incoming call detected from:', callerUserId);\n      });\n    }\n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      clearInterval(registerInterval);\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {/* handle error */}\n      }\n      setIncomingCallInfo(null);\n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      webRTCService.disconnect();\n    };\n  }, []);\n\n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: doctor => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n\n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      cleanupPreviousCall();\n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          audio.addEventListener('error', e => {\n            console.error('Ringtone error:', e);\n          });\n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      playRingtone();\n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      setAutoAcceptTimer(timer);\n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    acceptIncomingCall: doctor => {\n      console.log('Accepting incoming call from:', doctor === null || doctor === void 0 ? void 0 : doctor.name);\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      setIncomingCallInfo(null);\n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      webRTCService.declineCall();\n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      displayToast('Call rejected');\n    },\n    checkDoctorOnline: async doctorId => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    initiateCall: async doctor => {\n      if (!webRTCService || !doctor) return;\n      try {\n        if (webRTCService.callState === 'connecting' || webRTCService.callState === 'active') {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n        await webRTCService.getLocalMedia();\n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n    handleConnectDoctor: async doctor => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  const {\n    displayIncomingCallAlert,\n    acceptIncomingCall,\n    rejectIncomingCall,\n    initiateCall,\n    handleConnectDoctor\n  } = callHandlers;\n\n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n\n  // Handle search filtering\n  const handleSearch = query => {\n    setSearchQuery(query);\n  };\n\n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery ? doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()) : true;\n    const matchesAvailability = filterActive ? doctor.availability.includes('Available') && !doctor.availability.includes('in') : true;\n    return matchesSearch && matchesAvailability;\n  });\n\n  // Improved toast display function\n  const displayToast = message => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n\n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n\n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-6 pb-24 dark-mode-transition\",\n    style: {\n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)` : 'none'\n    },\n    children: [/*#__PURE__*/_jsxDEV(ConnectHeader, {\n      headerVisible: headerVisible,\n      notifications: notifications,\n      setNotifications: setNotifications,\n      colors: colors,\n      isDoctorMode: isDoctorMode,\n      setIsDoctorMode: setIsDoctorMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 507,\n      columnNumber: 7\n    }, this), incomingCallCounter > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 p-2 bg-red-100 rounded-md text-xs\",\n      children: [\"Incoming call events received: \", incomingCallCounter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 517,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(SearchBar, {\n      headerVisible: headerVisible,\n      searchFocused: searchFocused,\n      setSearchFocused: setSearchFocused,\n      searchQuery: searchQuery,\n      setSearchQuery: setSearchQuery,\n      handleSearch: handleSearch,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 522,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FilterChips, {\n      headerVisible: headerVisible,\n      filterActive: filterActive,\n      setFilterActive: setFilterActive,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 533,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DoctorsTeam, {\n      headerVisible: headerVisible,\n      doctors: filteredDoctors,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      handleConnectDoctor: handleConnectDoctor,\n      setSelectedDoctor: setSelectedDoctor,\n      setSchedulingDoctor: setSchedulingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 541,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(QuickConnectActions, {\n      headerVisible: headerVisible,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      initiateCall: initiateCall,\n      displayToast: displayToast,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 553,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RecentMessages, {\n      headerVisible: headerVisible,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 563,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MessageDialog, {\n      isOpen: showMessageDialog,\n      onClose: () => {\n        setShowMessageDialog(false);\n        setSchedulingDoctor(null);\n      },\n      colors: colors,\n      recipient: schedulingDoctor || connectingDoctor,\n      doctors: doctors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 569,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoCallScreen, {\n      isOpen: showVideoCall,\n      onClose: () => setShowVideoCall(false),\n      colors: colors,\n      doctor: connectingDoctor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 581,\n      columnNumber: 7\n    }, this), incomingCallInfo && /*#__PURE__*/_jsxDEV(IncomingCallUI, {\n      incomingCallInfo: incomingCallInfo,\n      colors: colors,\n      acceptIncomingCall: acceptIncomingCall,\n      rejectIncomingCall: rejectIncomingCall\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 590,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ToastNotification, {\n      activeToast: activeToast,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 599,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 605,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 500,\n    columnNumber: 5\n  }, this);\n};\n_s(ConnectScreen, \"kyZTdQukLxV/Hiq0PzZgaXBQPg0=\", false, function () {\n  return [useTheme];\n});\n_c = ConnectScreen;\nexport default ConnectScreen;\nvar _c;\n$RefreshReg$(_c, \"ConnectScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","MessageDialog","VideoCallScreen","ConnectHeader","SearchBar","FilterChips","DoctorsTeam","QuickConnectActions","RecentMessages","IncomingCallUI","ToastNotification","jsxDEV","_jsxDEV","ConnectScreen","colors","setActiveScreen","_s","isDarkMode","searchFocused","setSearchFocused","searchQuery","setSearchQuery","notifications","setNotifications","filterActive","setFilterActive","showMessageDialog","setShowMessageDialog","showVideoCall","setShowVideoCall","selectedDoctor","setSelectedDoctor","connectingDoctor","setConnectingDoctor","schedulingDoctor","setSchedulingDoctor","readyToConnect","setReadyToConnect","isDoctorMode","setIsDoctorMode","localStorage","getItem","toastQueue","setToastQueue","activeToast","setActiveToast","incomingCallInfo","setIncomingCallInfo","ringtoneAudio","setRingtoneAudio","autoAcceptTimer","setAutoAcceptTimer","incomingCallCounter","setIncomingCallCounter","prevShowVideoCall","doctors","id","name","specialty","image","availability","rating","setItem","socket","connected","doctorId","doctorExists","find","doc","emit","console","log","error","generateUniqueId","storedId","newId","Math","random","toString","substring","currentUserId","callbacks","onIncomingCall","callerId","prev","callingDoctor","parseInt","replace","setTimeout","displayIncomingCallAlert","onUserNotOnline","userId","doctor","displayToast","serverUrl","process","env","REACT_APP_SIGNALING_SERVER","initialize","registerInterval","setInterval","isCallActive","unsubscribeError","on","message","fatal","callerUserId","clearInterval","clearTimeout","pause","currentTime","e","disconnect","callHandlers","cleanupPreviousCall","callNotificationId","Date","now","timestamp","playRingtone","audio","Audio","loop","volume","addEventListener","playPromise","play","undefined","then","catch","timer","acceptIncomingCall","acceptCall","rejectIncomingCall","declineCall","checkDoctorOnline","attempt","isOnline","checkUserOnline","Promise","resolve","initiateCall","callState","getLocalMedia","makeCall","handleConnectDoctor","current","handleSearch","query","filteredDoctors","filter","matchesSearch","toLowerCase","includes","matchesAvailability","length","slice","headerVisible","setHeaderVisible","className","style","backgroundColor","background","backgroundImage","primary","accent","children","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","onClose","recipient","jsx","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext'; \nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\n\nconst ConnectScreen = ({ colors, setActiveScreen }) => {\n  const { isDarkMode } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n  \n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(\n    localStorage.getItem('is_doctor') === 'true'\n  );\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n  \n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  \n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n  \n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n  \n  // Sample doctors data\n  const doctors = [\n    {\n      id: 1,\n      name: \"Dr. Johnson\",\n      specialty: \"Cardiologist\",\n      image: \"/User_1.png\",\n      availability: \"Available now\",\n      rating: 5\n    },\n    {\n      id: 2,\n      name: \"Dr. Smith\",\n      specialty: \"Primary Care\",\n      image: \"/User_2.jpg\",\n      availability: \"Available in 15m\",\n      rating: 4\n    },\n    {\n      id: 3,\n      name: \"Dr. Garcia\",\n      specialty: \"Endocrinologist\",\n      image: \"/User_3.png\",\n      availability: \"Available tomorrow\",\n      rating: 5\n    },\n    {\n      id: 4,\n      name: \"Dr. Chen\",\n      specialty: \"Neurologist\",\n      image: \"/User_4.png\",\n      availability: \"Available in 2h\",\n      rating: 4\n    },\n  ];\n\n  // ENHANCED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    \n    if (isDoctorMode && webRTCService.socket && webRTCService.socket.connected) {\n      const doctorId = 1;\n      \n      const doctorExists = doctors.find(doc => doc.id === doctorId);\n      \n      if (doctorExists) {\n        webRTCService.socket.emit('register', `doctor-${doctorId}`);\n        console.log(`Registered as doctor-${doctorId} via toggle`);\n      } else {\n        console.error(`Doctor with ID ${doctorId} not found in doctors array`);\n      }\n    }\n  }, [isDoctorMode, doctors]);\n  \n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n  \n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      \n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    \n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    \n    const callbacks = {\n      onIncomingCall: (callerId) => {\n        console.log('Incoming call received from:', callerId);\n        \n        setIncomingCallCounter(prev => prev + 1);\n        \n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        \n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        \n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      \n      onUserNotOnline: (userId) => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        \n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        \n        setConnectingDoctor(null);\n      }\n    };\n    \n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    \n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        if (webRTCService.socket && webRTCService.socket.connected) {\n          const doctorId = 1;\n          webRTCService.socket.emit('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    \n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    const registerInterval = setInterval(() => {\n      if (webRTCService.socket && webRTCService.socket.connected && \n          !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.socket.emit('register', currentUserId);\n        \n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.socket.emit('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    \n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', (error) => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        \n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    \n    if (webRTCService.socket) {\n      webRTCService.socket.on('incoming-call', ({ callerUserId }) => {\n        console.log('DIRECT SOCKET: Incoming call detected from:', callerUserId);\n      });\n    }\n    \n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      \n      clearInterval(registerInterval);\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) { /* handle error */ }\n      }\n      \n      setIncomingCallInfo(null);\n      \n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      \n      webRTCService.disconnect();\n    };\n  }, []);\n  \n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n      \n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        \n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        \n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      \n      cleanupPreviousCall();\n      \n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      \n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          \n          audio.addEventListener('error', (e) => {\n            console.error('Ringtone error:', e);\n          });\n          \n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      \n      playRingtone();\n      \n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      \n      setAutoAcceptTimer(timer);\n      \n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    \n    acceptIncomingCall: (doctor) => {\n      console.log('Accepting incoming call from:', doctor?.name);\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      setIncomingCallInfo(null);\n      \n      webRTCService.acceptCall();\n      \n      setShowVideoCall(true);\n      \n      displayToast(`Connected with ${doctor.name}`);\n    },\n    \n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {\n          console.error('Error stopping ringtone:', e);\n        }\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      webRTCService.declineCall();\n      \n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      \n      displayToast('Call rejected');\n    },\n    \n    checkDoctorOnline: async (doctorId) => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    \n    initiateCall: async (doctor) => {\n      if (!webRTCService || !doctor) return;\n  \n      try {\n        if (webRTCService.callState === 'connecting' || webRTCService.callState === 'active') {\n          console.log('Call already active or connecting, not initiating a new one');\n          \n          setShowVideoCall(true);\n          return;\n        }\n        \n        await webRTCService.getLocalMedia();\n        \n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        \n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n      \n    handleConnectDoctor: async (doctor) => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      \n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        \n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        \n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        \n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  \n  const { displayIncomingCallAlert, acceptIncomingCall, rejectIncomingCall, initiateCall, handleConnectDoctor } = callHandlers;\n  \n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    \n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n  \n  // Handle search filtering\n  const handleSearch = (query) => {\n    setSearchQuery(query);\n  };\n  \n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery \n      ? (doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || \n         doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()))\n      : true;\n      \n    const matchesAvailability = filterActive \n      ? doctor.availability.includes('Available') && !doctor.availability.includes('in')\n      : true;\n      \n    return matchesSearch && matchesAvailability;\n  });\n  \n  // Improved toast display function\n  const displayToast = (message) => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n  \n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      \n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n  \n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div className=\"p-6 pb-24 dark-mode-transition\" style={{ \n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode \n        ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)`\n        : 'none'\n    }}>\n      <ConnectHeader \n        headerVisible={headerVisible}\n        notifications={notifications}\n        setNotifications={setNotifications}\n        colors={colors}\n        isDoctorMode={isDoctorMode}\n        setIsDoctorMode={setIsDoctorMode}\n      />\n      \n      {incomingCallCounter > 0 && (\n        <div className=\"mb-2 p-2 bg-red-100 rounded-md text-xs\">\n          Incoming call events received: {incomingCallCounter}\n        </div>\n      )}\n      \n      <SearchBar \n        headerVisible={headerVisible}\n        searchFocused={searchFocused}\n        setSearchFocused={setSearchFocused}\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n        handleSearch={handleSearch}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <FilterChips \n        headerVisible={headerVisible}\n        filterActive={filterActive}\n        setFilterActive={setFilterActive}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <DoctorsTeam \n        headerVisible={headerVisible}\n        doctors={filteredDoctors}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        handleConnectDoctor={handleConnectDoctor}\n        setSelectedDoctor={setSelectedDoctor}\n        setSchedulingDoctor={setSchedulingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        isDarkMode={isDarkMode}\n      />\n      \n      <QuickConnectActions \n        headerVisible={headerVisible}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        initiateCall={initiateCall}\n        displayToast={displayToast}\n        isDarkMode={isDarkMode}\n      />\n      \n      <RecentMessages \n        headerVisible={headerVisible}\n        colors={colors}\n      />\n      \n      {/* Message Dialog */}\n      <MessageDialog \n        isOpen={showMessageDialog}\n        onClose={() => {\n          setShowMessageDialog(false);\n          setSchedulingDoctor(null);\n        }}\n        colors={colors}\n        recipient={schedulingDoctor || connectingDoctor}\n        doctors={doctors}\n      />\n      \n      {/* Video Call Screen */}\n      <VideoCallScreen \n        isOpen={showVideoCall}\n        onClose={() => setShowVideoCall(false)}\n        colors={colors}\n        doctor={connectingDoctor}\n      />\n      \n      {/* Incoming Call UI */}\n      {incomingCallInfo && (\n        <IncomingCallUI \n          incomingCallInfo={incomingCallInfo}\n          colors={colors}\n          acceptIncomingCall={acceptIncomingCall}\n          rejectIncomingCall={rejectIncomingCall}\n        />\n      )}\n      \n      {/* Toast Notification */}\n      <ToastNotification \n        activeToast={activeToast}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <style jsx>{`\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ConnectScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}