{"ast":null,"code":"// services/GlobalCallService.js\nimport { create } from 'zustand';\nimport supabase from '../supabaseClient';\nimport webRTCService from './WebRTCService';\n\n/**\n * Global state store for managing doctor calls from anywhere in the app\n * Uses Zustand for state management\n */\nconst useGlobalCallStore = create((set, get) => ({\n  // Call states\n  activeCall: null,\n  showCallUI: false,\n  incomingCall: null,\n  callState: 'idle',\n  // 'idle', 'connecting', 'active', 'ended'\n  ringtoneAudio: null,\n  // Doctor states\n  availableDoctors: [],\n  selectedDoctor: null,\n  loadingDoctors: false,\n  /**\n   * Load available doctors from Supabase\n   */\n  loadAvailableDoctors: async () => {\n    try {\n      set({\n        loadingDoctors: true\n      });\n      const {\n        data,\n        error\n      } = await supabase.from('doctors').select('*').eq('availability', true);\n      if (error) throw error;\n\n      // Format doctor data for our app\n      const doctors = data.map(doc => ({\n        id: doc.doctor_id,\n        name: doc.name,\n        specialty: doc.specialty,\n        image: doc.image_url,\n        rating: doc.rating,\n        availability: 'Available now'\n      }));\n      set({\n        availableDoctors: doctors,\n        loadingDoctors: false\n      });\n    } catch (error) {\n      console.error('Error loading doctors:', error);\n      set({\n        loadingDoctors: false\n      });\n    }\n  },\n  /**\n   * Check if a doctor is currently online via socket\n   */\n  checkDoctorOnline: async doctorId => {\n    if (!webRTCService) return false;\n    try {\n      const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n      return isOnline;\n    } catch (error) {\n      console.error('Error checking doctor online status:', error);\n      return false;\n    }\n  },\n  /**\n   * Initiate a call to a doctor\n   */\n  callDoctor: async doctor => {\n    try {\n      if (!webRTCService) {\n        throw new Error('WebRTC service not available');\n      }\n\n      // Save the selected doctor\n      set({\n        selectedDoctor: doctor,\n        callState: 'connecting'\n      });\n\n      // Initialize WebRTC if needed\n      if (!webRTCService.isInitialized) {\n        const userId = localStorage.getItem('user_instance_id') || `user-${Math.random().toString(36).substring(2, 15)}`;\n        webRTCService.initialize(userId, {\n          onCallStarted: () => set({\n            callState: 'active'\n          }),\n          onCallEnded: () => {\n            set({\n              callState: 'ended'\n            });\n            setTimeout(() => set({\n              showCallUI: false,\n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          },\n          onCallDeclined: () => {\n            set({\n              callState: 'ended'\n            });\n            setTimeout(() => set({\n              showCallUI: false,\n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          }\n        });\n      }\n\n      // Try to get media\n      await webRTCService.getLocalMedia();\n\n      // Make the call\n      await webRTCService.makeCall(`doctor-${doctor.id}`);\n\n      // Show call UI\n      set({\n        showCallUI: true\n      });\n    } catch (error) {\n      console.error('Failed to call doctor:', error);\n      set({\n        callState: 'ended'\n      });\n      setTimeout(() => set({\n        showCallUI: false,\n        selectedDoctor: null,\n        callState: 'idle'\n      }), 3000);\n      throw error;\n    }\n  },\n  /**\n   * End the current call\n   */\n  endCall: () => {\n    if (webRTCService) {\n      webRTCService.endCall();\n    }\n    set({\n      callState: 'ended'\n    });\n\n    // After a delay, reset the UI\n    setTimeout(() => {\n      set({\n        showCallUI: false,\n        selectedDoctor: null,\n        callState: 'idle'\n      });\n    }, 3000);\n  },\n  /**\n   * Handle incoming calls\n   */\n  setIncomingCall: callInfo => {\n    // Stop any existing ringtone\n    const {\n      ringtoneAudio\n    } = get();\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n    }\n\n    // Play ringtone for incoming call\n    try {\n      const audio = new Audio('/song1.mp3');\n      audio.loop = true;\n      audio.volume = 0.7;\n      audio.play().catch(e => console.log('Could not play ringtone:', e));\n      set({\n        ringtoneAudio: audio\n      });\n    } catch (error) {\n      console.log('Could not initialize ringtone:', error);\n    }\n    set({\n      incomingCall: callInfo\n    });\n  },\n  /**\n   * Accept incoming call\n   */\n  acceptIncomingCall: () => {\n    const {\n      incomingCall,\n      ringtoneAudio\n    } = get();\n    if (!incomingCall) return;\n\n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({\n        ringtoneAudio: null\n      });\n    }\n\n    // Accept the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.acceptCall();\n    }\n    set({\n      showCallUI: true,\n      callState: 'connecting',\n      selectedDoctor: incomingCall.doctor,\n      incomingCall: null\n    });\n  },\n  /**\n   * Decline incoming call\n   */\n  declineIncomingCall: () => {\n    const {\n      ringtoneAudio\n    } = get();\n\n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({\n        ringtoneAudio: null\n      });\n    }\n\n    // Decline the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.declineCall();\n    }\n    set({\n      incomingCall: null\n    });\n  },\n  /**\n   * Close the call UI\n   */\n  closeCallUI: () => {\n    // End any active call\n    if (webRTCService && get().callState !== 'idle') {\n      webRTCService.endCall();\n    }\n    set({\n      showCallUI: false,\n      callState: 'idle',\n      selectedDoctor: null\n    });\n  }\n}));\nexport default useGlobalCallStore;","map":{"version":3,"names":["create","supabase","webRTCService","useGlobalCallStore","set","get","activeCall","showCallUI","incomingCall","callState","ringtoneAudio","availableDoctors","selectedDoctor","loadingDoctors","loadAvailableDoctors","data","error","from","select","eq","doctors","map","doc","id","doctor_id","name","specialty","image","image_url","rating","availability","console","checkDoctorOnline","doctorId","isOnline","checkUserOnline","callDoctor","doctor","Error","isInitialized","userId","localStorage","getItem","Math","random","toString","substring","initialize","onCallStarted","onCallEnded","setTimeout","onCallDeclined","getLocalMedia","makeCall","endCall","setIncomingCall","callInfo","pause","currentTime","audio","Audio","loop","volume","play","catch","e","log","acceptIncomingCall","acceptCall","declineIncomingCall","declineCall","closeCallUI"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/services/GlobalCallService.js"],"sourcesContent":["// services/GlobalCallService.js\nimport { create } from 'zustand';\nimport supabase from '../supabaseClient';\nimport webRTCService from './WebRTCService';\n\n/**\n * Global state store for managing doctor calls from anywhere in the app\n * Uses Zustand for state management\n */\nconst useGlobalCallStore = create((set, get) => ({\n  // Call states\n  activeCall: null,\n  showCallUI: false,\n  incomingCall: null,\n  callState: 'idle', // 'idle', 'connecting', 'active', 'ended'\n  ringtoneAudio: null,\n  \n  // Doctor states\n  availableDoctors: [],\n  selectedDoctor: null,\n  loadingDoctors: false,\n  \n  /**\n   * Load available doctors from Supabase\n   */\n  loadAvailableDoctors: async () => {\n    try {\n      set({ loadingDoctors: true });\n      \n      const { data, error } = await supabase\n        .from('doctors')\n        .select('*')\n        .eq('availability', true);\n        \n      if (error) throw error;\n      \n      // Format doctor data for our app\n      const doctors = data.map(doc => ({\n        id: doc.doctor_id,\n        name: doc.name,\n        specialty: doc.specialty,\n        image: doc.image_url,\n        rating: doc.rating,\n        availability: 'Available now'\n      }));\n      \n      set({ availableDoctors: doctors, loadingDoctors: false });\n    } catch (error) {\n      console.error('Error loading doctors:', error);\n      set({ loadingDoctors: false });\n    }\n  },\n  \n  /**\n   * Check if a doctor is currently online via socket\n   */\n  checkDoctorOnline: async (doctorId) => {\n    if (!webRTCService) return false;\n    \n    try {\n      const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n      return isOnline;\n    } catch (error) {\n      console.error('Error checking doctor online status:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Initiate a call to a doctor\n   */\n  callDoctor: async (doctor) => {\n    try {\n      if (!webRTCService) {\n        throw new Error('WebRTC service not available');\n      }\n      \n      // Save the selected doctor\n      set({ selectedDoctor: doctor, callState: 'connecting' });\n      \n      // Initialize WebRTC if needed\n      if (!webRTCService.isInitialized) {\n        const userId = localStorage.getItem('user_instance_id') || \n                      `user-${Math.random().toString(36).substring(2, 15)}`;\n                      \n        webRTCService.initialize(userId, {\n          onCallStarted: () => set({ callState: 'active' }),\n          onCallEnded: () => {\n            set({ callState: 'ended' });\n            setTimeout(() => set({ \n              showCallUI: false, \n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          },\n          onCallDeclined: () => {\n            set({ callState: 'ended' });\n            setTimeout(() => set({ \n              showCallUI: false, \n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          }\n        });\n      }\n      \n      // Try to get media\n      await webRTCService.getLocalMedia();\n      \n      // Make the call\n      await webRTCService.makeCall(`doctor-${doctor.id}`);\n      \n      // Show call UI\n      set({ showCallUI: true });\n      \n    } catch (error) {\n      console.error('Failed to call doctor:', error);\n      set({ callState: 'ended' });\n      setTimeout(() => set({ \n        showCallUI: false, \n        selectedDoctor: null,\n        callState: 'idle'\n      }), 3000);\n      \n      throw error;\n    }\n  },\n  \n  /**\n   * End the current call\n   */\n  endCall: () => {\n    if (webRTCService) {\n      webRTCService.endCall();\n    }\n    \n    set({ callState: 'ended' });\n    \n    // After a delay, reset the UI\n    setTimeout(() => {\n      set({ \n        showCallUI: false, \n        selectedDoctor: null,\n        callState: 'idle'\n      });\n    }, 3000);\n  },\n  \n  /**\n   * Handle incoming calls\n   */\n  setIncomingCall: (callInfo) => {\n    // Stop any existing ringtone\n    const { ringtoneAudio } = get();\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n    }\n    \n    // Play ringtone for incoming call\n    try {\n      const audio = new Audio('/song1.mp3');\n      audio.loop = true;\n      audio.volume = 0.7;\n      audio.play().catch(e => console.log('Could not play ringtone:', e));\n      \n      set({ ringtoneAudio: audio });\n    } catch (error) {\n      console.log('Could not initialize ringtone:', error);\n    }\n    \n    set({ incomingCall: callInfo });\n  },\n  \n  /**\n   * Accept incoming call\n   */\n  acceptIncomingCall: () => {\n    const { incomingCall, ringtoneAudio } = get();\n    \n    if (!incomingCall) return;\n    \n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({ ringtoneAudio: null });\n    }\n    \n    // Accept the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.acceptCall();\n    }\n    \n    set({ \n      showCallUI: true,\n      callState: 'connecting',\n      selectedDoctor: incomingCall.doctor,\n      incomingCall: null\n    });\n  },\n  \n  /**\n   * Decline incoming call\n   */\n  declineIncomingCall: () => {\n    const { ringtoneAudio } = get();\n    \n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({ ringtoneAudio: null });\n    }\n    \n    // Decline the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.declineCall();\n    }\n    \n    set({ incomingCall: null });\n  },\n  \n  /**\n   * Close the call UI\n   */\n  closeCallUI: () => {\n    // End any active call\n    if (webRTCService && get().callState !== 'idle') {\n      webRTCService.endCall();\n    }\n    \n    set({ \n      showCallUI: false, \n      callState: 'idle',\n      selectedDoctor: null\n    });\n  }\n}));\n\nexport default useGlobalCallStore;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}