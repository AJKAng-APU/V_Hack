{"ast":null,"code":"// services/GlobalCallService.js\nimport { create } from 'zustand';\nimport supabase from '../supabaseClient';\nimport webRTCService from './WebRTCService';\n\n/**\n * Global state store for managing doctor calls from anywhere in the app\n * Uses Zustand for state management\n */\nconst useGlobalCallStore = create((set, get) => ({\n  // Call states\n  activeCall: null,\n  showCallUI: false,\n  incomingCall: null,\n  callState: 'idle',\n  // 'idle', 'connecting', 'active', 'ended'\n  ringtoneAudio: null,\n  // Doctor states\n  availableDoctors: [],\n  selectedDoctor: null,\n  loadingDoctors: false,\n  error: null,\n  /**\n   * Load available doctors from Supabase\n   * @returns {Promise} - Promise resolving to the list of available doctors\n   */\n  loadAvailableDoctors: async () => {\n    try {\n      set({\n        loadingDoctors: true,\n        error: null\n      });\n      const {\n        data,\n        error\n      } = await supabase.from('doctors').select('*').eq('availability', true);\n      if (error) throw error;\n\n      // Format doctor data for our app\n      const doctors = data.map(doc => ({\n        id: doc.doctor_id,\n        name: doc.name,\n        specialty: doc.specialty,\n        image: doc.image_url,\n        rating: doc.rating,\n        availability: 'Available now'\n      }));\n      set({\n        availableDoctors: doctors,\n        loadingDoctors: false\n      });\n      return doctors;\n    } catch (error) {\n      console.error('Error loading doctors:', error);\n      set({\n        loadingDoctors: false,\n        error: error.message\n      });\n      return [];\n    }\n  },\n  /**\n   * Check if a doctor is currently online via socket\n   * @param {number} doctorId - Doctor ID\n   * @returns {Promise<boolean>} - Whether the doctor is online\n   */\n  checkDoctorOnline: async doctorId => {\n    if (!webRTCService) return false;\n    try {\n      const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n      return isOnline;\n    } catch (error) {\n      console.error('Error checking doctor online status:', error);\n      return false;\n    }\n  },\n  /**\n   * Initiate a call to a doctor\n   * @param {Object} doctor - Doctor object\n   * @returns {Promise} - Promise resolving when the call is initiated\n   */\n  callDoctor: async doctor => {\n    try {\n      if (!webRTCService) {\n        throw new Error('WebRTC service not available');\n      }\n\n      // Save the selected doctor\n      set({\n        selectedDoctor: doctor,\n        callState: 'connecting'\n      });\n\n      // Initialize WebRTC if needed\n      if (!webRTCService.isInitialized) {\n        const userId = localStorage.getItem('user_instance_id') || `user-${Math.random().toString(36).substring(2, 15)}`;\n        webRTCService.initialize(userId, {\n          onCallStarted: () => set({\n            callState: 'active'\n          }),\n          onCallEnded: () => {\n            set({\n              callState: 'ended'\n            });\n            setTimeout(() => set({\n              showCallUI: false,\n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          },\n          onCallDeclined: () => {\n            set({\n              callState: 'ended'\n            });\n            setTimeout(() => set({\n              showCallUI: false,\n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          }\n        });\n      }\n\n      // Try to get media\n      await webRTCService.getLocalMedia();\n\n      // Make the call\n      await webRTCService.makeCall(`doctor-${doctor.id}`);\n\n      // Show call UI\n      set({\n        showCallUI: true\n      });\n    } catch (error) {\n      console.error('Failed to call doctor:', error);\n      set({\n        callState: 'ended',\n        error: error.message\n      });\n      setTimeout(() => set({\n        showCallUI: false,\n        selectedDoctor: null,\n        callState: 'idle',\n        error: null\n      }), 3000);\n      throw error;\n    }\n  },\n  /**\n   * End the current call\n   */\n  endCall: () => {\n    if (webRTCService) {\n      webRTCService.endCall();\n    }\n    set({\n      callState: 'ended'\n    });\n\n    // After a delay, reset the UI\n    setTimeout(() => {\n      set({\n        showCallUI: false,\n        selectedDoctor: null,\n        callState: 'idle'\n      });\n    }, 3000);\n  },\n  /**\n   * Handle incoming calls\n   * @param {Object} callInfo - Information about the incoming call\n   */\n  setIncomingCall: callInfo => {\n    // Stop any existing ringtone\n    const {\n      ringtoneAudio\n    } = get();\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n    }\n    set({\n      incomingCall: callInfo\n    });\n  },\n  /**\n   * Accept incoming call\n   */\n  acceptIncomingCall: () => {\n    const {\n      incomingCall,\n      ringtoneAudio\n    } = get();\n    if (!incomingCall) return;\n\n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({\n        ringtoneAudio: null\n      });\n    }\n\n    // Accept the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.acceptCall();\n    }\n    set({\n      showCallUI: true,\n      callState: 'connecting',\n      selectedDoctor: incomingCall.doctor,\n      incomingCall: null\n    });\n  },\n  /**\n   * Decline incoming call\n   */\n  declineIncomingCall: () => {\n    const {\n      ringtoneAudio\n    } = get();\n\n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({\n        ringtoneAudio: null\n      });\n    }\n\n    // Decline the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.declineCall();\n    }\n    set({\n      incomingCall: null\n    });\n  },\n  /**\n   * Close the call UI\n   */\n  closeCallUI: () => {\n    // End any active call\n    if (webRTCService && get().callState !== 'idle') {\n      webRTCService.endCall();\n    }\n    set({\n      showCallUI: false,\n      callState: 'idle',\n      selectedDoctor: null\n    });\n  }\n}));\nexport default useGlobalCallStore;","map":{"version":3,"names":["create","supabase","webRTCService","useGlobalCallStore","set","get","activeCall","showCallUI","incomingCall","callState","ringtoneAudio","availableDoctors","selectedDoctor","loadingDoctors","error","loadAvailableDoctors","data","from","select","eq","doctors","map","doc","id","doctor_id","name","specialty","image","image_url","rating","availability","console","message","checkDoctorOnline","doctorId","isOnline","checkUserOnline","callDoctor","doctor","Error","isInitialized","userId","localStorage","getItem","Math","random","toString","substring","initialize","onCallStarted","onCallEnded","setTimeout","onCallDeclined","getLocalMedia","makeCall","endCall","setIncomingCall","callInfo","pause","currentTime","acceptIncomingCall","acceptCall","declineIncomingCall","declineCall","closeCallUI"],"sources":["/Users/ang/V_Hack_Ver4/frontend2/src/components/services/GlobalCallService.js"],"sourcesContent":["// services/GlobalCallService.js\nimport { create } from 'zustand';\nimport supabase from '../supabaseClient';\nimport webRTCService from './WebRTCService';\n\n/**\n * Global state store for managing doctor calls from anywhere in the app\n * Uses Zustand for state management\n */\nconst useGlobalCallStore = create((set, get) => ({\n  // Call states\n  activeCall: null,\n  showCallUI: false,\n  incomingCall: null,\n  callState: 'idle', // 'idle', 'connecting', 'active', 'ended'\n  ringtoneAudio: null,\n  \n  // Doctor states\n  availableDoctors: [],\n  selectedDoctor: null,\n  loadingDoctors: false,\n  error: null,\n  \n  /**\n   * Load available doctors from Supabase\n   * @returns {Promise} - Promise resolving to the list of available doctors\n   */\n  loadAvailableDoctors: async () => {\n    try {\n      set({ loadingDoctors: true, error: null });\n      \n      const { data, error } = await supabase\n        .from('doctors')\n        .select('*')\n        .eq('availability', true);\n        \n      if (error) throw error;\n      \n      // Format doctor data for our app\n      const doctors = data.map(doc => ({\n        id: doc.doctor_id,\n        name: doc.name,\n        specialty: doc.specialty,\n        image: doc.image_url,\n        rating: doc.rating,\n        availability: 'Available now'\n      }));\n      \n      set({ availableDoctors: doctors, loadingDoctors: false });\n      return doctors;\n    } catch (error) {\n      console.error('Error loading doctors:', error);\n      set({ loadingDoctors: false, error: error.message });\n      return [];\n    }\n  },\n  \n  /**\n   * Check if a doctor is currently online via socket\n   * @param {number} doctorId - Doctor ID\n   * @returns {Promise<boolean>} - Whether the doctor is online\n   */\n  checkDoctorOnline: async (doctorId) => {\n    if (!webRTCService) return false;\n    \n    try {\n      const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n      return isOnline;\n    } catch (error) {\n      console.error('Error checking doctor online status:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Initiate a call to a doctor\n   * @param {Object} doctor - Doctor object\n   * @returns {Promise} - Promise resolving when the call is initiated\n   */\n  callDoctor: async (doctor) => {\n    try {\n      if (!webRTCService) {\n        throw new Error('WebRTC service not available');\n      }\n      \n      // Save the selected doctor\n      set({ selectedDoctor: doctor, callState: 'connecting' });\n      \n      // Initialize WebRTC if needed\n      if (!webRTCService.isInitialized) {\n        const userId = localStorage.getItem('user_instance_id') || \n                      `user-${Math.random().toString(36).substring(2, 15)}`;\n                      \n        webRTCService.initialize(userId, {\n          onCallStarted: () => set({ callState: 'active' }),\n          onCallEnded: () => {\n            set({ callState: 'ended' });\n            setTimeout(() => set({ \n              showCallUI: false, \n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          },\n          onCallDeclined: () => {\n            set({ callState: 'ended' });\n            setTimeout(() => set({ \n              showCallUI: false, \n              selectedDoctor: null,\n              callState: 'idle'\n            }), 3000);\n          }\n        });\n      }\n      \n      // Try to get media\n      await webRTCService.getLocalMedia();\n      \n      // Make the call\n      await webRTCService.makeCall(`doctor-${doctor.id}`);\n      \n      // Show call UI\n      set({ showCallUI: true });\n      \n    } catch (error) {\n      console.error('Failed to call doctor:', error);\n      set({ callState: 'ended', error: error.message });\n      setTimeout(() => set({ \n        showCallUI: false, \n        selectedDoctor: null,\n        callState: 'idle',\n        error: null\n      }), 3000);\n      \n      throw error;\n    }\n  },\n  \n  /**\n   * End the current call\n   */\n  endCall: () => {\n    if (webRTCService) {\n      webRTCService.endCall();\n    }\n    \n    set({ callState: 'ended' });\n    \n    // After a delay, reset the UI\n    setTimeout(() => {\n      set({ \n        showCallUI: false, \n        selectedDoctor: null,\n        callState: 'idle'\n      });\n    }, 3000);\n  },\n  \n  /**\n   * Handle incoming calls\n   * @param {Object} callInfo - Information about the incoming call\n   */\n  setIncomingCall: (callInfo) => {\n    // Stop any existing ringtone\n    const { ringtoneAudio } = get();\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n    }\n    \n    set({ incomingCall: callInfo });\n  },\n  \n  /**\n   * Accept incoming call\n   */\n  acceptIncomingCall: () => {\n    const { incomingCall, ringtoneAudio } = get();\n    \n    if (!incomingCall) return;\n    \n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({ ringtoneAudio: null });\n    }\n    \n    // Accept the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.acceptCall();\n    }\n    \n    set({ \n      showCallUI: true,\n      callState: 'connecting',\n      selectedDoctor: incomingCall.doctor,\n      incomingCall: null\n    });\n  },\n  \n  /**\n   * Decline incoming call\n   */\n  declineIncomingCall: () => {\n    const { ringtoneAudio } = get();\n    \n    // Stop ringtone\n    if (ringtoneAudio) {\n      ringtoneAudio.pause();\n      ringtoneAudio.currentTime = 0;\n      set({ ringtoneAudio: null });\n    }\n    \n    // Decline the call via WebRTC service\n    if (webRTCService) {\n      webRTCService.declineCall();\n    }\n    \n    set({ incomingCall: null });\n  },\n  \n  /**\n   * Close the call UI\n   */\n  closeCallUI: () => {\n    // End any active call\n    if (webRTCService && get().callState !== 'idle') {\n      webRTCService.endCall();\n    }\n    \n    set({ \n      showCallUI: false, \n      callState: 'idle',\n      selectedDoctor: null\n    });\n  }\n}));\n\nexport default useGlobalCallStore;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}