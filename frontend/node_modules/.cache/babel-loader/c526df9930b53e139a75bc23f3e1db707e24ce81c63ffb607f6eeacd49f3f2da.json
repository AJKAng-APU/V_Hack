{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectScreen = ({\n  colors,\n  setActiveScreen\n}) => {\n  _s();\n  const {\n    isDarkMode\n  } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n\n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(localStorage.getItem('is_doctor') === 'true');\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n\n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n\n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n\n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Sample doctors data\n  const doctors = [{\n    id: 1,\n    name: \"Dr. Johnson\",\n    specialty: \"Cardiologist\",\n    image: \"/User_1.png\",\n    availability: \"Available now\",\n    rating: 5\n  }, {\n    id: 2,\n    name: \"Dr. Smith\",\n    specialty: \"Primary Care\",\n    image: \"/User_2.jpg\",\n    availability: \"Available in 15m\",\n    rating: 4\n  }, {\n    id: 3,\n    name: \"Dr. Garcia\",\n    specialty: \"Endocrinologist\",\n    image: \"/User_3.png\",\n    availability: \"Available tomorrow\",\n    rating: 5\n  }, {\n    id: 4,\n    name: \"Dr. Chen\",\n    specialty: \"Neurologist\",\n    image: \"/User_4.png\",\n    availability: \"Available in 2h\",\n    rating: 4\n  }];\n  const generateDoctorId = () => {\n    return localStorage.getItem('doctor_id') || `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n  };\n\n  // FIXED: Doctor Mode Toggle useEffect\n  // IMPROVED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n            const doctorId = generateDoctorId(); // Use generated ID instead of hardcoded 1\n            localStorage.setItem('doctor_id', doctorId); // Store the ID\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n\n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n\n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    const callbacks = {\n      onIncomingCall: callerId => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      onUserNotOnline: userId => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        setConnectingDoctor(null);\n      },\n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n\n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {/* handle error */}\n          setRingtoneAudio(null);\n        }\n      }\n    };\n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && webRTCService.signalingService.isConnected() && !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.signalingService.send('register', currentUserId);\n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', error => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      clearInterval(registerInterval);\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {/* handle error */}\n      }\n      setIncomingCallInfo(null);\n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      webRTCService.disconnect();\n    };\n  }, []);\n\n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: doctor => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n\n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      cleanupPreviousCall();\n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          audio.addEventListener('error', e => {\n            console.error('Ringtone error:', e);\n          });\n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      playRingtone();\n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      setAutoAcceptTimer(timer);\n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    acceptIncomingCall: doctor => {\n      console.log('Accepting incoming call from:', doctor === null || doctor === void 0 ? void 0 : doctor.name);\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      setIncomingCallInfo(null);\n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n\n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      webRTCService.declineCall();\n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n\n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    checkDoctorOnline: async doctorId => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    // FIXED: initiateCall method with proper state checks\n    initiateCall: async doctor => {\n      if (!webRTCService || !doctor) return;\n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n\n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n    handleConnectDoctor: async doctor => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  const {\n    displayIncomingCallAlert,\n    acceptIncomingCall,\n    rejectIncomingCall,\n    initiateCall,\n    handleConnectDoctor\n  } = callHandlers;\n\n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n\n  // Handle search filtering\n  const handleSearch = query => {\n    setSearchQuery(query);\n  };\n\n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery ? doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()) : true;\n    const matchesAvailability = filterActive ? doctor.availability.includes('Available') && !doctor.availability.includes('in') : true;\n    return matchesSearch && matchesAvailability;\n  });\n\n  // Improved toast display function\n  const displayToast = message => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n\n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n\n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-6 pb-24 dark-mode-transition\",\n    style: {\n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)` : 'none'\n    },\n    children: [/*#__PURE__*/_jsxDEV(ConnectHeader, {\n      headerVisible: headerVisible,\n      notifications: notifications,\n      setNotifications: setNotifications,\n      colors: colors,\n      isDoctorMode: isDoctorMode,\n      setIsDoctorMode: setIsDoctorMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 551,\n      columnNumber: 7\n    }, this), incomingCallCounter > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 p-2 bg-red-100 rounded-md text-xs\",\n      children: [\"Incoming call events received: \", incomingCallCounter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 561,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(SearchBar, {\n      headerVisible: headerVisible,\n      searchFocused: searchFocused,\n      setSearchFocused: setSearchFocused,\n      searchQuery: searchQuery,\n      setSearchQuery: setSearchQuery,\n      handleSearch: handleSearch,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 566,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FilterChips, {\n      headerVisible: headerVisible,\n      filterActive: filterActive,\n      setFilterActive: setFilterActive,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 577,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DoctorsTeam, {\n      headerVisible: headerVisible,\n      doctors: filteredDoctors,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      handleConnectDoctor: handleConnectDoctor,\n      setSelectedDoctor: setSelectedDoctor,\n      setSchedulingDoctor: setSchedulingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 585,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(QuickConnectActions, {\n      headerVisible: headerVisible,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      initiateCall: initiateCall,\n      displayToast: displayToast,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 597,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RecentMessages, {\n      headerVisible: headerVisible,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 607,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MessageDialog, {\n      isOpen: showMessageDialog,\n      onClose: () => {\n        setShowMessageDialog(false);\n        setSchedulingDoctor(null);\n      },\n      colors: colors,\n      recipient: schedulingDoctor || connectingDoctor,\n      doctors: doctors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 613,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoCallScreen, {\n      isOpen: showVideoCall,\n      onClose: () => setShowVideoCall(false),\n      colors: colors,\n      doctor: connectingDoctor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 625,\n      columnNumber: 7\n    }, this), incomingCallInfo && /*#__PURE__*/_jsxDEV(IncomingCallUI, {\n      incomingCallInfo: incomingCallInfo,\n      colors: colors,\n      acceptIncomingCall: acceptIncomingCall,\n      rejectIncomingCall: rejectIncomingCall\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 634,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ToastNotification, {\n      activeToast: activeToast,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 643,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 649,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 544,\n    columnNumber: 5\n  }, this);\n};\n_s(ConnectScreen, \"kyZTdQukLxV/Hiq0PzZgaXBQPg0=\", false, function () {\n  return [useTheme];\n});\n_c = ConnectScreen;\nexport default ConnectScreen;\nvar _c;\n$RefreshReg$(_c, \"ConnectScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","MessageDialog","VideoCallScreen","ConnectHeader","SearchBar","FilterChips","DoctorsTeam","QuickConnectActions","RecentMessages","IncomingCallUI","ToastNotification","jsxDEV","_jsxDEV","ConnectScreen","colors","setActiveScreen","_s","isDarkMode","searchFocused","setSearchFocused","searchQuery","setSearchQuery","notifications","setNotifications","filterActive","setFilterActive","showMessageDialog","setShowMessageDialog","showVideoCall","setShowVideoCall","selectedDoctor","setSelectedDoctor","connectingDoctor","setConnectingDoctor","schedulingDoctor","setSchedulingDoctor","readyToConnect","setReadyToConnect","isDoctorMode","setIsDoctorMode","localStorage","getItem","toastQueue","setToastQueue","activeToast","setActiveToast","incomingCallInfo","setIncomingCallInfo","ringtoneAudio","setRingtoneAudio","autoAcceptTimer","setAutoAcceptTimer","incomingCallCounter","setIncomingCallCounter","prevShowVideoCall","doctors","id","name","specialty","image","availability","rating","generateDoctorId","Math","floor","random","setItem","registerAsDoctor","signalingService","isConnected","doctorId","send","console","log","displayToast","replace","setTimeout","error","userId","generateUniqueId","storedId","newId","toString","substring","currentUserId","callbacks","onIncomingCall","callerId","prev","callingDoctor","find","doc","parseInt","displayIncomingCallAlert","onUserNotOnline","doctor","onCallInProgress","callerUserId","message","pause","currentTime","e","serverUrl","process","env","REACT_APP_SIGNALING_SERVER","initialize","registerInterval","setInterval","isCallActive","unsubscribeError","on","fatal","clearInterval","clearTimeout","disconnect","callHandlers","cleanupPreviousCall","callNotificationId","Date","now","timestamp","playRingtone","audio","Audio","loop","volume","addEventListener","playPromise","play","undefined","then","catch","timer","acceptIncomingCall","acceptCall","rejectIncomingCall","declineCall","checkDoctorOnline","attempt","isOnline","checkUserOnline","Promise","resolve","initiateCall","getLocalMedia","makeCall","handleConnectDoctor","current","handleSearch","query","filteredDoctors","filter","matchesSearch","toLowerCase","includes","matchesAvailability","length","slice","headerVisible","setHeaderVisible","className","style","backgroundColor","background","backgroundImage","primary","accent","children","fileName","_jsxFileName","lineNumber","columnNumber","isOpen","onClose","recipient","jsx","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/ConnectScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext'; \nimport webRTCService from '../../services/WebRTCService';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\n\nconst ConnectScreen = ({ colors, setActiveScreen }) => {\n  const { isDarkMode } = useTheme();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n  \n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n  \n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(\n    localStorage.getItem('is_doctor') === 'true'\n  );\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n  \n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  \n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n  \n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n  \n  // Sample doctors data\n  const doctors = [\n    {\n      id: 1,\n      name: \"Dr. Johnson\",\n      specialty: \"Cardiologist\",\n      image: \"/User_1.png\",\n      availability: \"Available now\",\n      rating: 5\n    },\n    {\n      id: 2,\n      name: \"Dr. Smith\",\n      specialty: \"Primary Care\",\n      image: \"/User_2.jpg\",\n      availability: \"Available in 15m\",\n      rating: 4\n    },\n    {\n      id: 3,\n      name: \"Dr. Garcia\",\n      specialty: \"Endocrinologist\",\n      image: \"/User_3.png\",\n      availability: \"Available tomorrow\",\n      rating: 5\n    },\n    {\n      id: 4,\n      name: \"Dr. Chen\",\n      specialty: \"Neurologist\",\n      image: \"/User_4.png\",\n      availability: \"Available in 2h\",\n      rating: 4\n    },\n  ];\n\n  const generateDoctorId = () => {\n    return localStorage.getItem('doctor_id') || \n           `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n  };\n\n  // FIXED: Doctor Mode Toggle useEffect\n  // IMPROVED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    \n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && \n              webRTCService.signalingService.isConnected()) {\n            const doctorId = generateDoctorId();  // Use generated ID instead of hardcoded 1\n            localStorage.setItem('doctor_id', doctorId);  // Store the ID\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      \n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && \n            webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode]);\n  \n  // DEBUG: Log incoming call info whenever it changes\n  useEffect(() => {\n    if (incomingCallInfo) {\n      console.log('INCOMING CALL INFO UPDATED:', incomingCallInfo);\n    }\n  }, [incomingCallInfo]);\n  \n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      \n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    \n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    \n    const callbacks = {\n      onIncomingCall: (callerId) => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1)\n        \n        const callingDoctor = doctors.find(doc => `doctor-${doc.id}` === callerId) || {\n          id: parseInt(callerId.replace('doctor-', '')) || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"/User_1.png\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        \n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        \n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      \n      onUserNotOnline: (userId) => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        \n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        \n        setConnectingDoctor(null);\n      },\n\n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n        \n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) { /* handle error */ }\n          setRingtoneAudio(null);\n        }\n      }\n    };\n    \n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    \n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // FIXED: Doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        // FIXED: Proper signaling service access\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Registered as doctor-${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    \n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // FIXED: registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && \n          webRTCService.signalingService.isConnected() && \n          !webRTCService.isCallActive() && \n          !showVideoCall) {\n        \n        webRTCService.signalingService.send('register', currentUserId);\n        \n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = 1;\n          webRTCService.signalingService.send('register', `doctor-${doctorId}`);\n          console.log(`Re-registering as doctor-${doctorId}`);\n        }\n      }\n    }, 5000);\n    \n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', (error) => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        \n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n\n    \n    \n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      \n      clearInterval(registerInterval);\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) { /* handle error */ }\n      }\n      \n      setIncomingCallInfo(null);\n      \n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      \n      webRTCService.disconnect();\n    };\n  }, []);\n  \n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n      \n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        \n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        \n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      \n      cleanupPreviousCall();\n      \n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      \n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          \n          audio.addEventListener('error', (e) => {\n            console.error('Ringtone error:', e);\n          });\n          \n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      \n      playRingtone();\n      \n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      \n      setAutoAcceptTimer(timer);\n      \n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    \n    acceptIncomingCall: (doctor) => {\n      console.log('Accepting incoming call from:', doctor?.name);\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      setIncomingCallInfo(null);\n      \n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n      \n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    \n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      webRTCService.declineCall();\n      \n      setIncomingCallInfo(null);\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      \n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    \n    checkDoctorOnline: async (doctorId) => {\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    \n    // FIXED: initiateCall method with proper state checks\n    initiateCall: async (doctor) => {\n      if (!webRTCService || !doctor) return;\n    \n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n        \n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        \n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n      \n    handleConnectDoctor: async (doctor) => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      \n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        \n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        \n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        \n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  \n  const { displayIncomingCallAlert, acceptIncomingCall, rejectIncomingCall, initiateCall, handleConnectDoctor } = callHandlers;\n  \n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n    }\n    \n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n  \n  // Handle search filtering\n  const handleSearch = (query) => {\n    setSearchQuery(query);\n  };\n  \n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery \n      ? (doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || \n         doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()))\n      : true;\n      \n    const matchesAvailability = filterActive \n      ? doctor.availability.includes('Available') && !doctor.availability.includes('in')\n      : true;\n      \n    return matchesSearch && matchesAvailability;\n  });\n  \n  // Improved toast display function\n  const displayToast = (message) => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n  \n  // Process toast queue with increased display time (4 seconds)\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      \n      const timer = setTimeout(() => {\n        setActiveToast(null);\n      }, 4000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n  \n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div className=\"p-6 pb-24 dark-mode-transition\" style={{ \n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode \n        ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)`\n        : 'none'\n    }}>\n      <ConnectHeader \n        headerVisible={headerVisible}\n        notifications={notifications}\n        setNotifications={setNotifications}\n        colors={colors}\n        isDoctorMode={isDoctorMode}\n        setIsDoctorMode={setIsDoctorMode}\n      />\n      \n      {incomingCallCounter > 0 && (\n      <div className=\"mb-2 p-2 bg-red-100 rounded-md text-xs\">\n        Incoming call events received: {incomingCallCounter}\n      </div>\n    )}\n      \n      <SearchBar \n        headerVisible={headerVisible}\n        searchFocused={searchFocused}\n        setSearchFocused={setSearchFocused}\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n        handleSearch={handleSearch}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <FilterChips \n        headerVisible={headerVisible}\n        filterActive={filterActive}\n        setFilterActive={setFilterActive}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <DoctorsTeam \n        headerVisible={headerVisible}\n        doctors={filteredDoctors}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        handleConnectDoctor={handleConnectDoctor}\n        setSelectedDoctor={setSelectedDoctor}\n        setSchedulingDoctor={setSchedulingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        isDarkMode={isDarkMode}\n      />\n      \n      <QuickConnectActions \n        headerVisible={headerVisible}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        initiateCall={initiateCall}\n        displayToast={displayToast}\n        isDarkMode={isDarkMode}\n      />\n      \n      <RecentMessages \n        headerVisible={headerVisible}\n        colors={colors}\n      />\n      \n      {/* Message Dialog */}\n      <MessageDialog \n        isOpen={showMessageDialog}\n        onClose={() => {\n          setShowMessageDialog(false);\n          setSchedulingDoctor(null);\n        }}\n        colors={colors}\n        recipient={schedulingDoctor || connectingDoctor}\n        doctors={doctors}\n      />\n      \n      {/* Video Call Screen */}\n      <VideoCallScreen \n        isOpen={showVideoCall}\n        onClose={() => setShowVideoCall(false)}\n        colors={colors}\n        doctor={connectingDoctor}\n      />\n      \n      {/* Incoming Call UI */}\n      {incomingCallInfo && (\n        <IncomingCallUI \n          incomingCallInfo={incomingCallInfo}\n          colors={colors}\n          acceptIncomingCall={acceptIncomingCall}\n          rejectIncomingCall={rejectIncomingCall}\n        />\n      )}\n      \n      {/* Toast Notification */}\n      <ToastNotification \n        activeToast={activeToast}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <style jsx>{`\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ConnectScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}