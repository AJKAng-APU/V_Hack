{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/VideoCallScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport CallControls from './CallControls';\nimport ConnectionStatus from './ConnectionStatus';\nimport CallHeader from './CallHeader';\nimport ConnectingState from './ConnectingState';\nimport EndedState from './EndedState';\nimport VideoDisplay from './VideoDisplay';\nimport { Users } from 'lucide-react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCallScreen = ({\n  isOpen,\n  onClose,\n  colors,\n  doctor\n}) => {\n  _s();\n  var _remoteVideoRef$curre4;\n  const {\n    isDarkMode\n  } = useTheme();\n\n  // State variables\n  const [callStatus, setCallStatus] = useState('connecting'); // connecting, active, ended\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const [isSpeakerOff, setIsSpeakerOff] = useState(false);\n  const [callDuration, setCallDuration] = useState(0);\n  const [showControls, setShowControls] = useState(true);\n  const [alwaysShowControls, setAlwaysShowControls] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState('good'); // good, poor, unstable\n  const [reconnectAttempt, setReconnectAttempt] = useState(0);\n  const [errorMessage, setErrorMessage] = useState('');\n  const [streamReady, setStreamReady] = useState(false);\n\n  // Use refs for tracking state without triggering rerenders\n  const forceActiveRef = useRef(false);\n  const endingCallRef = useRef(false); // Track if we're in the process of ending call\n  const callEndedTimeRef = useRef(null); // Track when the call ended\n\n  // Refs for video elements and timers\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  const lastMoveTimeRef = useRef(0);\n  const callDurationTimer = useRef(null);\n  const stateCheckerInterval = useRef(null);\n  const stateCheckTimeouts = useRef([]);\n  const activeSinceRef = useRef(null);\n  const callStatusRef = useRef('connecting');\n  const mouseMoveTimerRef = useRef(null);\n  const endCheckIntervalRef = useRef(null);\n  const autoCloseTimerRef = useRef(null);\n\n  // Update the ref when state changes\n  useEffect(() => {\n    callStatusRef.current = callStatus;\n  }, [callStatus]);\n\n  // Enhanced logging for debugging\n  const log = message => {\n    console.log(`[VideoCall] ${message}`);\n  };\n\n  // CRITICAL FIX: Get direct access to the socket for better call-ended handling\n  useEffect(() => {\n    var _webRTCService$signal;\n    if (!isOpen) return;\n\n    // Get direct access to the socket.io connection if available\n    const socket = (_webRTCService$signal = webRTCService.signalingService) === null || _webRTCService$signal === void 0 ? void 0 : _webRTCService$signal.socket;\n    if (!socket) {\n      log('Warning: No direct socket access available');\n      return;\n    }\n\n    // Setup direct socket event listener for call-ended\n    const handleDirectSocketCallEnded = () => {\n      log('ðŸ”´ DIRECT SOCKET call-ended event received!');\n      synchronizedEndCall('socket event');\n    };\n\n    // Add the event listener directly to the socket\n    socket.on('call-ended', handleDirectSocketCallEnded);\n\n    // Track when this event listener was added\n    log('Added direct socket event listener for call-ended');\n    return () => {\n      // Remove the event listener when component unmounts\n      if (socket) {\n        socket.off('call-ended', handleDirectSocketCallEnded);\n        log('Removed direct socket event listener for call-ended');\n      }\n    };\n  }, [isOpen]);\n\n  // Create an enhanced synchronized end call function with reason tracking\n  const synchronizedEndCall = (reason = 'user action') => {\n    var _localVideoRef$curren, _remoteVideoRef$curre;\n    // Prevent multiple executions\n    if (endingCallRef.current) {\n      log(`Call already ending (ignored reason: ${reason})`);\n      return;\n    }\n    log(`ðŸ”´ ENDING CALL - reason: ${reason}`);\n    endingCallRef.current = true;\n    callEndedTimeRef.current = Date.now();\n\n    // 1. Immediately set local state to ended\n    setCallStatus('ended');\n    callStatusRef.current = 'ended';\n\n    // 2. Stop media tracks immediately\n    if ((_localVideoRef$curren = localVideoRef.current) !== null && _localVideoRef$curren !== void 0 && _localVideoRef$curren.srcObject) {\n      log('Stopping local video tracks');\n      try {\n        const stream = localVideoRef.current.srcObject;\n        stream.getTracks().forEach(track => {\n          log(`Stopping ${track.kind} track`);\n          track.stop();\n        });\n        localVideoRef.current.srcObject = null;\n      } catch (error) {\n        log(`Error stopping local tracks: ${error.message}`);\n      }\n    }\n\n    // 3. Clean up remote video\n    if ((_remoteVideoRef$curre = remoteVideoRef.current) !== null && _remoteVideoRef$curre !== void 0 && _remoteVideoRef$curre.srcObject) {\n      try {\n        remoteVideoRef.current.srcObject = null;\n      } catch (error) {\n        log(`Error clearing remote video: ${error.message}`);\n      }\n    }\n\n    // 4. Clear call duration timer\n    if (callDurationTimer.current) {\n      clearInterval(callDurationTimer.current);\n      callDurationTimer.current = null;\n    }\n\n    // 5. If endCall was triggered by the user (not by receiving an end event),\n    // send end-call signal to the other party multiple times for reliability\n    if (reason === 'user action' && webRTCService.signalingService && webRTCService.targetUserId) {\n      const targetUserId = webRTCService.targetUserId;\n      log(`Sending end-call signals to ${targetUserId}`);\n\n      // CRITICAL: Send via multiple methods for maximum reliability\n\n      // Method 1: Use the signaling service's send method (most reliable)\n      try {\n        webRTCService.signalingService.send('end-call', {\n          targetUserId\n        });\n\n        // Send additional signals with delays for redundancy\n        setTimeout(() => {\n          try {\n            webRTCService.signalingService.send('end-call', {\n              targetUserId\n            });\n            log('Sent second end-call signal');\n          } catch (e) {\n            log(`Error sending second end-call signal: ${e.message}`);\n          }\n        }, 300);\n        setTimeout(() => {\n          try {\n            webRTCService.signalingService.send('end-call', {\n              targetUserId\n            });\n            log('Sent third end-call signal');\n          } catch (e) {\n            log(`Error sending third end-call signal: ${e.message}`);\n          }\n        }, 800);\n      } catch (error) {\n        log(`Error sending primary end-call signal: ${error.message}`);\n      }\n\n      // Method 2: If direct socket access is available, emit the event directly\n      // This bypasses any potential issues in the signaling service\n      try {\n        var _webRTCService$signal2;\n        const socket = (_webRTCService$signal2 = webRTCService.signalingService) === null || _webRTCService$signal2 === void 0 ? void 0 : _webRTCService$signal2.socket;\n        if (socket) {\n          socket.emit('end-call', {\n            targetUserId\n          });\n          log('Sent direct socket end-call event');\n        }\n      } catch (socketError) {\n        log(`Error with direct socket emit: ${socketError.message}`);\n      }\n    }\n\n    // 6. Tell WebRTCService to end the call (but don't send another notification)\n    try {\n      webRTCService.endCall(false);\n    } catch (error) {\n      log(`Error ending call in WebRTCService: ${error.message}`);\n    }\n\n    // 7. Schedule UI close after a fixed delay (2 seconds)\n    if (autoCloseTimerRef.current) {\n      clearTimeout(autoCloseTimerRef.current);\n    }\n    autoCloseTimerRef.current = setTimeout(() => {\n      log('Auto-closing call UI after ended state');\n      onClose();\n    }, 2000);\n  };\n\n  // When call becomes active, ensure controls are visible and reset timer\n  useEffect(() => {\n    if (callStatus === 'active') {\n      setShowControls(true);\n      if (mouseMoveTimerRef.current) {\n        clearTimeout(mouseMoveTimerRef.current);\n      }\n      mouseMoveTimerRef.current = setTimeout(() => {\n        if (!alwaysShowControls) {\n          setShowControls(false);\n        }\n      }, 15000);\n    }\n  }, [callStatus, alwaysShowControls]);\n\n  // NEW: Add more direct event listeners for call-ended event\n  useEffect(() => {\n    var _webRTCService$signal3;\n    if (!isOpen) return;\n    const handleCallEndedEvent = () => {\n      log('WebRTCService emitted call-ended event - ending call');\n      synchronizedEndCall('event emitter');\n    };\n\n    // Add listener to WebRTCService's event emitter\n    const unsubscribeDirectCallEnded = webRTCService.eventEmitter.on('call-ended', handleCallEndedEvent);\n\n    // Also listen for socket disconnect as a potential signal of call end\n    const handleSocketDisconnect = () => {\n      if (callStatusRef.current !== 'ended' && callStatusRef.current !== 'connecting') {\n        log('Socket disconnected while call was active - ending call');\n        synchronizedEndCall('socket disconnect');\n      }\n    };\n\n    // Try to subscribe to socket disconnect events if available\n    let unsubscribeSocketDisconnect = () => {};\n    if ((_webRTCService$signal3 = webRTCService.signalingService) !== null && _webRTCService$signal3 !== void 0 && _webRTCService$signal3.socket) {\n      webRTCService.signalingService.socket.on('disconnect', handleSocketDisconnect);\n      unsubscribeSocketDisconnect = () => {\n        var _webRTCService$signal4, _webRTCService$signal5;\n        (_webRTCService$signal4 = webRTCService.signalingService) === null || _webRTCService$signal4 === void 0 ? void 0 : (_webRTCService$signal5 = _webRTCService$signal4.socket) === null || _webRTCService$signal5 === void 0 ? void 0 : _webRTCService$signal5.off('disconnect', handleSocketDisconnect);\n      };\n    }\n\n    // Regular check to detect if WebRTCService's call state is ended\n    endCheckIntervalRef.current = setInterval(() => {\n      var _webRTCService$connec;\n      // Check if WebRTCService thinks the call has ended\n      if (callStatusRef.current !== 'ended' && webRTCService.callState === 'ended') {\n        log('WebRTCService call state is \"ended\" but UI hasn\\'t updated - ending call');\n        synchronizedEndCall('service state check');\n      }\n\n      // Also check peer connection states\n      const peerConnection = (_webRTCService$connec = webRTCService.connectionManager) === null || _webRTCService$connec === void 0 ? void 0 : _webRTCService$connec.peerConnection;\n      if (peerConnection) {\n        const connState = peerConnection.connectionState;\n        const iceState = peerConnection.iceConnectionState;\n\n        // If connection completely failed or closed\n        if ((connState === 'closed' || connState === 'failed') && callStatusRef.current !== 'ended') {\n          log(`Peer connection is in ${connState} state - ending call`);\n          synchronizedEndCall('peer connection failure');\n        }\n\n        // If ICE connection failed\n        if (iceState === 'failed' && callStatusRef.current !== 'ended') {\n          log('ICE connection failed - ending call');\n          synchronizedEndCall('ice failure');\n        }\n\n        // If connection is disconnected for too long\n        if (connState === 'disconnected') {\n          const disconnectedDuration = Date.now() - lastMoveTimeRef.current;\n          if (disconnectedDuration > 5000 && callStatusRef.current !== 'ended') {\n            log(`Connection disconnected for ${disconnectedDuration}ms - ending call`);\n            synchronizedEndCall('disconnection timeout');\n          }\n        }\n      }\n    }, 1000);\n    return () => {\n      if (typeof unsubscribeDirectCallEnded === 'function') {\n        unsubscribeDirectCallEnded();\n      }\n      unsubscribeSocketDisconnect();\n      if (endCheckIntervalRef.current) {\n        clearInterval(endCheckIntervalRef.current);\n        endCheckIntervalRef.current = null;\n      }\n    };\n  }, [isOpen, onClose]);\n\n  // Force check and update UI state\n  const forceVideoStateCheck = () => {\n    var _webRTCService$connec3;\n    if (callStatusRef.current === 'ended') return;\n    let shouldSetActive = false;\n\n    // Check remote video stream\n    if (remoteVideoRef.current) {\n      var _webRTCService$connec2;\n      if (!remoteVideoRef.current.srcObject && (_webRTCService$connec2 = webRTCService.connectionManager) !== null && _webRTCService$connec2 !== void 0 && _webRTCService$connec2.remoteStream) {\n        log('Attaching remote stream to video element');\n        remoteVideoRef.current.srcObject = webRTCService.connectionManager.remoteStream;\n        try {\n          remoteVideoRef.current.play().catch(e => {\n            log(`Remote video play error: ${e.message}`);\n          });\n        } catch (err) {\n          log(`Error playing remote video: ${err.message}`);\n        }\n        shouldSetActive = true;\n      }\n      if (remoteVideoRef.current.srcObject) {\n        const tracks = remoteVideoRef.current.srcObject.getTracks();\n        if (tracks.length > 0) {\n          shouldSetActive = true;\n          if (remoteVideoRef.current.paused) {\n            remoteVideoRef.current.play().catch(e => {\n              log(`Auto-play failed: ${e.message}`);\n            });\n          }\n        }\n      }\n    }\n    if (webRTCService.isCallActive() && callStatusRef.current !== 'active') {\n      shouldSetActive = true;\n    }\n    if ((_webRTCService$connec3 = webRTCService.connectionManager) !== null && _webRTCService$connec3 !== void 0 && _webRTCService$connec3.remoteStream) {\n      if (remoteVideoRef.current && remoteVideoRef.current.srcObject !== webRTCService.connectionManager.remoteStream) {\n        remoteVideoRef.current.srcObject = webRTCService.connectionManager.remoteStream;\n        try {\n          remoteVideoRef.current.play().catch(e => {\n            log(`Remote video play error: ${e.message}`);\n          });\n        } catch (err) {\n          log(`Error playing remote video: ${err.message}`);\n        }\n      }\n      shouldSetActive = true;\n    }\n    if (!activeSinceRef.current && callStatusRef.current === 'active') {\n      activeSinceRef.current = Date.now();\n    }\n    if (activeSinceRef.current && Date.now() - activeSinceRef.current > 5000) {\n      forceActiveRef.current = true;\n    }\n    if (shouldSetActive && callStatusRef.current !== 'active') {\n      setCallStatus('active');\n      setStreamReady(true);\n      setShowControls(true);\n    }\n\n    // Handle local video\n    if (localVideoRef.current) {\n      var _webRTCService$mediaM;\n      if (!localVideoRef.current.srcObject && (_webRTCService$mediaM = webRTCService.mediaManager) !== null && _webRTCService$mediaM !== void 0 && _webRTCService$mediaM.localStream) {\n        localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n        try {\n          localVideoRef.current.play().catch(e => {\n            log(`Local play error: ${e.message}`);\n            localVideoRef.current.muted = true;\n            localVideoRef.current.play().catch(innerErr => {\n              log(`Local muted play also failed: ${innerErr.message}`);\n            });\n          });\n        } catch (err) {\n          log(`Error during local play: ${err.message}`);\n        }\n      } else if (localVideoRef.current.srcObject) {\n        const videoTracks = localVideoRef.current.srcObject.getVideoTracks();\n        if (videoTracks.length > 0) {\n          videoTracks.forEach(track => {\n            if (!isVideoOff && !track.enabled) {\n              track.enabled = true;\n            }\n          });\n        }\n      }\n    }\n  };\n\n  // Function to safely toggle video state\n  const toggleVideo = videoOff => {\n    log(`Toggle video: ${videoOff}`);\n    setIsVideoOff(videoOff);\n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleVideo(videoOff);\n    }\n  };\n\n  // Toggle always showing controls\n  const toggleAlwaysShowControls = () => {\n    try {\n      setAlwaysShowControls(prevValue => {\n        const newValue = !prevValue;\n        if (newValue) {\n          setShowControls(true);\n          if (mouseMoveTimerRef.current) {\n            clearTimeout(mouseMoveTimerRef.current);\n            mouseMoveTimerRef.current = null;\n          }\n        }\n        try {\n          localStorage.setItem('always_show_controls', newValue ? 'true' : 'false');\n        } catch (e) {\n          // Ignore storage errors\n        }\n        return newValue;\n      });\n    } catch (err) {\n      console.error('Error in toggleAlwaysShowControls:', err);\n    }\n  };\n\n  // Load saved preference for always showing controls\n  useEffect(() => {\n    try {\n      const savedPreference = localStorage.getItem('always_show_controls');\n      if (savedPreference === 'true') {\n        setAlwaysShowControls(true);\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n  }, []);\n\n  // Handle ending call using the synchronized end function\n  const handleEndCall = () => {\n    log('User initiated call end');\n    synchronizedEndCall('user action');\n  };\n\n  // Initialize WebRTC when component mounts\n  useEffect(() => {\n    if (!isOpen || !doctor) return;\n    log(`Opening call with ${doctor.name}`);\n    endingCallRef.current = false; // Reset ending call flag\n    callEndedTimeRef.current = null;\n    activeSinceRef.current = null;\n    forceActiveRef.current = false;\n\n    // Reset state when opening\n    setCallStatus('connecting');\n    callStatusRef.current = 'connecting';\n    setStreamReady(false);\n\n    // Define handleLocalStream function first before using in callbacks\n    const handleLocalStream = stream => {\n      log(`Got local stream with ${stream.getTracks().length} tracks`);\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n        log('Set local video source');\n        try {\n          localVideoRef.current.play().catch(err => {\n            log(`Local video play error: ${err.message}`);\n          });\n        } catch (err) {\n          log(`Error playing local video: ${err.message}`);\n        }\n        setTimeout(() => {\n          if (localVideoRef.current) {\n            if (!localVideoRef.current.srcObject) {\n              localVideoRef.current.srcObject = stream;\n            }\n            if (localVideoRef.current.paused) {\n              localVideoRef.current.play().catch(e => log(`Error: ${e.message}`));\n            }\n          }\n        }, 1000);\n      }\n    };\n\n    // Set up callbacks\n    const callbacks = {\n      onLocalStream: handleLocalStream,\n      onRemoteStream: stream => {\n        log(`Got remote stream with ${stream.getTracks().length} tracks`);\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.srcObject = stream;\n          remoteVideoRef.current.muted = isSpeakerOff;\n          log('Set remote video source');\n          setStreamReady(true);\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          try {\n            remoteVideoRef.current.play().catch(err => {\n              log(`Initial play failed: ${err.message}`);\n            });\n          } catch (err) {\n            log(`Error during initial play: ${err.message}`);\n          }\n          if (callDurationTimer.current) {\n            clearInterval(callDurationTimer.current);\n          }\n          callDurationTimer.current = setInterval(() => {\n            setCallDuration(prev => prev + 1);\n          }, 1000);\n        }\n      },\n      onCallStarted: () => {\n        log('Call started callback fired');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setReconnectAttempt(0);\n        setErrorMessage('');\n        setShowControls(true);\n        if (!callDurationTimer.current) {\n          callDurationTimer.current = setInterval(() => {\n            setCallDuration(prev => prev + 1);\n          }, 1000);\n        }\n      },\n      onCallEnded: () => {\n        log('Call ended callback fired');\n        synchronizedEndCall('callback');\n      },\n      onICEConnectionStateChange: state => {\n        log(`ICE connection state changed to: ${state}`);\n        if (state === 'checking') {\n          setConnectionQuality('unstable');\n        } else if (state === 'connected' || state === 'completed') {\n          setConnectionQuality('good');\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          setShowControls(true);\n        } else if (state === 'disconnected') {\n          setConnectionQuality('poor');\n          setReconnectAttempt(prev => prev + 1);\n          setShowControls(true);\n\n          // Start tracking potential disconnection\n          lastMoveTimeRef.current = Date.now();\n        } else if (state === 'failed') {\n          setConnectionQuality('unstable');\n          setReconnectAttempt(prev => prev + 1);\n          setShowControls(true);\n\n          // If complete failure, end call after short delay\n          setTimeout(() => {\n            var _webRTCService$connec4, _webRTCService$connec5;\n            if (callStatusRef.current !== 'ended' && ((_webRTCService$connec4 = webRTCService.connectionManager) === null || _webRTCService$connec4 === void 0 ? void 0 : (_webRTCService$connec5 = _webRTCService$connec4.peerConnection) === null || _webRTCService$connec5 === void 0 ? void 0 : _webRTCService$connec5.iceConnectionState) === 'failed') {\n              log('ICE connection failed, forcing ended state');\n              synchronizedEndCall('ice failure timeout');\n            }\n          }, 5000);\n        }\n      }\n    };\n\n    // Register callbacks\n    webRTCService.updateCallbacks(callbacks);\n\n    // Ensure we have local media\n    if (!webRTCService.mediaManager.hasLocalStream()) {\n      log('Requesting camera and microphone access');\n      webRTCService.getLocalMedia(true, true).then(stream => {\n        log(`Local media access granted with ${stream.getTracks().length} tracks`);\n        if (localVideoRef.current) {\n          localVideoRef.current.srcObject = stream;\n          localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n        }\n      }).catch(error => {\n        log(`Media access error: ${error.message}`);\n        setErrorMessage(`Camera/mic access failed: ${error.message}`);\n      });\n    } else {\n      const stream = webRTCService.mediaManager.localStream;\n      log(`Using existing local stream with ${stream.getTracks().length} tracks`);\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n        localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n      }\n    }\n\n    // Set up state checker at regular intervals\n    stateCheckerInterval.current = setInterval(() => {\n      forceVideoStateCheck();\n    }, 1000);\n\n    // Add specific timeouts for critical checks\n    stateCheckTimeouts.current = [setTimeout(() => forceVideoStateCheck(), 2000), setTimeout(() => forceVideoStateCheck(), 5000), setTimeout(() => forceVideoStateCheck(), 8000), setTimeout(() => {\n      if (callStatusRef.current === 'connecting') {\n        log('10 seconds passed, forcing active state');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        forceActiveRef.current = true;\n        setShowControls(true);\n      }\n    }, 10000)];\n\n    // Listen for call state changes\n    const unsubscribeCallState = webRTCService.on('callStateChanged', state => {\n      log(`Call state event: ${state}, current UI state: ${callStatusRef.current}`);\n      if (state === 'ended') {\n        log('Call ended event received via state change');\n        synchronizedEndCall('state change');\n      }\n    });\n\n    // Listen for direct call-ended event\n    const unsubscribeCallEnded = webRTCService.on('call-ended', () => {\n      log('Direct call-ended event received via event subscription');\n      synchronizedEndCall('direct event');\n    });\n\n    // Listen for errors\n    const unsubscribeError = webRTCService.on('error', error => {\n      log(`WebRTC error: ${error.message}`);\n      setErrorMessage(error.message || 'Call error');\n      setShowControls(true);\n      if (error.fatal) {\n        synchronizedEndCall('fatal error');\n      }\n    });\n\n    // Listen for remote tracks added\n    const unsubscribeTrackAdded = webRTCService.on('remoteTrackAdded', () => {\n      log('Remote track added event received');\n      setCallStatus('active');\n      callStatusRef.current = 'active';\n      setStreamReady(true);\n      setShowControls(true);\n    });\n\n    // Set up mouse movement tracker for controls\n    const handleUserActivity = () => {\n      const now = Date.now();\n      if (now - lastMoveTimeRef.current > 150) {\n        lastMoveTimeRef.current = now;\n        if (!showControls) {\n          setShowControls(true);\n        }\n        if (!alwaysShowControls) {\n          clearTimeout(mouseMoveTimerRef.current);\n          mouseMoveTimerRef.current = setTimeout(() => {\n            setShowControls(false);\n          }, 10000);\n        }\n      }\n    };\n    window.addEventListener('mousemove', handleUserActivity);\n    window.addEventListener('touchstart', handleUserActivity);\n\n    // Double-tap handler\n    let lastTapTime = 0;\n    const handleDoubleTap = e => {\n      const now = Date.now();\n      const DOUBLE_TAP_THRESHOLD = 300;\n      if (now - lastTapTime < DOUBLE_TAP_THRESHOLD) {\n        toggleAlwaysShowControls();\n        e.preventDefault();\n      }\n      lastTapTime = now;\n    };\n    window.addEventListener('touchend', handleDoubleTap);\n\n    // Force active after a delay\n    setTimeout(() => {\n      if (webRTCService.isCallActive()) {\n        log('Force activating call after delay');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setShowControls(true);\n      }\n    }, 1000);\n\n    // Clean up\n    return () => {\n      var _localVideoRef$curren2, _remoteVideoRef$curre2;\n      log('Cleaning up call resources');\n      unsubscribeCallState();\n      unsubscribeError();\n      unsubscribeTrackAdded();\n      unsubscribeCallEnded();\n      if (stateCheckerInterval.current) {\n        clearInterval(stateCheckerInterval.current);\n        stateCheckerInterval.current = null;\n      }\n      if (endCheckIntervalRef.current) {\n        clearInterval(endCheckIntervalRef.current);\n        endCheckIntervalRef.current = null;\n      }\n      if (autoCloseTimerRef.current) {\n        clearTimeout(autoCloseTimerRef.current);\n        autoCloseTimerRef.current = null;\n      }\n      stateCheckTimeouts.current.forEach(timeout => clearTimeout(timeout));\n      stateCheckTimeouts.current = [];\n      window.removeEventListener('mousemove', handleUserActivity);\n      window.removeEventListener('touchstart', handleUserActivity);\n      window.removeEventListener('touchend', handleDoubleTap);\n      if (mouseMoveTimerRef.current) {\n        clearTimeout(mouseMoveTimerRef.current);\n      }\n      if (callDurationTimer.current) {\n        clearInterval(callDurationTimer.current);\n        callDurationTimer.current = null;\n      }\n\n      // Clean up video elements\n      if ((_localVideoRef$curren2 = localVideoRef.current) !== null && _localVideoRef$curren2 !== void 0 && _localVideoRef$curren2.srcObject) {\n        const stream = localVideoRef.current.srcObject;\n        stream.getTracks().forEach(track => track.stop());\n        localVideoRef.current.srcObject = null;\n      }\n      if ((_remoteVideoRef$curre2 = remoteVideoRef.current) !== null && _remoteVideoRef$curre2 !== void 0 && _remoteVideoRef$curre2.srcObject) {\n        remoteVideoRef.current.srcObject = null;\n      }\n\n      // End the call\n      webRTCService.endCall(true);\n    };\n  }, [isOpen, doctor, onClose, alwaysShowControls]);\n\n  // Update WebRTC when audio mute state changes\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleAudio(isMuted);\n    }\n  }, [isMuted]);\n\n  // Call duration timer based on active status\n  useEffect(() => {\n    if (callStatus === 'active' && !callDurationTimer.current) {\n      log('Starting call duration timer based on active call status');\n      callDurationTimer.current = setInterval(() => {\n        setCallDuration(prev => prev + 1);\n      }, 1000);\n    }\n    return () => {\n      if (callDurationTimer.current && callStatus !== 'active') {\n        clearInterval(callDurationTimer.current);\n        callDurationTimer.current = null;\n      }\n    };\n  }, [callStatus]);\n\n  // Update remote video muted state when isSpeakerOff changes\n  useEffect(() => {\n    if (remoteVideoRef.current) {\n      remoteVideoRef.current.muted = isSpeakerOff;\n    }\n  }, [isSpeakerOff]);\n\n  // Update WebRTC when video state changes\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleVideo(isVideoOff);\n    }\n  }, [isVideoOff]);\n\n  // Format seconds to MM:SS\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  // Additional effect to handle active state when remote video is detected\n  useEffect(() => {\n    var _remoteVideoRef$curre3;\n    if ((_remoteVideoRef$curre3 = remoteVideoRef.current) !== null && _remoteVideoRef$curre3 !== void 0 && _remoteVideoRef$curre3.srcObject) {\n      const checkForTracks = () => {\n        const tracks = remoteVideoRef.current.srcObject.getTracks();\n        if (tracks.length > 0) {\n          log(`Remote video has ${tracks.length} tracks, forcing active state`);\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          setStreamReady(true);\n          setShowControls(true);\n          return true;\n        }\n        return false;\n      };\n      if (checkForTracks()) return;\n      const handleCanPlay = () => {\n        log('Remote video can play event fired');\n        setStreamReady(true);\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setShowControls(true);\n      };\n      const handleLoadedMetadata = () => {\n        log('Remote video loadedmetadata event fired');\n        checkForTracks();\n      };\n      remoteVideoRef.current.addEventListener('canplay', handleCanPlay);\n      remoteVideoRef.current.addEventListener('loadedmetadata', handleLoadedMetadata);\n      if (remoteVideoRef.current.readyState >= 3) {\n        remoteVideoRef.current.play().catch(e => {\n          log('Error auto-playing video: ' + e.message);\n        });\n      }\n      return () => {\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.removeEventListener('canplay', handleCanPlay);\n          remoteVideoRef.current.removeEventListener('loadedmetadata', handleLoadedMetadata);\n        }\n      };\n    }\n  }, [(_remoteVideoRef$curre4 = remoteVideoRef.current) === null || _remoteVideoRef$curre4 === void 0 ? void 0 : _remoteVideoRef$curre4.srcObject]);\n\n  // Force active state after a timeout\n  useEffect(() => {\n    if (callStatus === 'connecting') {\n      const timeout = setTimeout(() => {\n        log('Timeout reached, forcing active state');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        forceActiveRef.current = true;\n        setShowControls(true);\n      }, 15000);\n      return () => clearTimeout(timeout);\n    }\n  }, [callStatus]);\n\n  // Ensure local video is displayed\n  useEffect(() => {\n    if (isOpen && localVideoRef.current) {\n      if (webRTCService.mediaManager.hasLocalStream() && !localVideoRef.current.srcObject) {\n        log('Connecting existing local stream to video element');\n        localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n        localVideoRef.current.play().catch(err => {\n          log(`Failed to play local video: ${err.message}`);\n        });\n      }\n      const checkTimer = setTimeout(() => {\n        if (webRTCService.mediaManager.hasLocalStream() && (!localVideoRef.current.srcObject || localVideoRef.current.paused)) {\n          log('Delayed local video check - reconnecting stream');\n          localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n          localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n        }\n      }, 2000);\n      return () => clearTimeout(checkTimer);\n    }\n  }, [isOpen, callStatus]);\n  if (!isOpen) return null;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"fixed inset-0 z-50 flex items-center justify-center\",\n    style: {\n      backgroundColor: 'rgba(0,0,0,0.85)',\n      backdropFilter: 'blur(10px)'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"w-full h-full max-w-md relative overflow-hidden\",\n      children: [callStatus === 'ended' ? /*#__PURE__*/_jsxDEV(EndedState, {\n        doctor: doctor,\n        errorMessage: errorMessage,\n        callDuration: callDuration,\n        formatTime: formatTime,\n        colors: colors,\n        isDarkMode: isDarkMode\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 913,\n        columnNumber: 11\n      }, this) : callStatus === 'connecting' ? /*#__PURE__*/_jsxDEV(ConnectingState, {\n        doctor: doctor,\n        colors: colors\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 922,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(VideoDisplay, {\n        remoteVideoRef: remoteVideoRef,\n        localVideoRef: localVideoRef,\n        isSpeakerOff: isSpeakerOff,\n        isVideoOff: isVideoOff,\n        doctor: doctor,\n        connectionQuality: connectionQuality,\n        reconnectAttempt: reconnectAttempt,\n        showControls: showControls,\n        isDarkMode: isDarkMode,\n        colors: colors,\n        callStatus: callStatus,\n        forceActiveState: forceActiveRef.current,\n        onClick: () => {\n          // Toggle controls on video click\n          setShowControls(prev => !prev);\n\n          // Reset hide timer if showing controls\n          if (!showControls && !alwaysShowControls) {\n            if (mouseMoveTimerRef.current) {\n              clearTimeout(mouseMoveTimerRef.current);\n            }\n            mouseMoveTimerRef.current = setTimeout(() => {\n              setShowControls(false);\n            }, 10000);\n          }\n        },\n        children: [/*#__PURE__*/_jsxDEV(CallHeader, {\n          doctor: doctor,\n          callDuration: callDuration,\n          formatTime: formatTime,\n          showControls: showControls\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 953,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(ConnectionStatus, {\n          connectionQuality: connectionQuality,\n          showControls: showControls || connectionQuality !== 'good'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 960,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `absolute top-4 right-24 px-2 py-1 bg-green-500 bg-opacity-50 text-white text-xs rounded-full transition-opacity duration-300 ${showControls ? 'opacity-100' : 'opacity-50'}`,\n          style: {\n            zIndex: 500\n          },\n          children: \"Active\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 966,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 924,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(CallControls, {\n        isMuted: isMuted,\n        setIsMuted: setIsMuted,\n        isVideoOff: isVideoOff,\n        setIsVideoOff: toggleVideo,\n        isSpeakerOff: isSpeakerOff,\n        setIsSpeakerOff: setIsSpeakerOff,\n        handleEndCall: handleEndCall,\n        showControls: showControls,\n        colors: colors,\n        callStatus: callStatus,\n        resetControlsTimer: () => {\n          if (mouseMoveTimerRef.current) {\n            clearTimeout(mouseMoveTimerRef.current);\n          }\n          if (!alwaysShowControls) {\n            mouseMoveTimerRef.current = setTimeout(() => {\n              setShowControls(false);\n            }, 10000);\n          }\n        },\n        setShowControls: setShowControls\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 976,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 911,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 909,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCallScreen, \"tqEhuRnxDi76f4xoMBKRwEZxPRk=\", false, function () {\n  return [useTheme];\n});\n_c = VideoCallScreen;\nexport default VideoCallScreen;\nvar _c;\n$RefreshReg$(_c, \"VideoCallScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","CallControls","ConnectionStatus","CallHeader","ConnectingState","EndedState","VideoDisplay","Users","jsxDEV","_jsxDEV","VideoCallScreen","isOpen","onClose","colors","doctor","_s","_remoteVideoRef$curre4","isDarkMode","callStatus","setCallStatus","isMuted","setIsMuted","isVideoOff","setIsVideoOff","isSpeakerOff","setIsSpeakerOff","callDuration","setCallDuration","showControls","setShowControls","alwaysShowControls","setAlwaysShowControls","connectionQuality","setConnectionQuality","reconnectAttempt","setReconnectAttempt","errorMessage","setErrorMessage","streamReady","setStreamReady","forceActiveRef","endingCallRef","callEndedTimeRef","localVideoRef","remoteVideoRef","lastMoveTimeRef","callDurationTimer","stateCheckerInterval","stateCheckTimeouts","activeSinceRef","callStatusRef","mouseMoveTimerRef","endCheckIntervalRef","autoCloseTimerRef","current","log","message","console","_webRTCService$signal","socket","signalingService","handleDirectSocketCallEnded","synchronizedEndCall","on","off","reason","_localVideoRef$curren","_remoteVideoRef$curre","Date","now","srcObject","stream","getTracks","forEach","track","kind","stop","error","clearInterval","targetUserId","send","setTimeout","e","_webRTCService$signal2","emit","socketError","endCall","clearTimeout","_webRTCService$signal3","handleCallEndedEvent","unsubscribeDirectCallEnded","eventEmitter","handleSocketDisconnect","unsubscribeSocketDisconnect","_webRTCService$signal4","_webRTCService$signal5","setInterval","_webRTCService$connec","callState","peerConnection","connectionManager","connState","connectionState","iceState","iceConnectionState","disconnectedDuration","forceVideoStateCheck","_webRTCService$connec3","shouldSetActive","_webRTCService$connec2","remoteStream","play","catch","err","tracks","length","paused","isCallActive","_webRTCService$mediaM","mediaManager","localStream","muted","innerErr","videoTracks","getVideoTracks","enabled","toggleVideo","videoOff","hasLocalStream","toggleAlwaysShowControls","prevValue","newValue","localStorage","setItem","savedPreference","getItem","handleEndCall","name","handleLocalStream","callbacks","onLocalStream","onRemoteStream","prev","onCallStarted","onCallEnded","onICEConnectionStateChange","state","_webRTCService$connec4","_webRTCService$connec5","updateCallbacks","getLocalMedia","then","unsubscribeCallState","unsubscribeCallEnded","unsubscribeError","fatal","unsubscribeTrackAdded","handleUserActivity","window","addEventListener","lastTapTime","handleDoubleTap","DOUBLE_TAP_THRESHOLD","preventDefault","_localVideoRef$curren2","_remoteVideoRef$curre2","timeout","removeEventListener","toggleAudio","formatTime","seconds","mins","Math","floor","secs","toString","padStart","_remoteVideoRef$curre3","checkForTracks","handleCanPlay","handleLoadedMetadata","readyState","checkTimer","className","style","backgroundColor","backdropFilter","children","fileName","_jsxFileName","lineNumber","columnNumber","forceActiveState","onClick","zIndex","resetControlsTimer","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/screens/Connect/VideoCallScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport CallControls from './CallControls';\nimport ConnectionStatus from './ConnectionStatus'; \nimport CallHeader from './CallHeader';\nimport ConnectingState from './ConnectingState';\nimport EndedState from './EndedState';\nimport VideoDisplay from './VideoDisplay';\nimport { Users } from 'lucide-react';\n\nconst VideoCallScreen = ({ isOpen, onClose, colors, doctor }) => {\n  const { isDarkMode } = useTheme();\n  \n  // State variables\n  const [callStatus, setCallStatus] = useState('connecting'); // connecting, active, ended\n  const [isMuted, setIsMuted] = useState(false);\n  const [isVideoOff, setIsVideoOff] = useState(false);\n  const [isSpeakerOff, setIsSpeakerOff] = useState(false);\n  const [callDuration, setCallDuration] = useState(0);\n  const [showControls, setShowControls] = useState(true);\n  const [alwaysShowControls, setAlwaysShowControls] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState('good'); // good, poor, unstable\n  const [reconnectAttempt, setReconnectAttempt] = useState(0);\n  const [errorMessage, setErrorMessage] = useState('');\n  const [streamReady, setStreamReady] = useState(false);\n  \n  // Use refs for tracking state without triggering rerenders\n  const forceActiveRef = useRef(false);\n  const endingCallRef = useRef(false); // Track if we're in the process of ending call\n  const callEndedTimeRef = useRef(null); // Track when the call ended\n  \n  // Refs for video elements and timers\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  const lastMoveTimeRef = useRef(0);\n  const callDurationTimer = useRef(null);\n  const stateCheckerInterval = useRef(null);\n  const stateCheckTimeouts = useRef([]);\n  const activeSinceRef = useRef(null);\n  const callStatusRef = useRef('connecting');\n  const mouseMoveTimerRef = useRef(null);\n  const endCheckIntervalRef = useRef(null);\n  const autoCloseTimerRef = useRef(null);\n  \n  // Update the ref when state changes\n  useEffect(() => {\n    callStatusRef.current = callStatus;\n  }, [callStatus]);\n  \n  // Enhanced logging for debugging\n  const log = (message) => {\n    console.log(`[VideoCall] ${message}`);\n  };\n  \n  // CRITICAL FIX: Get direct access to the socket for better call-ended handling\n  useEffect(() => {\n    if (!isOpen) return;\n    \n    // Get direct access to the socket.io connection if available\n    const socket = webRTCService.signalingService?.socket;\n    if (!socket) {\n      log('Warning: No direct socket access available');\n      return;\n    }\n    \n    // Setup direct socket event listener for call-ended\n    const handleDirectSocketCallEnded = () => {\n      log('ðŸ”´ DIRECT SOCKET call-ended event received!');\n      synchronizedEndCall('socket event');\n    };\n    \n    // Add the event listener directly to the socket\n    socket.on('call-ended', handleDirectSocketCallEnded);\n    \n    // Track when this event listener was added\n    log('Added direct socket event listener for call-ended');\n    \n    return () => {\n      // Remove the event listener when component unmounts\n      if (socket) {\n        socket.off('call-ended', handleDirectSocketCallEnded);\n        log('Removed direct socket event listener for call-ended');\n      }\n    };\n  }, [isOpen]);\n  \n  // Create an enhanced synchronized end call function with reason tracking\n  const synchronizedEndCall = (reason = 'user action') => {\n    // Prevent multiple executions\n    if (endingCallRef.current) {\n      log(`Call already ending (ignored reason: ${reason})`);\n      return;\n    }\n    \n    log(`ðŸ”´ ENDING CALL - reason: ${reason}`);\n    endingCallRef.current = true;\n    callEndedTimeRef.current = Date.now();\n    \n    // 1. Immediately set local state to ended\n    setCallStatus('ended');\n    callStatusRef.current = 'ended';\n    \n    // 2. Stop media tracks immediately\n    if (localVideoRef.current?.srcObject) {\n      log('Stopping local video tracks');\n      try {\n        const stream = localVideoRef.current.srcObject;\n        stream.getTracks().forEach(track => {\n          log(`Stopping ${track.kind} track`);\n          track.stop();\n        });\n        localVideoRef.current.srcObject = null;\n      } catch (error) {\n        log(`Error stopping local tracks: ${error.message}`);\n      }\n    }\n    \n    // 3. Clean up remote video\n    if (remoteVideoRef.current?.srcObject) {\n      try {\n        remoteVideoRef.current.srcObject = null;\n      } catch (error) {\n        log(`Error clearing remote video: ${error.message}`);\n      }\n    }\n    \n    // 4. Clear call duration timer\n    if (callDurationTimer.current) {\n      clearInterval(callDurationTimer.current);\n      callDurationTimer.current = null;\n    }\n    \n    // 5. If endCall was triggered by the user (not by receiving an end event),\n    // send end-call signal to the other party multiple times for reliability\n    if (reason === 'user action' && webRTCService.signalingService && webRTCService.targetUserId) {\n      const targetUserId = webRTCService.targetUserId;\n      log(`Sending end-call signals to ${targetUserId}`);\n      \n      // CRITICAL: Send via multiple methods for maximum reliability\n      \n      // Method 1: Use the signaling service's send method (most reliable)\n      try {\n        webRTCService.signalingService.send('end-call', { targetUserId });\n        \n        // Send additional signals with delays for redundancy\n        setTimeout(() => {\n          try {\n            webRTCService.signalingService.send('end-call', { targetUserId });\n            log('Sent second end-call signal');\n          } catch (e) {\n            log(`Error sending second end-call signal: ${e.message}`);\n          }\n        }, 300);\n        \n        setTimeout(() => {\n          try {\n            webRTCService.signalingService.send('end-call', { targetUserId });\n            log('Sent third end-call signal');\n          } catch (e) {\n            log(`Error sending third end-call signal: ${e.message}`);\n          }\n        }, 800);\n      } catch (error) {\n        log(`Error sending primary end-call signal: ${error.message}`);\n      }\n      \n      // Method 2: If direct socket access is available, emit the event directly\n      // This bypasses any potential issues in the signaling service\n      try {\n        const socket = webRTCService.signalingService?.socket;\n        if (socket) {\n          socket.emit('end-call', { targetUserId });\n          log('Sent direct socket end-call event');\n        }\n      } catch (socketError) {\n        log(`Error with direct socket emit: ${socketError.message}`);\n      }\n    }\n    \n    // 6. Tell WebRTCService to end the call (but don't send another notification)\n    try {\n      webRTCService.endCall(false);\n    } catch (error) {\n      log(`Error ending call in WebRTCService: ${error.message}`);\n    }\n    \n    // 7. Schedule UI close after a fixed delay (2 seconds)\n    if (autoCloseTimerRef.current) {\n      clearTimeout(autoCloseTimerRef.current);\n    }\n    \n    autoCloseTimerRef.current = setTimeout(() => {\n      log('Auto-closing call UI after ended state');\n      onClose();\n    }, 2000);\n  };\n\n  // When call becomes active, ensure controls are visible and reset timer\n  useEffect(() => {\n    if (callStatus === 'active') {\n      setShowControls(true);\n      \n      if (mouseMoveTimerRef.current) {\n        clearTimeout(mouseMoveTimerRef.current);\n      }\n      \n      mouseMoveTimerRef.current = setTimeout(() => {\n        if (!alwaysShowControls) {\n          setShowControls(false);\n        }\n      }, 15000);\n    }\n  }, [callStatus, alwaysShowControls]);\n\n  // NEW: Add more direct event listeners for call-ended event\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleCallEndedEvent = () => {\n      log('WebRTCService emitted call-ended event - ending call');\n      synchronizedEndCall('event emitter');\n    };\n\n    // Add listener to WebRTCService's event emitter\n    const unsubscribeDirectCallEnded = webRTCService.eventEmitter.on('call-ended', handleCallEndedEvent);\n    \n    // Also listen for socket disconnect as a potential signal of call end\n    const handleSocketDisconnect = () => {\n      if (callStatusRef.current !== 'ended' && callStatusRef.current !== 'connecting') {\n        log('Socket disconnected while call was active - ending call');\n        synchronizedEndCall('socket disconnect');\n      }\n    };\n    \n    // Try to subscribe to socket disconnect events if available\n    let unsubscribeSocketDisconnect = () => {};\n    if (webRTCService.signalingService?.socket) {\n      webRTCService.signalingService.socket.on('disconnect', handleSocketDisconnect);\n      unsubscribeSocketDisconnect = () => {\n        webRTCService.signalingService?.socket?.off('disconnect', handleSocketDisconnect);\n      };\n    }\n    \n    // Regular check to detect if WebRTCService's call state is ended\n    endCheckIntervalRef.current = setInterval(() => {\n      // Check if WebRTCService thinks the call has ended\n      if (callStatusRef.current !== 'ended' && webRTCService.callState === 'ended') {\n        log('WebRTCService call state is \"ended\" but UI hasn\\'t updated - ending call');\n        synchronizedEndCall('service state check');\n      }\n      \n      // Also check peer connection states\n      const peerConnection = webRTCService.connectionManager?.peerConnection;\n      if (peerConnection) {\n        const connState = peerConnection.connectionState;\n        const iceState = peerConnection.iceConnectionState;\n        \n        // If connection completely failed or closed\n        if ((connState === 'closed' || connState === 'failed') && callStatusRef.current !== 'ended') {\n          log(`Peer connection is in ${connState} state - ending call`);\n          synchronizedEndCall('peer connection failure');\n        }\n        \n        // If ICE connection failed\n        if (iceState === 'failed' && callStatusRef.current !== 'ended') {\n          log('ICE connection failed - ending call');\n          synchronizedEndCall('ice failure');\n        }\n        \n        // If connection is disconnected for too long\n        if (connState === 'disconnected') {\n          const disconnectedDuration = Date.now() - lastMoveTimeRef.current;\n          if (disconnectedDuration > 5000 && callStatusRef.current !== 'ended') {\n            log(`Connection disconnected for ${disconnectedDuration}ms - ending call`);\n            synchronizedEndCall('disconnection timeout');\n          }\n        }\n      }\n    }, 1000);\n    \n    return () => {\n      if (typeof unsubscribeDirectCallEnded === 'function') {\n        unsubscribeDirectCallEnded();\n      }\n      \n      unsubscribeSocketDisconnect();\n      \n      if (endCheckIntervalRef.current) {\n        clearInterval(endCheckIntervalRef.current);\n        endCheckIntervalRef.current = null;\n      }\n    };\n  }, [isOpen, onClose]);\n  \n  // Force check and update UI state\n  const forceVideoStateCheck = () => {\n    if (callStatusRef.current === 'ended') return;\n    \n    let shouldSetActive = false;\n    \n    // Check remote video stream\n    if (remoteVideoRef.current) {\n      if (!remoteVideoRef.current.srcObject && webRTCService.connectionManager?.remoteStream) {\n        log('Attaching remote stream to video element');\n        remoteVideoRef.current.srcObject = webRTCService.connectionManager.remoteStream;\n        \n        try {\n          remoteVideoRef.current.play().catch(e => {\n            log(`Remote video play error: ${e.message}`);\n          });\n        } catch (err) {\n          log(`Error playing remote video: ${err.message}`);\n        }\n        \n        shouldSetActive = true;\n      }\n      \n      if (remoteVideoRef.current.srcObject) {\n        const tracks = remoteVideoRef.current.srcObject.getTracks();\n        if (tracks.length > 0) {\n          shouldSetActive = true;\n          \n          if (remoteVideoRef.current.paused) {\n            remoteVideoRef.current.play().catch(e => {\n              log(`Auto-play failed: ${e.message}`);\n            });\n          }\n        }\n      }\n    }\n    \n    if (webRTCService.isCallActive() && callStatusRef.current !== 'active') {\n      shouldSetActive = true;\n    }\n    \n    if (webRTCService.connectionManager?.remoteStream) {\n      if (remoteVideoRef.current && \n          remoteVideoRef.current.srcObject !== webRTCService.connectionManager.remoteStream) {\n        remoteVideoRef.current.srcObject = webRTCService.connectionManager.remoteStream;\n        \n        try {\n          remoteVideoRef.current.play().catch(e => {\n            log(`Remote video play error: ${e.message}`);\n          });\n        } catch (err) {\n          log(`Error playing remote video: ${err.message}`);\n        }\n      }\n      \n      shouldSetActive = true;\n    }\n    \n    if (!activeSinceRef.current && callStatusRef.current === 'active') {\n      activeSinceRef.current = Date.now();\n    }\n    \n    if (activeSinceRef.current && (Date.now() - activeSinceRef.current > 5000)) {\n      forceActiveRef.current = true;\n    }\n    \n    if (shouldSetActive && callStatusRef.current !== 'active') {\n      setCallStatus('active');\n      setStreamReady(true);\n      setShowControls(true);\n    }\n  \n    // Handle local video\n    if (localVideoRef.current) {\n      if (!localVideoRef.current.srcObject && webRTCService.mediaManager?.localStream) {\n        localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n        \n        try {\n          localVideoRef.current.play().catch(e => {\n            log(`Local play error: ${e.message}`);\n            localVideoRef.current.muted = true;\n            localVideoRef.current.play().catch(innerErr => {\n              log(`Local muted play also failed: ${innerErr.message}`);\n            });\n          });\n        } catch (err) {\n          log(`Error during local play: ${err.message}`);\n        }\n      } else if (localVideoRef.current.srcObject) {\n        const videoTracks = localVideoRef.current.srcObject.getVideoTracks();\n        if (videoTracks.length > 0) {\n          videoTracks.forEach(track => {\n            if (!isVideoOff && !track.enabled) {\n              track.enabled = true;\n            }\n          });\n        }\n      }\n    }  \n  };\n  \n  // Function to safely toggle video state\n  const toggleVideo = (videoOff) => {\n    log(`Toggle video: ${videoOff}`);\n    setIsVideoOff(videoOff);\n    \n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleVideo(videoOff);\n    }\n  };\n  \n  // Toggle always showing controls\n  const toggleAlwaysShowControls = () => {\n    try {\n      setAlwaysShowControls(prevValue => {\n        const newValue = !prevValue;\n        \n        if (newValue) {\n          setShowControls(true);\n          \n          if (mouseMoveTimerRef.current) {\n            clearTimeout(mouseMoveTimerRef.current);\n            mouseMoveTimerRef.current = null;\n          }\n        }\n        \n        try {\n          localStorage.setItem('always_show_controls', newValue ? 'true' : 'false');\n        } catch (e) {\n          // Ignore storage errors\n        }\n        \n        return newValue;\n      });\n    } catch (err) {\n      console.error('Error in toggleAlwaysShowControls:', err);\n    }\n  };\n  \n  // Load saved preference for always showing controls\n  useEffect(() => {\n    try {\n      const savedPreference = localStorage.getItem('always_show_controls');\n      if (savedPreference === 'true') {\n        setAlwaysShowControls(true);\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n  }, []);\n  \n  // Handle ending call using the synchronized end function\n  const handleEndCall = () => {\n    log('User initiated call end');\n    synchronizedEndCall('user action');\n  };\n  \n  // Initialize WebRTC when component mounts\n  useEffect(() => {\n    if (!isOpen || !doctor) return;\n    \n    log(`Opening call with ${doctor.name}`);\n    endingCallRef.current = false; // Reset ending call flag\n    callEndedTimeRef.current = null;\n    activeSinceRef.current = null;\n    forceActiveRef.current = false;\n    \n    // Reset state when opening\n    setCallStatus('connecting');\n    callStatusRef.current = 'connecting';\n    setStreamReady(false);\n    \n    // Define handleLocalStream function first before using in callbacks\n    const handleLocalStream = (stream) => {\n      log(`Got local stream with ${stream.getTracks().length} tracks`);\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n        log('Set local video source');\n        \n        try {\n          localVideoRef.current.play().catch(err => {\n            log(`Local video play error: ${err.message}`);\n          });\n        } catch (err) {\n          log(`Error playing local video: ${err.message}`);\n        }\n        \n        setTimeout(() => {\n          if (localVideoRef.current) {\n            if (!localVideoRef.current.srcObject) {\n              localVideoRef.current.srcObject = stream;\n            }\n            \n            if (localVideoRef.current.paused) {\n              localVideoRef.current.play().catch(e => log(`Error: ${e.message}`));\n            }\n          }\n        }, 1000);\n      }\n    };\n    \n    // Set up callbacks\n    const callbacks = {\n      onLocalStream: handleLocalStream,\n      \n      onRemoteStream: (stream) => {\n        log(`Got remote stream with ${stream.getTracks().length} tracks`);\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.srcObject = stream;\n          remoteVideoRef.current.muted = isSpeakerOff;\n          log('Set remote video source');\n          \n          setStreamReady(true);\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          \n          try {\n            remoteVideoRef.current.play().catch(err => {\n              log(`Initial play failed: ${err.message}`);\n            });\n          } catch (err) {\n            log(`Error during initial play: ${err.message}`);\n          }\n          \n          if (callDurationTimer.current) {\n            clearInterval(callDurationTimer.current);\n          }\n          \n          callDurationTimer.current = setInterval(() => {\n            setCallDuration(prev => prev + 1);\n          }, 1000);\n        }\n      },\n      \n      onCallStarted: () => {\n        log('Call started callback fired');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setReconnectAttempt(0);\n        setErrorMessage('');\n        setShowControls(true);\n        \n        if (!callDurationTimer.current) {\n          callDurationTimer.current = setInterval(() => {\n            setCallDuration(prev => prev + 1);\n          }, 1000);\n        }\n      },\n      \n      onCallEnded: () => {\n        log('Call ended callback fired');\n        synchronizedEndCall('callback');\n      },\n      \n      onICEConnectionStateChange: (state) => {\n        log(`ICE connection state changed to: ${state}`);\n        \n        if (state === 'checking') {\n          setConnectionQuality('unstable');\n        } else if (state === 'connected' || state === 'completed') {\n          setConnectionQuality('good');\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          setShowControls(true);\n        } else if (state === 'disconnected') {\n          setConnectionQuality('poor');\n          setReconnectAttempt(prev => prev + 1);\n          setShowControls(true);\n          \n          // Start tracking potential disconnection\n          lastMoveTimeRef.current = Date.now();\n        } else if (state === 'failed') {\n          setConnectionQuality('unstable');\n          setReconnectAttempt(prev => prev + 1);\n          setShowControls(true);\n          \n          // If complete failure, end call after short delay\n          setTimeout(() => {\n            if (callStatusRef.current !== 'ended' && \n                webRTCService.connectionManager?.peerConnection?.iceConnectionState === 'failed') {\n              log('ICE connection failed, forcing ended state');\n              synchronizedEndCall('ice failure timeout');\n            }\n          }, 5000);\n        }\n      }\n    };\n    \n    // Register callbacks\n    webRTCService.updateCallbacks(callbacks);\n    \n    // Ensure we have local media\n    if (!webRTCService.mediaManager.hasLocalStream()) {\n      log('Requesting camera and microphone access');\n      webRTCService.getLocalMedia(true, true)\n        .then(stream => {\n          log(`Local media access granted with ${stream.getTracks().length} tracks`);\n          if (localVideoRef.current) {\n            localVideoRef.current.srcObject = stream;\n            localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n          }\n        })\n        .catch(error => {\n          log(`Media access error: ${error.message}`);\n          setErrorMessage(`Camera/mic access failed: ${error.message}`);\n        });\n    } else {\n      const stream = webRTCService.mediaManager.localStream;\n      log(`Using existing local stream with ${stream.getTracks().length} tracks`);\n      if (localVideoRef.current) {\n        localVideoRef.current.srcObject = stream;\n        localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n      }\n    }\n    \n    // Set up state checker at regular intervals\n    stateCheckerInterval.current = setInterval(() => {\n      forceVideoStateCheck();\n    }, 1000);\n    \n    // Add specific timeouts for critical checks\n    stateCheckTimeouts.current = [\n      setTimeout(() => forceVideoStateCheck(), 2000),\n      setTimeout(() => forceVideoStateCheck(), 5000),\n      setTimeout(() => forceVideoStateCheck(), 8000),\n      setTimeout(() => {\n        if (callStatusRef.current === 'connecting') {\n          log('10 seconds passed, forcing active state');\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          forceActiveRef.current = true;\n          setShowControls(true);\n        }\n      }, 10000)\n    ];\n    \n    // Listen for call state changes\n    const unsubscribeCallState = webRTCService.on('callStateChanged', (state) => {\n      log(`Call state event: ${state}, current UI state: ${callStatusRef.current}`);\n      \n      if (state === 'ended') {\n        log('Call ended event received via state change');\n        synchronizedEndCall('state change');\n      } \n    });\n    \n    // Listen for direct call-ended event\n    const unsubscribeCallEnded = webRTCService.on('call-ended', () => {\n      log('Direct call-ended event received via event subscription');\n      synchronizedEndCall('direct event');\n    });\n    \n    // Listen for errors\n    const unsubscribeError = webRTCService.on('error', (error) => {\n      log(`WebRTC error: ${error.message}`);\n      setErrorMessage(error.message || 'Call error');\n      setShowControls(true);\n      \n      if (error.fatal) {\n        synchronizedEndCall('fatal error');\n      }\n    });\n    \n    // Listen for remote tracks added\n    const unsubscribeTrackAdded = webRTCService.on('remoteTrackAdded', () => {\n      log('Remote track added event received');\n      setCallStatus('active');\n      callStatusRef.current = 'active';\n      setStreamReady(true);\n      setShowControls(true);\n    });\n    \n    // Set up mouse movement tracker for controls\n    const handleUserActivity = () => {\n      const now = Date.now();\n      if (now - lastMoveTimeRef.current > 150) {\n        lastMoveTimeRef.current = now;\n        \n        if (!showControls) {\n          setShowControls(true);\n        }\n        \n        if (!alwaysShowControls) {\n          clearTimeout(mouseMoveTimerRef.current);\n          mouseMoveTimerRef.current = setTimeout(() => {\n            setShowControls(false);\n          }, 10000);\n        }\n      }\n    };\n    \n    window.addEventListener('mousemove', handleUserActivity);\n    window.addEventListener('touchstart', handleUserActivity);\n    \n    // Double-tap handler\n    let lastTapTime = 0;\n    const handleDoubleTap = (e) => {\n      const now = Date.now();\n      const DOUBLE_TAP_THRESHOLD = 300;\n      \n      if (now - lastTapTime < DOUBLE_TAP_THRESHOLD) {\n        toggleAlwaysShowControls();\n        e.preventDefault();\n      }\n      \n      lastTapTime = now;\n    };\n    \n    window.addEventListener('touchend', handleDoubleTap);\n    \n    // Force active after a delay\n    setTimeout(() => {\n      if (webRTCService.isCallActive()) {\n        log('Force activating call after delay');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setShowControls(true);\n      }\n    }, 1000);\n    \n    // Clean up\n    return () => {\n      log('Cleaning up call resources');\n      \n      unsubscribeCallState();\n      unsubscribeError();\n      unsubscribeTrackAdded();\n      unsubscribeCallEnded();\n      \n      if (stateCheckerInterval.current) {\n        clearInterval(stateCheckerInterval.current);\n        stateCheckerInterval.current = null;\n      }\n      \n      if (endCheckIntervalRef.current) {\n        clearInterval(endCheckIntervalRef.current);\n        endCheckIntervalRef.current = null;\n      }\n      \n      if (autoCloseTimerRef.current) {\n        clearTimeout(autoCloseTimerRef.current);\n        autoCloseTimerRef.current = null;\n      }\n      \n      stateCheckTimeouts.current.forEach(timeout => clearTimeout(timeout));\n      stateCheckTimeouts.current = [];\n      \n      window.removeEventListener('mousemove', handleUserActivity);\n      window.removeEventListener('touchstart', handleUserActivity);\n      window.removeEventListener('touchend', handleDoubleTap);\n      \n      if (mouseMoveTimerRef.current) {\n        clearTimeout(mouseMoveTimerRef.current);\n      }\n      \n      if (callDurationTimer.current) {\n        clearInterval(callDurationTimer.current);\n        callDurationTimer.current = null;\n      }\n      \n      // Clean up video elements\n      if (localVideoRef.current?.srcObject) {\n        const stream = localVideoRef.current.srcObject;\n        stream.getTracks().forEach(track => track.stop());\n        localVideoRef.current.srcObject = null;\n      }\n      \n      if (remoteVideoRef.current?.srcObject) {\n        remoteVideoRef.current.srcObject = null;\n      }\n      \n      // End the call\n      webRTCService.endCall(true);\n    };\n  }, [isOpen, doctor, onClose, alwaysShowControls]);\n  \n  // Update WebRTC when audio mute state changes\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleAudio(isMuted);\n    }\n  }, [isMuted]);\n\n  // Call duration timer based on active status\n  useEffect(() => {\n    if (callStatus === 'active' && !callDurationTimer.current) {\n      log('Starting call duration timer based on active call status');\n      callDurationTimer.current = setInterval(() => {\n        setCallDuration(prev => prev + 1);\n      }, 1000);\n    }\n    \n    return () => {\n      if (callDurationTimer.current && callStatus !== 'active') {\n        clearInterval(callDurationTimer.current);\n        callDurationTimer.current = null;\n      }\n    };\n  }, [callStatus]);\n  \n  // Update remote video muted state when isSpeakerOff changes\n  useEffect(() => {\n    if (remoteVideoRef.current) {\n      remoteVideoRef.current.muted = isSpeakerOff;\n    }\n  }, [isSpeakerOff]);\n  \n  // Update WebRTC when video state changes\n  useEffect(() => {\n    if (webRTCService && webRTCService.mediaManager.hasLocalStream()) {\n      webRTCService.toggleVideo(isVideoOff);\n    }\n  }, [isVideoOff]);\n  \n  // Format seconds to MM:SS\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n  \n  // Additional effect to handle active state when remote video is detected\n  useEffect(() => {\n    if (remoteVideoRef.current?.srcObject) {\n      const checkForTracks = () => {\n        const tracks = remoteVideoRef.current.srcObject.getTracks();\n        if (tracks.length > 0) {\n          log(`Remote video has ${tracks.length} tracks, forcing active state`);\n          setCallStatus('active');\n          callStatusRef.current = 'active';\n          setStreamReady(true);\n          setShowControls(true);\n          return true;\n        }\n        return false;\n      };\n      \n      if (checkForTracks()) return;\n      \n      const handleCanPlay = () => {\n        log('Remote video can play event fired');\n        setStreamReady(true);\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        setShowControls(true);\n      };\n      \n      const handleLoadedMetadata = () => {\n        log('Remote video loadedmetadata event fired');\n        checkForTracks();\n      };\n      \n      remoteVideoRef.current.addEventListener('canplay', handleCanPlay);\n      remoteVideoRef.current.addEventListener('loadedmetadata', handleLoadedMetadata);\n      \n      if (remoteVideoRef.current.readyState >= 3) {\n        remoteVideoRef.current.play().catch(e => {\n          log('Error auto-playing video: ' + e.message);\n        });\n      }\n      \n      return () => {\n        if (remoteVideoRef.current) {\n          remoteVideoRef.current.removeEventListener('canplay', handleCanPlay);\n          remoteVideoRef.current.removeEventListener('loadedmetadata', handleLoadedMetadata);\n        }\n      };\n    }\n  }, [remoteVideoRef.current?.srcObject]);\n  \n  // Force active state after a timeout\n  useEffect(() => {\n    if (callStatus === 'connecting') {\n      const timeout = setTimeout(() => {\n        log('Timeout reached, forcing active state');\n        setCallStatus('active');\n        callStatusRef.current = 'active';\n        forceActiveRef.current = true;\n        setShowControls(true);\n      }, 15000);\n      \n      return () => clearTimeout(timeout);\n    }\n  }, [callStatus]);\n  \n  // Ensure local video is displayed\n  useEffect(() => {\n    if (isOpen && localVideoRef.current) {\n      if (webRTCService.mediaManager.hasLocalStream() && !localVideoRef.current.srcObject) {\n        log('Connecting existing local stream to video element');\n        localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n        \n        localVideoRef.current.play().catch(err => {\n          log(`Failed to play local video: ${err.message}`);\n        });\n      }\n      \n      const checkTimer = setTimeout(() => {\n        if (webRTCService.mediaManager.hasLocalStream() && \n            (!localVideoRef.current.srcObject || localVideoRef.current.paused)) {\n          log('Delayed local video check - reconnecting stream');\n          localVideoRef.current.srcObject = webRTCService.mediaManager.localStream;\n          localVideoRef.current.play().catch(e => log(`Play error: ${e.message}`));\n        }\n      }, 2000);\n      \n      return () => clearTimeout(checkTimer);\n    }\n  }, [isOpen, callStatus]);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center\"\n         style={{ backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(10px)' }}>\n      <div className=\"w-full h-full max-w-md relative overflow-hidden\">\n        {callStatus === 'ended' ? (\n          <EndedState \n            doctor={doctor}\n            errorMessage={errorMessage} \n            callDuration={callDuration} \n            formatTime={formatTime}\n            colors={colors}\n            isDarkMode={isDarkMode}\n          />\n        ) : callStatus === 'connecting' ? (\n          <ConnectingState doctor={doctor} colors={colors} />\n        ) : (\n          <VideoDisplay\n            remoteVideoRef={remoteVideoRef}\n            localVideoRef={localVideoRef}\n            isSpeakerOff={isSpeakerOff}\n            isVideoOff={isVideoOff}\n            doctor={doctor}\n            connectionQuality={connectionQuality}\n            reconnectAttempt={reconnectAttempt}\n            showControls={showControls}\n            isDarkMode={isDarkMode}\n            colors={colors}\n            callStatus={callStatus}\n            forceActiveState={forceActiveRef.current}\n            onClick={() => {\n              // Toggle controls on video click\n              setShowControls(prev => !prev);\n              \n              // Reset hide timer if showing controls\n              if (!showControls && !alwaysShowControls) {\n                if (mouseMoveTimerRef.current) {\n                  clearTimeout(mouseMoveTimerRef.current);\n                }\n                mouseMoveTimerRef.current = setTimeout(() => {\n                  setShowControls(false);\n                }, 10000);\n              }\n            }}\n          >\n            {/* Render header and connection status inside VideoDisplay */}\n            <CallHeader \n              doctor={doctor}\n              callDuration={callDuration}\n              formatTime={formatTime}\n              showControls={showControls}\n            />\n            \n            <ConnectionStatus\n              connectionQuality={connectionQuality}\n              showControls={showControls || connectionQuality !== 'good'}\n            />\n            \n            {/* Active call visual indicator */}\n            <div \n              className={`absolute top-4 right-24 px-2 py-1 bg-green-500 bg-opacity-50 text-white text-xs rounded-full transition-opacity duration-300 ${showControls ? 'opacity-100' : 'opacity-50'}`}\n              style={{ zIndex: 500 }}\n            >\n              Active\n            </div>\n          </VideoDisplay>\n        )}\n        \n        {/* Controls */}\n        <CallControls\n          isMuted={isMuted}\n          setIsMuted={setIsMuted}\n          isVideoOff={isVideoOff}\n          setIsVideoOff={toggleVideo} \n          isSpeakerOff={isSpeakerOff}\n          setIsSpeakerOff={setIsSpeakerOff}\n          handleEndCall={handleEndCall}\n          showControls={showControls}\n          colors={colors}\n          callStatus={callStatus}\n          resetControlsTimer={() => {\n            if (mouseMoveTimerRef.current) {\n              clearTimeout(mouseMoveTimerRef.current);\n            }\n            if (!alwaysShowControls) {\n              mouseMoveTimerRef.current = setTimeout(() => {\n                setShowControls(false);\n              }, 10000);\n            }\n          }}\n          setShowControls={setShowControls}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default VideoCallScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}