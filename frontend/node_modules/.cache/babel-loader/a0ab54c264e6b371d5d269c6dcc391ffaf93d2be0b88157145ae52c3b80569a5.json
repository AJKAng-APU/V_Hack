{"ast":null,"code":"/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n  constructor(logger) {\n    this.logger = logger;\n    this.localStream = null;\n    this.callbacks = {\n      onLocalStream: null\n    };\n  }\n\n  /**\n   * Set callbacks\n   * @param {object} callbacks - Callback functions\n   */\n  setCallbacks(callbacks) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n  }\n\n  /**\n   * Check if local stream is available\n   * @returns {boolean} - Whether local stream is available\n   */\n  hasLocalStream() {\n    return !!this.localStream;\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      this.logger.log('Requesting access to local media with constraints:', {\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n\n      // Request access to camera and microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints,\n        audio: audioConstraints\n      });\n      this.logger.log('Access to local media granted');\n      this.localStream = stream;\n      if (this.callbacks.onLocalStream) {\n        this.callbacks.onLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      // Classify and handle errors more specifically\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        throw new Error('Camera or microphone access was denied');\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        throw new Error('No camera or microphone found');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        this.logger.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n        track.enabled = !videoOff;\n      });\n    }\n  }\n\n  /**\n   * Stop all tracks in the local stream\n   */\n  stopLocalStream() {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        this.logger.log('Stopping track:', track.kind);\n        track.stop();\n      });\n      this.localStream = null;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    this.stopLocalStream();\n  }\n}\nexport default WebRTCMediaManager;","map":{"version":3,"names":["WebRTCMediaManager","constructor","logger","localStream","callbacks","onLocalStream","setCallbacks","hasLocalStream","getLocalMedia","videoConstraints","audioConstraints","log","video","audio","stream","navigator","mediaDevices","getUserMedia","error","name","Error","toggleAudio","muted","getAudioTracks","forEach","track","enabled","toggleVideo","videoOff","getVideoTracks","stopLocalStream","getTracks","kind","stop","cleanup"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCMediaManager.js"],"sourcesContent":["/**\n * Manages media streams for WebRTC\n */\nclass WebRTCMediaManager {\n    constructor(logger) {\n      this.logger = logger;\n      this.localStream = null;\n      this.callbacks = {\n        onLocalStream: null\n      };\n    }\n    \n    /**\n     * Set callbacks\n     * @param {object} callbacks - Callback functions\n     */\n    setCallbacks(callbacks) {\n      this.callbacks = {\n        ...this.callbacks,\n        ...callbacks\n      };\n    }\n    \n    /**\n     * Check if local stream is available\n     * @returns {boolean} - Whether local stream is available\n     */\n    hasLocalStream() {\n      return !!this.localStream;\n    }\n    \n    /**\n     * Get access to local camera and microphone\n     * @param {boolean|object} videoConstraints - Constraints for video\n     * @param {boolean|object} audioConstraints - Constraints for audio\n     * @returns {Promise<MediaStream>} - Local media stream\n     */\n    async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n      try {\n        this.logger.log('Requesting access to local media with constraints:', {\n          video: videoConstraints,\n          audio: audioConstraints\n        });\n        \n        // Request access to camera and microphone\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: videoConstraints,\n          audio: audioConstraints\n        });\n        \n        this.logger.log('Access to local media granted');\n        \n        this.localStream = stream;\n        if (this.callbacks.onLocalStream) {\n          this.callbacks.onLocalStream(stream);\n        }\n        return stream;\n      } catch (error) {\n        // Classify and handle errors more specifically\n        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n          throw new Error('Camera or microphone access was denied');\n        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n          throw new Error('No camera or microphone found');\n        } else {\n          throw error;\n        }\n      }\n    }\n    \n    /**\n     * Toggle audio mute state\n     * @param {boolean} muted - Whether to mute audio\n     */\n    toggleAudio(muted) {\n      if (this.localStream) {\n        this.localStream.getAudioTracks().forEach(track => {\n          this.logger.log(muted ? 'Muting audio' : 'Unmuting audio');\n          track.enabled = !muted;\n        });\n      }\n    }\n    \n    /**\n     * Toggle video on/off\n     * @param {boolean} videoOff - Whether to turn off video\n     */\n    toggleVideo(videoOff) {\n      if (this.localStream) {\n        this.localStream.getVideoTracks().forEach(track => {\n          this.logger.log(videoOff ? 'Turning off camera' : 'Turning on camera');\n          track.enabled = !videoOff;\n        });\n      }\n    }\n    \n    /**\n     * Stop all tracks in the local stream\n     */\n    stopLocalStream() {\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.logger.log('Stopping track:', track.kind);\n          track.stop();\n        });\n        this.localStream = null;\n      }\n    }\n    \n    /**\n     * Clean up resources\n     */\n    cleanup() {\n      this.stopLocalStream();\n    }\n  }\n  \n  export default WebRTCMediaManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}