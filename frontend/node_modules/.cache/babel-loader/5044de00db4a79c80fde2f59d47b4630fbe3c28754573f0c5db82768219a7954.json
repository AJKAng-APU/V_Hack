{"ast":null,"code":"class SignalingService {\n  constructor(errorHandler, logger) {\n    this.errorHandler = errorHandler;\n    this.logger = logger;\n    this.socket = null;\n    this.connected = false;\n    this.userId = null;\n    this.eventHandler = null;\n    this.configService = new ConfigService();\n  }\n  connect(userId, eventHandler) {\n    this.userId = userId;\n    this.eventHandler = eventHandler;\n    try {\n      const serverUrl = this.configService.getSignalingServerUrl();\n      this.logger.log(`Connecting to signaling server at ${serverUrl} with user ID ${userId}`);\n\n      // Import socket.io-client dynamically to avoid server-side issues\n      import('socket.io-client').then(io => {\n        this.socket = io.default(serverUrl);\n        this.setupSocketListeners();\n      }).catch(err => {\n        this.errorHandler.handleSignalingError(new Error(`Failed to import socket.io client: ${err.message}`), true);\n      });\n    } catch (error) {\n      this.errorHandler.handleSignalingError(new Error(`Failed to connect to signaling server: ${error.message}`), true);\n    }\n  }\n  setupSocketListeners() {\n    if (!this.socket) return;\n\n    // Handle connection events\n    this.socket.on('connect', () => {\n      this.logger.log('Connected to signaling server');\n      this.connected = true;\n\n      // Register user ID with the signaling server\n      this.socket.emit('register', this.userId);\n    });\n    this.socket.on('disconnect', () => {\n      this.logger.log('Disconnected from signaling server');\n      this.connected = false;\n    });\n\n    // Set up event listeners for signaling messages\n    const events = ['incoming-call', 'call-answered', 'call-declined', 'call-in-progress', 'ice-candidate', 'call-ended', 'call-failed', 'user-online', 'user-offline', 'user-online-status', 'media-connected'];\n    events.forEach(event => {\n      this.socket.on(event, data => {\n        if (this.eventHandler) {\n          this.eventHandler(event, data);\n        }\n      });\n    });\n\n    // Setup socket configuration for reliability\n    if (this.socket.io) {\n      this.socket.io.reconnection(true);\n      this.socket.io.reconnectionAttempts(10);\n      this.socket.io.reconnectionDelay(1000);\n      this.socket.io.timeout(10000);\n    }\n  }\n\n  /**\n   * Send a message to the signaling server\n   * @param {string} event - Event name\n   * @param {Object} data - Event data\n   */\n  send(event, data) {\n    if (this.connected && this.socket) {\n      this.socket.emit(event, data);\n    } else {\n      this.logger.error(`Cannot send message '${event}', not connected to signaling server`);\n      setTimeout(() => {\n        if (this.connected && this.socket) {\n          this.logger.log(`Retrying message '${event}' after delay`);\n          this.socket.emit(event, data);\n        }\n      }, 1000);\n    }\n  }\n\n  /**\n   * Check if a user is online\n   * @param {string} userId - User ID to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    return new Promise(resolve => {\n      if (!this.connected || !this.socket) {\n        resolve(false);\n        return;\n      }\n\n      // Create a unique request ID to match the response\n      const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      this.logger.log('Checking if user is online:', userId, 'with requestId:', requestId);\n      this.socket.emit('check-user-online', {\n        userId,\n        requestId\n      });\n\n      // Set up a one-time event listener for the response\n      const responseHandler = data => {\n        if (data.responseId === requestId && data.userId === userId) {\n          this.socket.off('user-online-status', responseHandler);\n          clearTimeout(timeoutId);\n          resolve(data.isOnline);\n        }\n      };\n      this.socket.on('user-online-status', responseHandler);\n\n      // Set a timeout in case we never get a response\n      const timeoutId = setTimeout(() => {\n        this.socket.off('user-online-status', responseHandler);\n        this.logger.log('User online check timed out for:', userId);\n        resolve(false);\n      }, 5000);\n    });\n  }\n\n  /**\n   * Check if connected to the signaling server\n   * @returns {boolean} - Whether connected\n   */\n  isConnected() {\n    return this.connected;\n  }\n\n  /**\n   * Disconnect from the signaling server\n   */\n  disconnect() {\n    if (this.connected && this.socket) {\n      this.socket.disconnect();\n      this.connected = false;\n    }\n  }\n}","map":{"version":3,"names":["SignalingService","constructor","errorHandler","logger","socket","connected","userId","eventHandler","configService","ConfigService","connect","serverUrl","getSignalingServerUrl","log","then","io","default","setupSocketListeners","catch","err","handleSignalingError","Error","message","error","on","emit","events","forEach","event","data","reconnection","reconnectionAttempts","reconnectionDelay","timeout","send","setTimeout","checkUserOnline","Promise","resolve","requestId","Date","now","Math","random","toString","substring","responseHandler","responseId","off","clearTimeout","timeoutId","isOnline","isConnected","disconnect"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/SignalingService.js"],"sourcesContent":["class SignalingService {\n  constructor(errorHandler, logger) {\n    this.errorHandler = errorHandler;\n    this.logger = logger;\n    this.socket = null;\n    this.connected = false;\n    this.userId = null;\n    this.eventHandler = null;\n    this.configService = new ConfigService();\n  }\n  \n  connect(userId, eventHandler) {\n    this.userId = userId;\n    this.eventHandler = eventHandler;\n    \n    try {\n      const serverUrl = this.configService.getSignalingServerUrl();\n      this.logger.log(`Connecting to signaling server at ${serverUrl} with user ID ${userId}`);\n      \n      // Import socket.io-client dynamically to avoid server-side issues\n      import('socket.io-client').then(io => {\n        this.socket = io.default(serverUrl);\n        this.setupSocketListeners();\n      }).catch(err => {\n        this.errorHandler.handleSignalingError(\n          new Error(`Failed to import socket.io client: ${err.message}`), true\n        );\n      });\n    } catch (error) {\n      this.errorHandler.handleSignalingError(\n        new Error(`Failed to connect to signaling server: ${error.message}`), true\n      );\n    }\n  }\n  \n  setupSocketListeners() {\n    if (!this.socket) return;\n    \n    // Handle connection events\n    this.socket.on('connect', () => {\n      this.logger.log('Connected to signaling server');\n      this.connected = true;\n      \n      // Register user ID with the signaling server\n      this.socket.emit('register', this.userId);\n    });\n    \n    this.socket.on('disconnect', () => {\n      this.logger.log('Disconnected from signaling server');\n      this.connected = false;\n    });\n    \n    // Set up event listeners for signaling messages\n    const events = [\n      'incoming-call', 'call-answered', 'call-declined', 'call-in-progress',\n      'ice-candidate', 'call-ended', 'call-failed', 'user-online', 'user-offline',\n      'user-online-status', 'media-connected'\n    ];\n    \n    events.forEach(event => {\n      this.socket.on(event, (data) => {\n        if (this.eventHandler) {\n          this.eventHandler(event, data);\n        }\n      });\n    });\n    \n    // Setup socket configuration for reliability\n    if (this.socket.io) {\n      this.socket.io.reconnection(true);\n      this.socket.io.reconnectionAttempts(10);\n      this.socket.io.reconnectionDelay(1000);\n      this.socket.io.timeout(10000);\n    }\n  }\n  \n  /**\n   * Send a message to the signaling server\n   * @param {string} event - Event name\n   * @param {Object} data - Event data\n   */\n  send(event, data) {\n    if (this.connected && this.socket) {\n      this.socket.emit(event, data);\n    } else {\n      this.logger.error(`Cannot send message '${event}', not connected to signaling server`);\n      setTimeout(() => {\n        if (this.connected && this.socket) {\n          this.logger.log(`Retrying message '${event}' after delay`);\n          this.socket.emit(event, data);\n        }\n      }, 1000);\n    }\n  }\n  \n  /**\n   * Check if a user is online\n   * @param {string} userId - User ID to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    return new Promise((resolve) => {\n      if (!this.connected || !this.socket) {\n        resolve(false);\n        return;\n      }\n      \n      // Create a unique request ID to match the response\n      const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      this.logger.log('Checking if user is online:', userId, 'with requestId:', requestId);\n      this.socket.emit('check-user-online', { userId, requestId });\n      \n      // Set up a one-time event listener for the response\n      const responseHandler = (data) => {\n        if (data.responseId === requestId && data.userId === userId) {\n          this.socket.off('user-online-status', responseHandler);\n          clearTimeout(timeoutId);\n          resolve(data.isOnline);\n        }\n      };\n      \n      this.socket.on('user-online-status', responseHandler);\n      \n      // Set a timeout in case we never get a response\n      const timeoutId = setTimeout(() => {\n        this.socket.off('user-online-status', responseHandler);\n        this.logger.log('User online check timed out for:', userId);\n        resolve(false);\n      }, 5000);\n    });\n  }\n  \n  /**\n   * Check if connected to the signaling server\n   * @returns {boolean} - Whether connected\n   */\n  isConnected() {\n    return this.connected;\n  }\n  \n  /**\n   * Disconnect from the signaling server\n   */\n  disconnect() {\n    if (this.connected && this.socket) {\n      this.socket.disconnect();\n      this.connected = false;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}