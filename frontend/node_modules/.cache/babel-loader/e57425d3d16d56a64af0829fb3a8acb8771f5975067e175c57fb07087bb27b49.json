{"ast":null,"code":"var _jsxFileName = \"/Users/ang/V_Hack_Ver4_2/frontend2/src/components/screens/Connect/ConnectScreen.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext';\nimport webRTCService from '../../services/WebRTCService';\nimport supabase from '../../supabaseClient';\nimport { useAuth } from '../../AuthProvider';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConnectScreen = ({\n  colors,\n  setActiveScreen\n}) => {\n  _s();\n  const {\n    isDarkMode\n  } = useTheme();\n  const {\n    user\n  } = useAuth();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n\n  // Doctors data from Supabase\n  const [doctors, setDoctors] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n\n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(localStorage.getItem('is_doctor') === 'true');\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n\n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n\n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n\n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Fetch doctors from Supabase\n  useEffect(() => {\n    async function fetchDoctors() {\n      try {\n        setIsLoading(true);\n        let query = supabase.from('doctors').select('*');\n\n        // Apply filter if active\n        if (filterActive) {\n          query = query.eq('availability', true);\n        }\n        const {\n          data,\n          error\n        } = await query;\n        if (error) {\n          throw error;\n        }\n\n        // Map Supabase data to our app's expected format\n        const formattedDoctors = data.map(doctor => ({\n          id: doctor.doctor_id,\n          name: doctor.name,\n          specialty: doctor.specialty,\n          image: doctor.image_url,\n          availability: doctor.availability ? \"Available now\" : \"Available in 2h\",\n          rating: doctor.rating || 5\n        }));\n        console.log('Fetched doctors from Supabase:', formattedDoctors);\n        setDoctors(formattedDoctors);\n      } catch (error) {\n        console.error('Error fetching doctors:', error);\n        displayToast('Failed to load doctors. Please try again.');\n      } finally {\n        setIsLoading(false);\n      }\n    }\n    fetchDoctors();\n  }, [filterActive]); // Refetch when filter changes\n\n  // IMPROVED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n            // Get doctor ID from user object or localStorage\n            let doctorId;\n            if (user && user.isDoctor && user.doctorId) {\n              doctorId = `doctor-${user.doctorId}`;\n            } else {\n              // Fallback to stored ID or generate one\n              doctorId = localStorage.getItem('doctor_id') || `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n            }\n            localStorage.setItem('doctor_id', doctorId);\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode, user]);\n\n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    const callbacks = {\n      onIncomingCall: callerId => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1);\n\n        // Try to find the doctor in our list based on the caller ID\n        const callerDoctorId = parseInt(callerId.replace('doctor-', ''));\n        const callingDoctor = doctors.find(doc => doc.id === callerDoctorId) || {\n          id: callerDoctorId || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"https://randomuser.me/api/portraits/men/32.jpg\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      onUserNotOnline: userId => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        setConnectingDoctor(null);\n      },\n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n\n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {/* handle error */}\n          setRingtoneAudio(null);\n        }\n      },\n      onCallDeclined: () => {\n        console.log('Call was declined by the doctor');\n\n        // Get the doctor name if available\n        const doctorName = connectingDoctor ? connectingDoctor.name : 'doctor';\n\n        // Display a toast notification to the user\n        displayToast(`Call declined by ${doctorName}`);\n\n        // Reset the connecting state\n        setConnectingDoctor(null);\n\n        // Make sure the video call screen is closed\n        setShowVideoCall(false);\n      }\n    };\n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // Handle doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = localStorage.getItem('doctor_id') || 'doctor-1';\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Registered as ${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // Registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && webRTCService.signalingService.isConnected() && !webRTCService.isCallActive() && !showVideoCall) {\n        webRTCService.signalingService.send('register', currentUserId);\n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = localStorage.getItem('doctor_id') || 'doctor-1';\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Re-registering as ${doctorId}`);\n        }\n      }\n    }, 5000);\n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', error => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      clearInterval(registerInterval);\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) {/* handle error */}\n      }\n      setIncomingCallInfo(null);\n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      webRTCService.disconnect();\n    };\n  }, []);\n\n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: doctor => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n\n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      cleanupPreviousCall();\n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          audio.addEventListener('error', e => {\n            console.error('Ringtone error:', e);\n          });\n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      playRingtone();\n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      setAutoAcceptTimer(timer);\n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    acceptIncomingCall: doctor => {\n      console.log('Accepting incoming call from:', doctor === null || doctor === void 0 ? void 0 : doctor.name);\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      setIncomingCallInfo(null);\n      setIncomingCallCounter(0); // Reset the counter when accepting a call\n\n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n\n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      webRTCService.declineCall();\n      setIncomingCallInfo(null);\n      setIncomingCallCounter(0); // Reset the counter when rejecting a call\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n\n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    checkDoctorOnline: async doctorId => {\n      // First check in Supabase if doctor is available\n      try {\n        const {\n          data,\n          error\n        } = await supabase.from('doctors').select('availability').eq('doctor_id', doctorId).single();\n        if (error) {\n          console.error('Error checking doctor availability in database:', error);\n          return false;\n        }\n\n        // If not marked as available in database, don't even check socket\n        if (!data.availability) {\n          console.log(`Doctor ${doctorId} is marked as unavailable in database`);\n          return false;\n        }\n\n        // Doctor is available in database, now check socket connection\n        console.log(`Doctor ${doctorId} is available in database, checking socket connection...`);\n      } catch (error) {\n        console.error('Error in database check:', error);\n      }\n\n      // Check socket connection with retry logic\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    initiateCall: async doctor => {\n      if (!webRTCService || !doctor) return;\n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n\n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n    handleConnectDoctor: async doctor => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        // Update doctor availability in real-time from Supabase\n        try {\n          const {\n            data,\n            error\n          } = await supabase.from('doctors').select('availability').eq('doctor_id', doctor.id).single();\n          if (error) throw error;\n\n          // Update the local doctor data with real-time availability\n          if (data) {\n            doctor.availability = data.availability ? \"Available now\" : \"Available in 2h\";\n          }\n        } catch (error) {\n          console.error('Error fetching doctor availability:', error);\n        }\n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  const {\n    displayIncomingCallAlert,\n    acceptIncomingCall,\n    rejectIncomingCall,\n    initiateCall,\n    handleConnectDoctor\n  } = callHandlers;\n\n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n      setIncomingCallCounter(0); // Reset the counter when a call ends\n    }\n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n\n  // Handle search filtering\n  const handleSearch = query => {\n    setSearchQuery(query);\n  };\n\n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery ? doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()) : true;\n    const matchesAvailability = filterActive ? doctor.availability.includes('Available') && !doctor.availability.includes('in') : true;\n    return matchesSearch && matchesAvailability;\n  });\n\n  // Improved toast display function\n  const displayToast = message => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n\n  // Process toast queue with improved timing\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      // Show the next toast in queue\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n\n      // Set a timer to clear the active toast after display time\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n\n        // Add a small delay before processing next toast\n        setTimeout(() => {\n          // Check if there are more toasts in queue and trigger reprocessing\n          if (toastQueue.length > 0) {\n            // Create a temporary state update to trigger the useEffect again\n            setToastQueue(prev => [...prev]);\n          }\n        }, 300); // Small delay between toasts\n      }, 3500); // Display duration reduced to 3.5 seconds\n\n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n\n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  // Loading state\n  if (isLoading) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"p-6 pb-24 flex items-center justify-center h-full\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"text-center\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 631,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-blue-500\",\n          children: \"Loading doctors...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 632,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 630,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 629,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"p-6 pb-24 dark-mode-transition\",\n    style: {\n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)` : 'none'\n    },\n    children: [/*#__PURE__*/_jsxDEV(ConnectHeader, {\n      headerVisible: headerVisible,\n      notifications: notifications,\n      setNotifications: setNotifications,\n      colors: colors,\n      isDoctorMode: isDoctorMode,\n      setIsDoctorMode: setIsDoctorMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 646,\n      columnNumber: 7\n    }, this), incomingCallCounter > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-2 p-2 bg-red-100 rounded-md text-xs\",\n      children: [\"Incoming call events received: \", incomingCallCounter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 656,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(SearchBar, {\n      headerVisible: headerVisible,\n      searchFocused: searchFocused,\n      setSearchFocused: setSearchFocused,\n      searchQuery: searchQuery,\n      setSearchQuery: setSearchQuery,\n      handleSearch: handleSearch,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 661,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FilterChips, {\n      headerVisible: headerVisible,\n      filterActive: filterActive,\n      setFilterActive: setFilterActive,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 672,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(DoctorsTeam, {\n      headerVisible: headerVisible,\n      doctors: filteredDoctors,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      handleConnectDoctor: handleConnectDoctor,\n      setSelectedDoctor: setSelectedDoctor,\n      setSchedulingDoctor: setSchedulingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 680,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(QuickConnectActions, {\n      headerVisible: headerVisible,\n      colors: colors,\n      connectingDoctor: connectingDoctor,\n      setShowMessageDialog: setShowMessageDialog,\n      initiateCall: initiateCall,\n      displayToast: displayToast,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 692,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RecentMessages, {\n      headerVisible: headerVisible,\n      colors: colors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 702,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MessageDialog, {\n      isOpen: showMessageDialog,\n      onClose: () => {\n        setShowMessageDialog(false);\n        setSchedulingDoctor(null);\n      },\n      colors: colors,\n      recipient: schedulingDoctor || connectingDoctor,\n      doctors: doctors\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 708,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoCallScreen, {\n      isOpen: showVideoCall,\n      onClose: () => setShowVideoCall(false),\n      colors: colors,\n      doctor: connectingDoctor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 720,\n      columnNumber: 7\n    }, this), incomingCallInfo && /*#__PURE__*/_jsxDEV(IncomingCallUI, {\n      incomingCallInfo: incomingCallInfo,\n      colors: colors,\n      acceptIncomingCall: acceptIncomingCall,\n      rejectIncomingCall: rejectIncomingCall\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 729,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ToastNotification, {\n      activeToast: activeToast,\n      colors: colors,\n      isDarkMode: isDarkMode\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 738,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"style\", {\n      jsx: true,\n      children: `\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 744,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 639,\n    columnNumber: 5\n  }, this);\n};\n_s(ConnectScreen, \"dufIvciK58zhh5KIcNdiT2EXY90=\", false, function () {\n  return [useTheme, useAuth];\n});\n_c = ConnectScreen;\nexport default ConnectScreen;\nvar _c;\n$RefreshReg$(_c, \"ConnectScreen\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useTheme","webRTCService","supabase","useAuth","MessageDialog","VideoCallScreen","ConnectHeader","SearchBar","FilterChips","DoctorsTeam","QuickConnectActions","RecentMessages","IncomingCallUI","ToastNotification","jsxDEV","_jsxDEV","ConnectScreen","colors","setActiveScreen","_s","isDarkMode","user","searchFocused","setSearchFocused","searchQuery","setSearchQuery","notifications","setNotifications","filterActive","setFilterActive","doctors","setDoctors","isLoading","setIsLoading","showMessageDialog","setShowMessageDialog","showVideoCall","setShowVideoCall","selectedDoctor","setSelectedDoctor","connectingDoctor","setConnectingDoctor","schedulingDoctor","setSchedulingDoctor","readyToConnect","setReadyToConnect","isDoctorMode","setIsDoctorMode","localStorage","getItem","toastQueue","setToastQueue","activeToast","setActiveToast","incomingCallInfo","setIncomingCallInfo","ringtoneAudio","setRingtoneAudio","autoAcceptTimer","setAutoAcceptTimer","incomingCallCounter","setIncomingCallCounter","prevShowVideoCall","fetchDoctors","query","from","select","eq","data","error","formattedDoctors","map","doctor","id","doctor_id","name","specialty","image","image_url","availability","rating","console","log","displayToast","setItem","registerAsDoctor","signalingService","isConnected","doctorId","isDoctor","Math","floor","random","send","replace","setTimeout","userId","generateUniqueId","storedId","newId","toString","substring","currentUserId","callbacks","onIncomingCall","callerId","prev","callerDoctorId","parseInt","callingDoctor","find","doc","displayIncomingCallAlert","onUserNotOnline","onCallInProgress","callerUserId","message","pause","currentTime","e","onCallDeclined","doctorName","serverUrl","process","env","REACT_APP_SIGNALING_SERVER","initialize","registerInterval","setInterval","isCallActive","unsubscribeError","on","fatal","clearInterval","clearTimeout","disconnect","callHandlers","cleanupPreviousCall","callNotificationId","Date","now","timestamp","playRingtone","audio","Audio","loop","volume","addEventListener","playPromise","play","undefined","then","catch","timer","acceptIncomingCall","acceptCall","rejectIncomingCall","declineCall","checkDoctorOnline","single","attempt","isOnline","checkUserOnline","Promise","resolve","initiateCall","getLocalMedia","makeCall","handleConnectDoctor","current","handleSearch","filteredDoctors","filter","matchesSearch","toLowerCase","includes","matchesAvailability","length","slice","headerVisible","setHeaderVisible","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","backgroundColor","background","backgroundImage","primary","accent","isOpen","onClose","recipient","jsx","_c","$RefreshReg$"],"sources":["/Users/ang/V_Hack_Ver4_2/frontend2/src/components/screens/Connect/ConnectScreen.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTheme } from '../../ThemeContext'; \nimport webRTCService from '../../services/WebRTCService';\nimport supabase from '../../supabaseClient';\nimport { useAuth } from '../../AuthProvider';\nimport MessageDialog from './MessageDialog';\nimport VideoCallScreen from './VideoCallScreen';\nimport ConnectHeader from './ConnectHeader';\nimport SearchBar from './SearchBar';\nimport FilterChips from './FilterChips';\nimport DoctorsTeam from './DoctorsTeam';\nimport QuickConnectActions from './QuickConnectActions';\nimport RecentMessages from './RecentMessages';\nimport IncomingCallUI from './IncomingCallUI';\nimport ToastNotification from './ToastNotification';\n\nconst ConnectScreen = ({ colors, setActiveScreen }) => {\n  const { isDarkMode } = useTheme();\n  const { user } = useAuth();\n  const [searchFocused, setSearchFocused] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [notifications, setNotifications] = useState(3);\n  const [filterActive, setFilterActive] = useState(false);\n  \n  // Doctors data from Supabase\n  const [doctors, setDoctors] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  // Modal states\n  const [showMessageDialog, setShowMessageDialog] = useState(false);\n  const [showVideoCall, setShowVideoCall] = useState(false);\n  const [selectedDoctor, setSelectedDoctor] = useState(null);\n  const [connectingDoctor, setConnectingDoctor] = useState(null);\n  const [schedulingDoctor, setSchedulingDoctor] = useState(null);\n  const [readyToConnect, setReadyToConnect] = useState(false);\n  \n  // Doctor mode toggle for testing\n  const [isDoctorMode, setIsDoctorMode] = useState(\n    localStorage.getItem('is_doctor') === 'true'\n  );\n\n  // Enhanced notification system\n  const [toastQueue, setToastQueue] = useState([]);\n  const [activeToast, setActiveToast] = useState(null);\n  \n  // Incoming call notification\n  const [incomingCallInfo, setIncomingCallInfo] = useState(null);\n  const [ringtoneAudio, setRingtoneAudio] = useState(null);\n  const [autoAcceptTimer, setAutoAcceptTimer] = useState(null);\n  \n  // Debug counter for incoming calls\n  const [incomingCallCounter, setIncomingCallCounter] = useState(0);\n  \n  // Ref to track previous video call state\n  const prevShowVideoCall = useRef(showVideoCall);\n\n  // Fetch doctors from Supabase\n  useEffect(() => {\n    async function fetchDoctors() {\n      try {\n        setIsLoading(true);\n        \n        let query = supabase\n          .from('doctors')\n          .select('*');\n          \n        // Apply filter if active\n        if (filterActive) {\n          query = query.eq('availability', true);\n        }\n        \n        const { data, error } = await query;\n          \n        if (error) {\n          throw error;\n        }\n        \n        // Map Supabase data to our app's expected format\n        const formattedDoctors = data.map(doctor => ({\n          id: doctor.doctor_id,\n          name: doctor.name,\n          specialty: doctor.specialty,\n          image: doctor.image_url,\n          availability: doctor.availability ? \"Available now\" : \"Available in 2h\",\n          rating: doctor.rating || 5\n        }));\n        \n        console.log('Fetched doctors from Supabase:', formattedDoctors);\n        setDoctors(formattedDoctors);\n      } catch (error) {\n        console.error('Error fetching doctors:', error);\n        displayToast('Failed to load doctors. Please try again.');\n      } finally {\n        setIsLoading(false);\n      }\n    }\n    \n    fetchDoctors();\n  }, [filterActive]); // Refetch when filter changes\n  \n  // IMPROVED: Doctor Mode Toggle useEffect\n  useEffect(() => {\n    localStorage.setItem('is_doctor', isDoctorMode ? 'true' : 'false');\n    \n    if (isDoctorMode) {\n      const registerAsDoctor = () => {\n        try {\n          if (webRTCService.signalingService && \n              webRTCService.signalingService.isConnected()) {\n            // Get doctor ID from user object or localStorage\n            let doctorId;\n            \n            if (user && user.isDoctor && user.doctorId) {\n              doctorId = `doctor-${user.doctorId}`;\n            } else {\n              // Fallback to stored ID or generate one\n              doctorId = localStorage.getItem('doctor_id') || \n                        `doctor-${Math.floor(1000 + Math.random() * 9000)}`;\n            }\n            \n            localStorage.setItem('doctor_id', doctorId);\n            webRTCService.signalingService.send('register', doctorId);\n            console.log(`ðŸ©º Successfully registered as ${doctorId}`);\n            displayToast(`Registered as Doctor (ID: ${doctorId.replace('doctor-', '')})`);\n          } else {\n            console.log(\"Socket not connected, retrying in 1 second...\");\n            setTimeout(registerAsDoctor, 1000);\n          }\n        } catch (error) {\n          console.error(\"Error registering as doctor:\", error);\n          setTimeout(registerAsDoctor, 1000);\n        }\n      };\n      \n      registerAsDoctor();\n    } else {\n      try {\n        if (webRTCService.signalingService && \n            webRTCService.signalingService.isConnected()) {\n          const userId = localStorage.getItem('user_instance_id') || 'user-default';\n          webRTCService.signalingService.send('register', userId);\n          console.log(`Registered back as patient: ${userId}`);\n        }\n      } catch (error) {\n        console.error(\"Error switching to patient mode:\", error);\n      }\n    }\n  }, [isDoctorMode, user]);\n  \n  // WebRTC initialization\n  useEffect(() => {\n    const generateUniqueId = () => {\n      const storedId = localStorage.getItem('user_instance_id');\n      if (storedId) {\n        return storedId;\n      }\n      \n      const newId = 'user-' + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('user_instance_id', newId);\n      return newId;\n    };\n    \n    const currentUserId = generateUniqueId();\n    console.log('Initializing with user ID:', currentUserId);\n    \n    const callbacks = {\n      onIncomingCall: (callerId) => {\n        console.log('Incoming call received from:', callerId);\n        setIncomingCallCounter(prev => prev + 1)\n        \n        // Try to find the doctor in our list based on the caller ID\n        const callerDoctorId = parseInt(callerId.replace('doctor-', ''));\n        const callingDoctor = doctors.find(doc => doc.id === callerDoctorId) || {\n          id: callerDoctorId || 999,\n          name: `Doctor ${callerId.replace('doctor-', '')}`,\n          specialty: \"Medical Professional\",\n          image: \"https://randomuser.me/api/portraits/men/32.jpg\",\n          availability: \"Available now\",\n          rating: 5\n        };\n        \n        setSelectedDoctor(callingDoctor);\n        setConnectingDoctor(callingDoctor);\n        \n        setTimeout(() => {\n          displayIncomingCallAlert(callingDoctor);\n        }, 10);\n      },\n      \n      onUserNotOnline: (userId) => {\n        const doctorId = userId.replace('doctor-', '');\n        const doctor = doctors.find(doc => doc.id.toString() === doctorId);\n        \n        if (doctor) {\n          displayToast(`${doctor.name} is not available right now. Please try again later.`);\n        } else {\n          displayToast('The selected doctor is not available right now.');\n        }\n        \n        setConnectingDoctor(null);\n      },\n    \n      onCallInProgress: (callerUserId, message) => {\n        displayToast(message || `Call with ${callerUserId} is already in progress`);\n        setConnectingDoctor(null);\n        setIncomingCallInfo(null);\n        \n        // Stop ringtone if it's playing\n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) { /* handle error */ }\n          setRingtoneAudio(null);\n        }\n      },\n      \n      onCallDeclined: () => {\n        console.log('Call was declined by the doctor');\n        \n        // Get the doctor name if available\n        const doctorName = connectingDoctor ? connectingDoctor.name : 'doctor';\n        \n        // Display a toast notification to the user\n        displayToast(`Call declined by ${doctorName}`);\n        \n        // Reset the connecting state\n        setConnectingDoctor(null);\n        \n        // Make sure the video call screen is closed\n        setShowVideoCall(false);\n      }\n    };\n    \n    const serverUrl = process.env.REACT_APP_SIGNALING_SERVER || null;\n    \n    webRTCService.initialize(currentUserId, callbacks, serverUrl);\n\n    // Handle doctor mode initialization\n    if (localStorage.getItem('is_doctor') === 'true') {\n      setTimeout(() => {\n        if (webRTCService.signalingService && webRTCService.signalingService.isConnected()) {\n          const doctorId = localStorage.getItem('doctor_id') || 'doctor-1';\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Registered as ${doctorId} on initialization`);\n        }\n      }, 1000);\n    }\n    \n    setTimeout(() => {\n      setReadyToConnect(true);\n    }, 2000);\n\n    // Registration interval with proper signaling service access\n    const registerInterval = setInterval(() => {\n      if (webRTCService.signalingService && \n          webRTCService.signalingService.isConnected() && \n          !webRTCService.isCallActive() && \n          !showVideoCall) {\n        \n        webRTCService.signalingService.send('register', currentUserId);\n        \n        if (localStorage.getItem('is_doctor') === 'true') {\n          const doctorId = localStorage.getItem('doctor_id') || 'doctor-1';\n          webRTCService.signalingService.send('register', doctorId);\n          console.log(`Re-registering as ${doctorId}`);\n        }\n      }\n    }, 5000);\n    \n    let unsubscribeError = () => {};\n    if (typeof webRTCService.on === 'function') {\n      unsubscribeError = webRTCService.on('error', (error) => {\n        console.log('WebRTC error received:', error);\n        displayToast(`Connection error: ${error.message}`);\n        \n        if (error.fatal) {\n          setConnectingDoctor(null);\n        }\n      });\n    }\n    \n    return () => {\n      console.log('Cleaning up ConnectScreen resources');\n      \n      clearInterval(registerInterval);\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n      }\n      \n      if (ringtoneAudio) {\n        try {\n          ringtoneAudio.pause();\n          ringtoneAudio.currentTime = 0;\n        } catch (e) { /* handle error */ }\n      }\n      \n      setIncomingCallInfo(null);\n      \n      if (typeof unsubscribeError === 'function') {\n        unsubscribeError();\n      }\n      \n      webRTCService.disconnect();\n    };\n  }, []);\n  \n  // Helpers for Call Management\n  const callHandlers = {\n    displayIncomingCallAlert: (doctor) => {\n      console.log('Displaying incoming call alert for doctor:', doctor.name);\n      \n      // Clean up before setting new call\n      const cleanupPreviousCall = () => {\n        setActiveToast(null);\n        setToastQueue([]);\n        \n        if (ringtoneAudio) {\n          try {\n            ringtoneAudio.pause();\n            ringtoneAudio.currentTime = 0;\n          } catch (e) {\n            console.error('Error stopping previous ringtone:', e);\n          }\n          setRingtoneAudio(null);\n        }\n        \n        if (autoAcceptTimer) {\n          clearTimeout(autoAcceptTimer);\n          setAutoAcceptTimer(null);\n        }\n      };\n      \n      cleanupPreviousCall();\n      \n      const callNotificationId = `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n      \n      setIncomingCallInfo({\n        doctor: doctor,\n        timestamp: Date.now(),\n        id: callNotificationId\n      });\n      \n      const playRingtone = () => {\n        try {\n          const audio = new Audio('/song1.mp3');\n          audio.loop = true;\n          audio.volume = 0.7;\n          \n          audio.addEventListener('error', (e) => {\n            console.error('Ringtone error:', e);\n          });\n          \n          const playPromise = audio.play();\n          if (playPromise !== undefined) {\n            playPromise.then(() => {\n              setRingtoneAudio(audio);\n            }).catch(e => {\n              console.log('Could not play notification sound:', e);\n              if (e.name === 'NotAllowedError') {\n                displayToast('Incoming call (sound muted)');\n              }\n            });\n          }\n        } catch (error) {\n          console.log('Could not initialize ringtone:', error);\n        }\n      };\n      \n      playRingtone();\n      \n      const timer = setTimeout(() => {\n        if (incomingCallInfo && incomingCallInfo.id === callNotificationId) {\n          acceptIncomingCall(doctor);\n        }\n      }, 15000);\n      \n      setAutoAcceptTimer(timer);\n      \n      displayToast(`Incoming call from ${doctor.name}`);\n    },\n    \n    acceptIncomingCall: (doctor) => {\n      console.log('Accepting incoming call from:', doctor?.name);\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      setIncomingCallInfo(null);\n      setIncomingCallCounter(0); // Reset the counter when accepting a call\n      \n      webRTCService.acceptCall();\n      setShowVideoCall(true);\n      \n      // Make this message more obvious\n      displayToast(`Connected with ${doctor.name}`);\n    },\n    \n    rejectIncomingCall: () => {\n      console.log('Rejecting incoming call');\n      \n      if (ringtoneAudio) {\n        ringtoneAudio.pause();\n        ringtoneAudio.currentTime = 0;\n        setRingtoneAudio(null);\n      }\n      \n      if (autoAcceptTimer) {\n        clearTimeout(autoAcceptTimer);\n        setAutoAcceptTimer(null);\n      }\n      \n      webRTCService.declineCall();\n      \n      setIncomingCallInfo(null);\n      setIncomingCallCounter(0); // Reset the counter when rejecting a call\n      setConnectingDoctor(null);\n      setSelectedDoctor(null);\n      \n      // Make this message more obvious\n      displayToast('Call rejected');\n    },\n    \n    checkDoctorOnline: async (doctorId) => {\n      // First check in Supabase if doctor is available\n      try {\n        const { data, error } = await supabase\n          .from('doctors')\n          .select('availability')\n          .eq('doctor_id', doctorId)\n          .single();\n          \n        if (error) {\n          console.error('Error checking doctor availability in database:', error);\n          return false;\n        }\n        \n        // If not marked as available in database, don't even check socket\n        if (!data.availability) {\n          console.log(`Doctor ${doctorId} is marked as unavailable in database`);\n          return false;\n        }\n        \n        // Doctor is available in database, now check socket connection\n        console.log(`Doctor ${doctorId} is available in database, checking socket connection...`);\n      } catch (error) {\n        console.error('Error in database check:', error);\n      }\n      \n      // Check socket connection with retry logic\n      for (let attempt = 0; attempt < 3; attempt++) {\n        try {\n          console.log(`Checking if doctor-${doctorId} is online (attempt ${attempt + 1})`);\n          const isOnline = await webRTCService.checkUserOnline(`doctor-${doctorId}`);\n          return isOnline;\n        } catch (error) {\n          console.log(`Error checking doctor online status (attempt ${attempt + 1}):`, error);\n          if (attempt < 2) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n      }\n      return false;\n    },\n    \n    initiateCall: async (doctor) => {\n      if (!webRTCService || !doctor) return;\n    \n      try {\n        // Check active call status properly\n        if (webRTCService.isCallActive()) {\n          console.log('Call already active or connecting, not initiating a new one');\n          setShowVideoCall(true);\n          return;\n        }\n        \n        // Try to get media with error handling\n        try {\n          await webRTCService.getLocalMedia();\n        } catch (error) {\n          console.error('Failed to get media:', error);\n          displayToast(`Camera/microphone access failed: ${error.message}`);\n          return;\n        }\n        \n        webRTCService.makeCall(`doctor-${doctor.id}`);\n        setShowVideoCall(true);\n      } catch (error) {\n        console.error('Failed to initiate call:', error);\n        displayToast(`Error starting call: ${error.message}`);\n      }\n    },\n      \n    handleConnectDoctor: async (doctor) => {\n      if (!readyToConnect) {\n        displayToast('Please wait while connecting to the service...');\n        return;\n      }\n      \n      if (connectingDoctor && connectingDoctor.id === doctor.id) {\n        setConnectingDoctor(null);\n        setSelectedDoctor(null);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Disconnected from ${doctor.name}`);\n      } else {\n        // Update doctor availability in real-time from Supabase\n        try {\n          const { data, error } = await supabase\n            .from('doctors')\n            .select('availability')\n            .eq('doctor_id', doctor.id)\n            .single();\n            \n          if (error) throw error;\n          \n          // Update the local doctor data with real-time availability\n          if (data) {\n            doctor.availability = data.availability ? \"Available now\" : \"Available in 2h\";\n          }\n        } catch (error) {\n          console.error('Error fetching doctor availability:', error);\n        }\n        \n        const isOnline = await callHandlers.checkDoctorOnline(doctor.id);\n        \n        if (!isOnline) {\n          displayToast(`${doctor.name} is not online right now. Please try again later.`);\n          return;\n        }\n        \n        if (connectingDoctor) {\n          displayToast(`Disconnected from ${connectingDoctor.name}`);\n        }\n        \n        setConnectingDoctor(doctor);\n        setSelectedDoctor(doctor);\n        \n        setActiveToast(null);\n        setToastQueue([]);\n        displayToast(`Connecting to ${doctor.name}...`);\n      }\n    }\n  };\n  \n  const { displayIncomingCallAlert, acceptIncomingCall, rejectIncomingCall, initiateCall, handleConnectDoctor } = callHandlers;\n  \n  // Reset connection when video call ends, but only if previous state was true\n  useEffect(() => {\n    if (prevShowVideoCall.current && !showVideoCall && connectingDoctor) {\n      displayToast(`Call with ${connectingDoctor.name} ended`);\n      setConnectingDoctor(null);\n      setIncomingCallCounter(0); // Reset the counter when a call ends\n    }\n    \n    prevShowVideoCall.current = showVideoCall;\n  }, [showVideoCall, connectingDoctor]);\n  \n  // Handle search filtering\n  const handleSearch = (query) => {\n    setSearchQuery(query);\n  };\n  \n  // Filter doctors based on search query and availability filter\n  const filteredDoctors = doctors.filter(doctor => {\n    const matchesSearch = searchQuery \n      ? (doctor.name.toLowerCase().includes(searchQuery.toLowerCase()) || \n         doctor.specialty.toLowerCase().includes(searchQuery.toLowerCase()))\n      : true;\n      \n    const matchesAvailability = filterActive \n      ? doctor.availability.includes('Available') && !doctor.availability.includes('in')\n      : true;\n      \n    return matchesSearch && matchesAvailability;\n  });\n  \n  // Improved toast display function\n  const displayToast = (message) => {\n    console.log('Displaying toast:', message);\n    setToastQueue(prev => [...prev, message]);\n  };\n  \n  // Process toast queue with improved timing\n  useEffect(() => {\n    if (toastQueue.length > 0 && !activeToast) {\n      // Show the next toast in queue\n      setActiveToast(toastQueue[0]);\n      setToastQueue(prev => prev.slice(1));\n      \n      // Set a timer to clear the active toast after display time\n      const timer = setTimeout(() => {\n        setActiveToast(null);\n        \n        // Add a small delay before processing next toast\n        setTimeout(() => {\n          // Check if there are more toasts in queue and trigger reprocessing\n          if (toastQueue.length > 0) {\n            // Create a temporary state update to trigger the useEffect again\n            setToastQueue(prev => [...prev]);\n          }\n        }, 300); // Small delay between toasts\n      }, 3500); // Display duration reduced to 3.5 seconds\n      \n      return () => clearTimeout(timer);\n    }\n  }, [toastQueue, activeToast]);\n  \n  // Animation for header\n  const [headerVisible, setHeaderVisible] = useState(false);\n  useEffect(() => {\n    const timer = setTimeout(() => setHeaderVisible(true), 100);\n    return () => clearTimeout(timer);\n  }, []);\n\n  // Loading state\n  if (isLoading) {\n    return (\n      <div className=\"p-6 pb-24 flex items-center justify-center h-full\">\n        <div className=\"text-center\">\n          <div className=\"w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4\"></div>\n          <p className=\"text-blue-500\">Loading doctors...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6 pb-24 dark-mode-transition\" style={{ \n      backgroundColor: isDarkMode ? colors.background : 'transparent',\n      backgroundImage: isDarkMode \n        ? `radial-gradient(circle at 70% 30%, ${colors.primary}10, transparent 50%), \n           radial-gradient(circle at 30% 70%, ${colors.accent}10, transparent 50%)`\n        : 'none'\n    }}>\n      <ConnectHeader \n        headerVisible={headerVisible}\n        notifications={notifications}\n        setNotifications={setNotifications}\n        colors={colors}\n        isDoctorMode={isDoctorMode}\n        setIsDoctorMode={setIsDoctorMode}\n      />\n      \n      {incomingCallCounter > 0 && (\n      <div className=\"mb-2 p-2 bg-red-100 rounded-md text-xs\">\n        Incoming call events received: {incomingCallCounter}\n      </div>\n    )}\n      \n      <SearchBar \n        headerVisible={headerVisible}\n        searchFocused={searchFocused}\n        setSearchFocused={setSearchFocused}\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n        handleSearch={handleSearch}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <FilterChips \n        headerVisible={headerVisible}\n        filterActive={filterActive}\n        setFilterActive={setFilterActive}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <DoctorsTeam \n        headerVisible={headerVisible}\n        doctors={filteredDoctors}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        handleConnectDoctor={handleConnectDoctor}\n        setSelectedDoctor={setSelectedDoctor}\n        setSchedulingDoctor={setSchedulingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        isDarkMode={isDarkMode}\n      />\n      \n      <QuickConnectActions \n        headerVisible={headerVisible}\n        colors={colors}\n        connectingDoctor={connectingDoctor}\n        setShowMessageDialog={setShowMessageDialog}\n        initiateCall={initiateCall}\n        displayToast={displayToast}\n        isDarkMode={isDarkMode}\n      />\n      \n      <RecentMessages \n        headerVisible={headerVisible}\n        colors={colors}\n      />\n      \n      {/* Message Dialog */}\n      <MessageDialog \n        isOpen={showMessageDialog}\n        onClose={() => {\n          setShowMessageDialog(false);\n          setSchedulingDoctor(null);\n        }}\n        colors={colors}\n        recipient={schedulingDoctor || connectingDoctor}\n        doctors={doctors}\n      />\n      \n      {/* Video Call Screen */}\n      <VideoCallScreen \n        isOpen={showVideoCall}\n        onClose={() => setShowVideoCall(false)}\n        colors={colors}\n        doctor={connectingDoctor}\n      />\n      \n      {/* Incoming Call UI */}\n      {incomingCallInfo && (\n        <IncomingCallUI \n          incomingCallInfo={incomingCallInfo}\n          colors={colors}\n          acceptIncomingCall={acceptIncomingCall}\n          rejectIncomingCall={rejectIncomingCall}\n        />\n      )}\n      \n      {/* Toast Notification */}\n      <ToastNotification \n        activeToast={activeToast}\n        colors={colors}\n        isDarkMode={isDarkMode}\n      />\n      \n      <style jsx>{`\n        @keyframes shimmer {\n          0% { background-position: -100% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(255, 255, 255, 0) 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            rgba(255, 255, 255, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .dark .shimmer-effect {\n          background: linear-gradient(\n            90deg,\n            rgba(30, 41, 59, 0) 0%,\n            rgba(30, 41, 59, 0.4) 50%,\n            rgba(30, 41, 59, 0) 100%\n          );\n          background-size: 200% 100%;\n          animation: shimmer 2s infinite linear;\n        }\n        \n        .hide-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        \n        .hide-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n        \n        @keyframes bounce-in {\n          0% { transform: scale(0.8); opacity: 0; }\n          70% { transform: scale(1.05); opacity: 1; }\n          100% { transform: scale(1); opacity: 1; }\n        }\n        .animate-bounce-in {\n          animation: bounce-in 0.5s ease-out forwards;\n        }\n        \n        @keyframes fade-in {\n          0% { opacity: 0; }\n          100% { opacity: 1; }\n        }\n        .animate-fade-in {\n          animation: fade-in 0.3s ease-out forwards;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ConnectScreen;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}