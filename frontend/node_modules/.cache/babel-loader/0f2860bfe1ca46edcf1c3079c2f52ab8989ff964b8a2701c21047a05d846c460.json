{"ast":null,"code":"// File: services/WebRTC/SignalingService.js\nimport io from 'socket.io-client';\n\n/**\n * Creates a signaling service instance with enhanced reliability\n * @param {string} serverUrl - Signaling server URL\n * @param {string} userId - Current user ID\n * @param {function} eventHandler - Event handler function\n * @returns {Object} - Signaling service instance\n */\nexport function createSignalingService(serverUrl, userId, eventHandler) {\n  // Connect to the signaling server with improved configuration\n  const socket = io(serverUrl, {\n    reconnection: true,\n    reconnectionAttempts: 10,\n    reconnectionDelay: 1000,\n    timeout: 10000,\n    transports: ['websocket', 'polling'] // Try WebSocket first, fallback to polling\n  });\n  let connected = false;\n  let reconnecting = false;\n  let pendingMessages = [];\n\n  // Handle connection events\n  socket.on('connect', () => {\n    console.log('Connected to signaling server');\n    connected = true;\n    reconnecting = false;\n\n    // Register user ID with the signaling server\n    socket.emit('register', userId);\n\n    // Send any pending messages\n    if (pendingMessages.length > 0) {\n      console.log(`Sending ${pendingMessages.length} pending messages`);\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n    }\n  });\n  socket.on('disconnect', reason => {\n    console.log('Disconnected from signaling server, reason:', reason);\n    connected = false;\n\n    // If the disconnection was not intended, attempt to reconnect\n    if (reason === 'io server disconnect' || reason === 'transport close') {\n      reconnecting = true;\n      // Force reconnection if server closed the connection\n      setTimeout(() => {\n        if (!connected) {\n          console.log('Forcing reconnection to signaling server');\n          socket.connect();\n        }\n      }, 2000);\n    }\n  });\n  socket.on('reconnect_attempt', attemptNumber => {\n    console.log(`Attempting to reconnect (${attemptNumber})`);\n    reconnecting = true;\n  });\n  socket.on('reconnect', attemptNumber => {\n    console.log(`Reconnected after ${attemptNumber} attempts`);\n    reconnecting = false;\n    connected = true;\n\n    // Re-register after reconnection\n    socket.emit('register', userId);\n\n    // Process any pending messages\n    if (pendingMessages.length > 0) {\n      console.log(`Processing ${pendingMessages.length} pending messages after reconnection`);\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n    }\n  });\n  socket.on('reconnect_error', error => {\n    console.error('Reconnection error:', error);\n  });\n  socket.on('reconnect_failed', () => {\n    console.error('Failed to reconnect to signaling server');\n    reconnecting = false;\n  });\n  socket.on('error', error => {\n    console.error('Socket error:', error);\n  });\n\n  // Set up event listeners for signaling messages\n  socket.on('incoming-call', data => {\n    eventHandler('incoming-call', data);\n  });\n  socket.on('call-answered', data => {\n    eventHandler('call-answered', data);\n  });\n  socket.on('call-declined', () => {\n    eventHandler('call-declined');\n  });\n  socket.on('call-in-progress', data => {\n    eventHandler('call-in-progress', data);\n  });\n  socket.on('ice-candidate', data => {\n    eventHandler('ice-candidate', data);\n  });\n  socket.on('call-ended', () => {\n    eventHandler('call-ended');\n  });\n  socket.on('direct-call-ended', data => {\n    eventHandler('direct-call-ended', data);\n  });\n  socket.on('call-failed', data => {\n    eventHandler('call-failed', data);\n  });\n  socket.on('media-connected', () => {\n    eventHandler('media-connected');\n  });\n\n  // Return the signaling service interface\n  return {\n    socket,\n    // Expose the socket object for direct access if needed\n\n    /**\n     * Send a message to the signaling server with improved error handling\n     * @param {string} event - Event name\n     * @param {Object} data - Event data\n     * @returns {boolean} - Whether the message was sent successfully\n     */\n    send: (event, data) => {\n      if (connected) {\n        try {\n          socket.emit(event, data);\n          return true;\n        } catch (error) {\n          console.error(`Error sending ${event}:`, error);\n          // Queue the message in case of error\n          pendingMessages.push({\n            event,\n            data\n          });\n          return false;\n        }\n      } else if (reconnecting) {\n        // Queue the message to be sent after reconnection\n        console.log(`Queuing ${event} message to be sent after reconnection`);\n        pendingMessages.push({\n          event,\n          data\n        });\n        return false;\n      } else {\n        console.error('Cannot send message, not connected to signaling server');\n        // Queue the message and try to reconnect\n        pendingMessages.push({\n          event,\n          data\n        });\n        socket.connect();\n        return false;\n      }\n    },\n    /**\n     * Check if a user is online with improved reliability\n     * @param {string} userId - User ID to check\n     * @returns {Promise<boolean>} - Whether the user is online\n     */\n    checkUserOnline: userId => {\n      return new Promise(resolve => {\n        if (!connected) {\n          // Try to reconnect first\n          socket.connect();\n\n          // Wait a bit for potential connection\n          setTimeout(() => {\n            if (connected) {\n              // Now try the check\n              checkOnlineStatus(userId, resolve);\n            } else {\n              resolve(false);\n            }\n          }, 1000);\n        } else {\n          checkOnlineStatus(userId, resolve);\n        }\n      });\n      function checkOnlineStatus(userId, resolve) {\n        // Create a unique request ID\n        const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        console.log('Checking if user is online:', userId, 'with requestId:', requestId);\n        socket.emit('check-user-online', {\n          userId,\n          requestId\n        });\n\n        // Set up a one-time event listener for the response\n        const responseHandler = data => {\n          if (data.responseId === requestId && data.userId === userId) {\n            socket.off('user-online-status', responseHandler);\n            clearTimeout(timeoutId);\n            resolve(data.isOnline);\n          }\n        };\n        socket.on('user-online-status', responseHandler);\n\n        // Set a timeout in case we never get a response\n        const timeoutId = setTimeout(() => {\n          socket.off('user-online-status', responseHandler);\n          console.log('User online check timed out for:', userId);\n          resolve(false);\n        }, 5000);\n      }\n    },\n    /**\n     * Check if connected to the signaling server\n     * @returns {boolean} - Whether connected\n     */\n    isConnected: () => connected,\n    /**\n     * Force reconnection to the signaling server\n     * @returns {Promise<boolean>} - Whether reconnection was successful\n     */\n    reconnect: () => {\n      return new Promise(resolve => {\n        if (connected) {\n          resolve(true);\n          return;\n        }\n        console.log('Forcing reconnection to signaling server');\n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n\n          // Re-register after connection\n          socket.emit('register', userId);\n          resolve(true);\n        };\n        socket.once('connect', connectHandler);\n        socket.connect();\n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          resolve(false);\n        }, 5000);\n      });\n    },\n    /**\n     * Get connection status\n     * @returns {Object} - Connection status object\n     */\n    getStatus: () => {\n      return {\n        connected,\n        reconnecting,\n        pendingMessages: pendingMessages.length,\n        socketId: socket.id\n      };\n    },\n    /**\n     * Flush any pending messages immediately\n     * @returns {number} - Number of messages flushed\n     */\n    flushPendingMessages: () => {\n      if (!connected || pendingMessages.length === 0) {\n        return 0;\n      }\n      const count = pendingMessages.length;\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n      return count;\n    },\n    /**\n     * Disconnect from the signaling server\n     */\n    disconnect: () => {\n      if (connected) {\n        socket.disconnect();\n        connected = false;\n      }\n    }\n  };\n}","map":{"version":3,"names":["io","createSignalingService","serverUrl","userId","eventHandler","socket","reconnection","reconnectionAttempts","reconnectionDelay","timeout","transports","connected","reconnecting","pendingMessages","on","console","log","emit","length","forEach","msg","event","data","reason","setTimeout","connect","attemptNumber","error","send","push","checkUserOnline","Promise","resolve","checkOnlineStatus","requestId","Date","now","Math","random","toString","substring","responseHandler","responseId","off","clearTimeout","timeoutId","isOnline","isConnected","reconnect","connectHandler","once","getStatus","socketId","id","flushPendingMessages","count","disconnect"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/SignalingService.js"],"sourcesContent":["// File: services/WebRTC/SignalingService.js\nimport io from 'socket.io-client';\n\n/**\n * Creates a signaling service instance with enhanced reliability\n * @param {string} serverUrl - Signaling server URL\n * @param {string} userId - Current user ID\n * @param {function} eventHandler - Event handler function\n * @returns {Object} - Signaling service instance\n */\nexport function createSignalingService(serverUrl, userId, eventHandler) {\n  // Connect to the signaling server with improved configuration\n  const socket = io(serverUrl, {\n    reconnection: true,\n    reconnectionAttempts: 10,\n    reconnectionDelay: 1000,\n    timeout: 10000,\n    transports: ['websocket', 'polling'] // Try WebSocket first, fallback to polling\n  });\n  \n  let connected = false;\n  let reconnecting = false;\n  let pendingMessages = [];\n  \n  // Handle connection events\n  socket.on('connect', () => {\n    console.log('Connected to signaling server');\n    connected = true;\n    reconnecting = false;\n    \n    // Register user ID with the signaling server\n    socket.emit('register', userId);\n    \n    // Send any pending messages\n    if (pendingMessages.length > 0) {\n      console.log(`Sending ${pendingMessages.length} pending messages`);\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n    }\n  });\n  \n  socket.on('disconnect', (reason) => {\n    console.log('Disconnected from signaling server, reason:', reason);\n    connected = false;\n    \n    // If the disconnection was not intended, attempt to reconnect\n    if (reason === 'io server disconnect' || reason === 'transport close') {\n      reconnecting = true;\n      // Force reconnection if server closed the connection\n      setTimeout(() => {\n        if (!connected) {\n          console.log('Forcing reconnection to signaling server');\n          socket.connect();\n        }\n      }, 2000);\n    }\n  });\n  \n  socket.on('reconnect_attempt', (attemptNumber) => {\n    console.log(`Attempting to reconnect (${attemptNumber})`);\n    reconnecting = true;\n  });\n  \n  socket.on('reconnect', (attemptNumber) => {\n    console.log(`Reconnected after ${attemptNumber} attempts`);\n    reconnecting = false;\n    connected = true;\n    \n    // Re-register after reconnection\n    socket.emit('register', userId);\n    \n    // Process any pending messages\n    if (pendingMessages.length > 0) {\n      console.log(`Processing ${pendingMessages.length} pending messages after reconnection`);\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n    }\n  });\n  \n  socket.on('reconnect_error', (error) => {\n    console.error('Reconnection error:', error);\n  });\n  \n  socket.on('reconnect_failed', () => {\n    console.error('Failed to reconnect to signaling server');\n    reconnecting = false;\n  });\n  \n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n  });\n  \n  // Set up event listeners for signaling messages\n  socket.on('incoming-call', (data) => {\n    eventHandler('incoming-call', data);\n  });\n  \n  socket.on('call-answered', (data) => {\n    eventHandler('call-answered', data);\n  });\n  \n  socket.on('call-declined', () => {\n    eventHandler('call-declined');\n  });\n  \n  socket.on('call-in-progress', (data) => {\n    eventHandler('call-in-progress', data);\n  });\n  \n  socket.on('ice-candidate', (data) => {\n    eventHandler('ice-candidate', data);\n  });\n  \n  socket.on('call-ended', () => {\n    eventHandler('call-ended');\n  });\n  \n  socket.on('direct-call-ended', (data) => {\n    eventHandler('direct-call-ended', data);\n  });\n  \n  socket.on('call-failed', (data) => {\n    eventHandler('call-failed', data);\n  });\n  \n  socket.on('media-connected', () => {\n    eventHandler('media-connected');\n  });\n  \n  // Return the signaling service interface\n  return {\n    socket, // Expose the socket object for direct access if needed\n    \n    /**\n     * Send a message to the signaling server with improved error handling\n     * @param {string} event - Event name\n     * @param {Object} data - Event data\n     * @returns {boolean} - Whether the message was sent successfully\n     */\n    send: (event, data) => {\n      if (connected) {\n        try {\n          socket.emit(event, data);\n          return true;\n        } catch (error) {\n          console.error(`Error sending ${event}:`, error);\n          // Queue the message in case of error\n          pendingMessages.push({ event, data });\n          return false;\n        }\n      } else if (reconnecting) {\n        // Queue the message to be sent after reconnection\n        console.log(`Queuing ${event} message to be sent after reconnection`);\n        pendingMessages.push({ event, data });\n        return false;\n      } else {\n        console.error('Cannot send message, not connected to signaling server');\n        // Queue the message and try to reconnect\n        pendingMessages.push({ event, data });\n        socket.connect();\n        return false;\n      }\n    },\n    \n    /**\n     * Check if a user is online with improved reliability\n     * @param {string} userId - User ID to check\n     * @returns {Promise<boolean>} - Whether the user is online\n     */\n    checkUserOnline: (userId) => {\n      return new Promise((resolve) => {\n        if (!connected) {\n          // Try to reconnect first\n          socket.connect();\n          \n          // Wait a bit for potential connection\n          setTimeout(() => {\n            if (connected) {\n              // Now try the check\n              checkOnlineStatus(userId, resolve);\n            } else {\n              resolve(false);\n            }\n          }, 1000);\n        } else {\n          checkOnlineStatus(userId, resolve);\n        }\n      });\n      \n      function checkOnlineStatus(userId, resolve) {\n        // Create a unique request ID\n        const requestId = `online-check-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n        \n        console.log('Checking if user is online:', userId, 'with requestId:', requestId);\n        socket.emit('check-user-online', { userId, requestId });\n        \n        // Set up a one-time event listener for the response\n        const responseHandler = (data) => {\n          if (data.responseId === requestId && data.userId === userId) {\n            socket.off('user-online-status', responseHandler);\n            clearTimeout(timeoutId);\n            resolve(data.isOnline);\n          }\n        };\n        \n        socket.on('user-online-status', responseHandler);\n        \n        // Set a timeout in case we never get a response\n        const timeoutId = setTimeout(() => {\n          socket.off('user-online-status', responseHandler);\n          console.log('User online check timed out for:', userId);\n          resolve(false);\n        }, 5000);\n      }\n    },\n    \n    /**\n     * Check if connected to the signaling server\n     * @returns {boolean} - Whether connected\n     */\n    isConnected: () => connected,\n    \n    /**\n     * Force reconnection to the signaling server\n     * @returns {Promise<boolean>} - Whether reconnection was successful\n     */\n    reconnect: () => {\n      return new Promise((resolve) => {\n        if (connected) {\n          resolve(true);\n          return;\n        }\n        \n        console.log('Forcing reconnection to signaling server');\n        \n        const connectHandler = () => {\n          socket.off('connect', connectHandler);\n          clearTimeout(timeoutId);\n          \n          // Re-register after connection\n          socket.emit('register', userId);\n          resolve(true);\n        };\n        \n        socket.once('connect', connectHandler);\n        socket.connect();\n        \n        const timeoutId = setTimeout(() => {\n          socket.off('connect', connectHandler);\n          resolve(false);\n        }, 5000);\n      });\n    },\n    \n    /**\n     * Get connection status\n     * @returns {Object} - Connection status object\n     */\n    getStatus: () => {\n      return {\n        connected,\n        reconnecting,\n        pendingMessages: pendingMessages.length,\n        socketId: socket.id\n      };\n    },\n    \n    /**\n     * Flush any pending messages immediately\n     * @returns {number} - Number of messages flushed\n     */\n    flushPendingMessages: () => {\n      if (!connected || pendingMessages.length === 0) {\n        return 0;\n      }\n      \n      const count = pendingMessages.length;\n      pendingMessages.forEach(msg => {\n        socket.emit(msg.event, msg.data);\n      });\n      pendingMessages = [];\n      return count;\n    },\n    \n    /**\n     * Disconnect from the signaling server\n     */\n    disconnect: () => {\n      if (connected) {\n        socket.disconnect();\n        connected = false;\n      }\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}