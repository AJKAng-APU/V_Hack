{"ast":null,"code":"// services/WebRTCService.js\n\n/**\n * Simple WebRTC service to handle video calls between users\n * This is a client-side implementation that works with the signaling server\n */\nclass WebRTCService {\n  constructor() {\n    this.localStream = null;\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.currentUserId = null;\n    this.targetUserId = null;\n    this.callbacks = {};\n    this.isInitialized = false;\n    this.socket = null;\n    this.configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }]\n    };\n  }\n\n  /**\n   * Initialize the WebRTC service\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions for various events\n   */\n  initialize(userId, callbacks) {\n    if (this.isInitialized) {\n      console.log('WebRTC service already initialized');\n      return;\n    }\n    this.currentUserId = userId;\n    this.callbacks = callbacks || {};\n    this.isInitialized = true;\n    console.log('WebRTC service initialized for user:', userId);\n\n    // In a real implementation, we would connect to the signaling server here\n    // For this demo, we'll simulate incoming calls after a delay\n    setTimeout(() => {\n      if (typeof this.callbacks.onIncomingCall === 'function') {\n        // Simulate an incoming call notification after 5 seconds for demo purposes\n        // In a real app, this would come from the signaling server\n        console.log('Simulating incoming call...');\n      }\n    }, 5000);\n  }\n\n  /**\n   * Get access to the user's camera and microphone\n   */\n  async getLocalMedia() {\n    try {\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n      console.log('Got local media stream');\n      if (typeof this.callbacks.onLocalStream === 'function') {\n        this.callbacks.onLocalStream(this.localStream);\n      }\n      return this.localStream;\n    } catch (error) {\n      console.error('Error getting user media:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a peer connection and add local media tracks\n   */\n  async createPeerConnection() {\n    try {\n      this.peerConnection = new RTCPeerConnection(this.configuration);\n\n      // Add local tracks to the peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.peerConnection.addTrack(track, this.localStream);\n        });\n      }\n\n      // Set up event handlers for the peer connection\n      this.peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          console.log('New ICE candidate:', event.candidate);\n          // In a real app, we would send this to the signaling server\n          // this.socket.emit('ice-candidate', { targetUserId: this.targetUserId, candidate: event.candidate });\n        }\n      };\n      this.peerConnection.oniceconnectionstatechange = () => {\n        console.log('ICE connection state:', this.peerConnection.iceConnectionState);\n        if (this.peerConnection.iceConnectionState === 'connected') {\n          if (typeof this.callbacks.onCallStarted === 'function') {\n            this.callbacks.onCallStarted();\n          }\n        }\n      };\n      this.peerConnection.ontrack = event => {\n        console.log('Remote track received:', event.streams[0]);\n        this.remoteStream = event.streams[0];\n        if (typeof this.callbacks.onRemoteStream === 'function') {\n          this.callbacks.onRemoteStream(this.remoteStream);\n        }\n      };\n      return this.peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Make a call to another user\n   * @param {string} targetUserId - The ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    if (!this.isInitialized) {\n      console.error('WebRTC service not initialized');\n      return;\n    }\n    this.targetUserId = targetUserId;\n    console.log(`Making call to user: ${targetUserId}`);\n    if (typeof this.callbacks.onCallConnecting === 'function') {\n      this.callbacks.onCallConnecting();\n    }\n    try {\n      // Ensure we have local media\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n\n      // Create a peer connection if one doesn't exist\n      if (!this.peerConnection) {\n        await this.createPeerConnection();\n      }\n\n      // Create an offer\n      const offer = await this.peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n\n      // Set local description\n      await this.peerConnection.setLocalDescription(offer);\n\n      // In a real app, we would send the offer to the other user via the signaling server\n      console.log('Created offer:', offer);\n\n      // For this demo, we'll simulate a call being accepted after a delay\n      setTimeout(() => {\n        // Simulate remote peer accepting the call\n        if (typeof this.callbacks.onCallStarted === 'function') {\n          this.callbacks.onCallStarted();\n        }\n\n        // Simulate receiving a remote stream\n        if (typeof this.callbacks.onRemoteStream === 'function') {\n          // For demo purposes, we'll use the local stream as the remote stream\n          this.callbacks.onRemoteStream(this.localStream);\n        }\n      }, 2000);\n    } catch (error) {\n      console.error('Error making call:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  acceptCall() {\n    console.log('Accepting call...');\n    if (typeof this.callbacks.onCallStarted === 'function') {\n      this.callbacks.onCallStarted();\n    }\n\n    // In a real implementation, this would create an answer and set it as the local description\n\n    // For demo purposes, we'll simulate the call being connected after a delay\n    setTimeout(() => {\n      // Simulate receiving a remote stream\n      if (typeof this.callbacks.onRemoteStream === 'function' && this.localStream) {\n        // For demo purposes, we'll use the local stream as the remote stream\n        this.callbacks.onRemoteStream(this.localStream);\n      }\n    }, 1000);\n  }\n\n  /**\n   * Toggle audio on/off\n   * @param {boolean} muted - Whether to mute the audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n      console.log(`Audio ${muted ? 'muted' : 'unmuted'}`);\n    }\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} off - Whether to turn off the video\n   */\n  toggleVideo(off) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        track.enabled = !off;\n      });\n      console.log(`Video ${off ? 'turned off' : 'turned on'}`);\n    }\n  }\n\n  /**\n   * End the current call\n   * @param {boolean} isInitiator - Whether this user initiated the call end\n   */\n  endCall(isInitiator = false) {\n    console.log('Ending call...');\n    if (isInitiator && this.targetUserId) {\n      // In a real app, notify the signaling server to inform the other user\n      console.log(`Notifying user ${this.targetUserId} that call has ended`);\n    }\n\n    // Stop all local tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n\n    // Close the peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    this.remoteStream = null;\n    this.targetUserId = null;\n    if (typeof this.callbacks.onCallEnded === 'function') {\n      this.callbacks.onCallEnded();\n    }\n  }\n\n  /**\n   * Disconnect from the signaling server and clean up\n   */\n  disconnect() {\n    console.log('Disconnecting WebRTC service...');\n    this.endCall();\n\n    // Close socket connection if there is one\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.isInitialized = false;\n    this.currentUserId = null;\n    this.callbacks = {};\n    console.log('WebRTC service disconnected');\n  }\n}\n\n// Export as a singleton\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["WebRTCService","constructor","localStream","peerConnection","remoteStream","currentUserId","targetUserId","callbacks","isInitialized","socket","configuration","iceServers","urls","initialize","userId","console","log","setTimeout","onIncomingCall","getLocalMedia","navigator","mediaDevices","getUserMedia","video","audio","onLocalStream","error","createPeerConnection","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","event","candidate","oniceconnectionstatechange","iceConnectionState","onCallStarted","ontrack","streams","onRemoteStream","makeCall","onCallConnecting","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","acceptCall","toggleAudio","muted","getAudioTracks","enabled","toggleVideo","off","getVideoTracks","endCall","isInitiator","stop","close","onCallEnded","disconnect","webRTCService"],"sources":["/Users/ang/V_Hack_Ver2/frontend/src/components/services/WebRTCService.js"],"sourcesContent":["// services/WebRTCService.js\n\n/**\n * Simple WebRTC service to handle video calls between users\n * This is a client-side implementation that works with the signaling server\n */\nclass WebRTCService {\n  constructor() {\n    this.localStream = null;\n    this.peerConnection = null;\n    this.remoteStream = null;\n    this.currentUserId = null;\n    this.targetUserId = null;\n    this.callbacks = {};\n    this.isInitialized = false;\n    this.socket = null;\n    this.configuration = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n      ]\n    };\n  }\n\n  /**\n   * Initialize the WebRTC service\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions for various events\n   */\n  initialize(userId, callbacks) {\n    if (this.isInitialized) {\n      console.log('WebRTC service already initialized');\n      return;\n    }\n\n    this.currentUserId = userId;\n    this.callbacks = callbacks || {};\n    this.isInitialized = true;\n\n    console.log('WebRTC service initialized for user:', userId);\n    \n    // In a real implementation, we would connect to the signaling server here\n    // For this demo, we'll simulate incoming calls after a delay\n    setTimeout(() => {\n      if (typeof this.callbacks.onIncomingCall === 'function') {\n        // Simulate an incoming call notification after 5 seconds for demo purposes\n        // In a real app, this would come from the signaling server\n        console.log('Simulating incoming call...');\n      }\n    }, 5000);\n  }\n\n  /**\n   * Get access to the user's camera and microphone\n   */\n  async getLocalMedia() {\n    try {\n      this.localStream = await navigator.mediaDevices.getUserMedia({ \n        video: true, \n        audio: true \n      });\n      \n      console.log('Got local media stream');\n      \n      if (typeof this.callbacks.onLocalStream === 'function') {\n        this.callbacks.onLocalStream(this.localStream);\n      }\n      \n      return this.localStream;\n    } catch (error) {\n      console.error('Error getting user media:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a peer connection and add local media tracks\n   */\n  async createPeerConnection() {\n    try {\n      this.peerConnection = new RTCPeerConnection(this.configuration);\n      \n      // Add local tracks to the peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          this.peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Set up event handlers for the peer connection\n      this.peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          console.log('New ICE candidate:', event.candidate);\n          // In a real app, we would send this to the signaling server\n          // this.socket.emit('ice-candidate', { targetUserId: this.targetUserId, candidate: event.candidate });\n        }\n      };\n      \n      this.peerConnection.oniceconnectionstatechange = () => {\n        console.log('ICE connection state:', this.peerConnection.iceConnectionState);\n        \n        if (this.peerConnection.iceConnectionState === 'connected') {\n          if (typeof this.callbacks.onCallStarted === 'function') {\n            this.callbacks.onCallStarted();\n          }\n        }\n      };\n      \n      this.peerConnection.ontrack = (event) => {\n        console.log('Remote track received:', event.streams[0]);\n        this.remoteStream = event.streams[0];\n        \n        if (typeof this.callbacks.onRemoteStream === 'function') {\n          this.callbacks.onRemoteStream(this.remoteStream);\n        }\n      };\n      \n      return this.peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Make a call to another user\n   * @param {string} targetUserId - The ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    if (!this.isInitialized) {\n      console.error('WebRTC service not initialized');\n      return;\n    }\n    \n    this.targetUserId = targetUserId;\n    console.log(`Making call to user: ${targetUserId}`);\n    \n    if (typeof this.callbacks.onCallConnecting === 'function') {\n      this.callbacks.onCallConnecting();\n    }\n    \n    try {\n      // Ensure we have local media\n      if (!this.localStream) {\n        await this.getLocalMedia();\n      }\n      \n      // Create a peer connection if one doesn't exist\n      if (!this.peerConnection) {\n        await this.createPeerConnection();\n      }\n      \n      // Create an offer\n      const offer = await this.peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      \n      // Set local description\n      await this.peerConnection.setLocalDescription(offer);\n      \n      // In a real app, we would send the offer to the other user via the signaling server\n      console.log('Created offer:', offer);\n      \n      // For this demo, we'll simulate a call being accepted after a delay\n      setTimeout(() => {\n        // Simulate remote peer accepting the call\n        if (typeof this.callbacks.onCallStarted === 'function') {\n          this.callbacks.onCallStarted();\n        }\n        \n        // Simulate receiving a remote stream\n        if (typeof this.callbacks.onRemoteStream === 'function') {\n          // For demo purposes, we'll use the local stream as the remote stream\n          this.callbacks.onRemoteStream(this.localStream);\n        }\n      }, 2000);\n      \n    } catch (error) {\n      console.error('Error making call:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  acceptCall() {\n    console.log('Accepting call...');\n    \n    if (typeof this.callbacks.onCallStarted === 'function') {\n      this.callbacks.onCallStarted();\n    }\n    \n    // In a real implementation, this would create an answer and set it as the local description\n    \n    // For demo purposes, we'll simulate the call being connected after a delay\n    setTimeout(() => {\n      // Simulate receiving a remote stream\n      if (typeof this.callbacks.onRemoteStream === 'function' && this.localStream) {\n        // For demo purposes, we'll use the local stream as the remote stream\n        this.callbacks.onRemoteStream(this.localStream);\n      }\n    }, 1000);\n  }\n  \n  /**\n   * Toggle audio on/off\n   * @param {boolean} muted - Whether to mute the audio\n   */\n  toggleAudio(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n      console.log(`Audio ${muted ? 'muted' : 'unmuted'}`);\n    }\n  }\n  \n  /**\n   * Toggle video on/off\n   * @param {boolean} off - Whether to turn off the video\n   */\n  toggleVideo(off) {\n    if (this.localStream) {\n      this.localStream.getVideoTracks().forEach(track => {\n        track.enabled = !off;\n      });\n      console.log(`Video ${off ? 'turned off' : 'turned on'}`);\n    }\n  }\n  \n  /**\n   * End the current call\n   * @param {boolean} isInitiator - Whether this user initiated the call end\n   */\n  endCall(isInitiator = false) {\n    console.log('Ending call...');\n    \n    if (isInitiator && this.targetUserId) {\n      // In a real app, notify the signaling server to inform the other user\n      console.log(`Notifying user ${this.targetUserId} that call has ended`);\n    }\n    \n    // Stop all local tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    \n    // Close the peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    \n    this.remoteStream = null;\n    this.targetUserId = null;\n    \n    if (typeof this.callbacks.onCallEnded === 'function') {\n      this.callbacks.onCallEnded();\n    }\n  }\n  \n  /**\n   * Disconnect from the signaling server and clean up\n   */\n  disconnect() {\n    console.log('Disconnecting WebRTC service...');\n    \n    this.endCall();\n    \n    // Close socket connection if there is one\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    \n    this.isInitialized = false;\n    this.currentUserId = null;\n    this.callbacks = {};\n    \n    console.log('WebRTC service disconnected');\n  }\n}\n\n// Export as a singleton\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}