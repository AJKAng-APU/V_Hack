{"ast":null,"code":"// WebRTCService.js - Fixed version with improved call stability and proper resource cleanup\nimport WebRTCEventEmitter from './WebRTCEventEmitter';\nimport WebRTCConnectionManager from './WebRTCConnectionManager';\nimport WebRTCMediaManager from './WebRTCMediaManager';\nimport WebRTCLogger from './WebRTCLogger';\nimport { createSignalingService } from './SignalingService';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management, error handling, and resource cleanup\n */\nclass WebRTCService {\n  constructor() {\n    // Public API: State Checking Methods\n    this.isCallActive = () => ['connecting', 'active'].includes(this.callState);\n    this.isCallConnected = () => this.callState === 'active';\n    this.hasRemoteStream = () => this.connectionManager && !!this.connectionManager.remoteStream;\n    // Create logger\n    this.logger = new WebRTCLogger();\n\n    // Create event emitter\n    this.eventEmitter = new WebRTCEventEmitter();\n\n    // Create media manager\n    this.mediaManager = new WebRTCMediaManager(this.logger);\n\n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n\n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n\n    // Initialize subsystems\n    this.connectionManager = null;\n    this.signalingService = null;\n\n    // Initialization state\n    this.isInitialized = false;\n\n    // Track state change timestamps to prevent rapid transitions\n    this.lastStateChangeTime = 0;\n    this.stateChangeDebounceMs = 300; // Minimum time between state changes\n\n    // Periodic state check\n    this.stateCheckInterval = null;\n\n    // Connection monitoring\n    this.connectionMonitorInterval = null;\n    this._disconnectionStartTime = undefined;\n    this._noMediaStartTime = undefined;\n\n    // Call end handling flag\n    this._handlingCallEnd = false;\n\n    // IMPORTANT: Add a flag to track if media has been properly released\n    this._mediaReleased = true;\n\n    // Track if we're a demo account for special handling\n    this._isDemoAccount = false;\n    this._isDoctorAccount = false;\n  }\n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n\n  // Public API: Call State Management with debouncing\n  updateCallState(newState) {\n    const now = Date.now();\n\n    // Always log state change requests\n    this.logger.log(`Call state change requested from ${this.callState} to ${newState}`);\n\n    // Prevent rapid state changes (except for 'ended' which should always happen)\n    if (newState !== 'ended' && now - this.lastStateChangeTime < this.stateChangeDebounceMs) {\n      this.logger.log(`Call state change debounced (${now - this.lastStateChangeTime}ms < ${this.stateChangeDebounceMs}ms)`);\n\n      // For 'active' state, schedule a delayed check to ensure it happens\n      if (newState === 'active' && this.callState !== 'active') {\n        setTimeout(() => {\n          if (this.callState !== 'active') {\n            this.logger.log('Delayed active state check - forcing state update');\n            this.forceStateUpdate('active');\n          }\n        }, this.stateChangeDebounceMs);\n      }\n      return;\n    }\n\n    // Prevent going backwards from active to connecting\n    if (this.callState === 'active' && newState === 'connecting') {\n      this.logger.log('Preventing state regression from active to connecting');\n      return;\n    }\n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n\n      // Set the state immediately\n      this.callState = newState;\n      this.lastStateChangeTime = now;\n\n      // Sync the UI immediately\n      this.eventEmitter.emit('callStateChanged', newState);\n\n      // For 'active' state, make extra sure all UI components know about it\n      if (newState === 'active') {\n        // Send additional update after short delay to ensure UI catches it\n        setTimeout(() => {\n          this.logger.log('Re-emitting active state after delay');\n          this.eventEmitter.emit('callStateChanged', 'active');\n\n          // Notify all callbacks\n          if (this.callbacks && this.callbacks.onCallStarted) {\n            this.callbacks.onCallStarted();\n          }\n        }, 500);\n\n        // Also notify after longer delay as backup\n        setTimeout(() => {\n          this.eventEmitter.emit('callStateChanged', 'active');\n        }, 2000);\n      }\n\n      // Trigger appropriate callbacks\n      if (this.callbacks) {\n        if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n        if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n        if (newState === 'connecting' && this.callbacks.onCallConnecting) this.callbacks.onCallConnecting();\n      }\n    } else if (newState === 'active') {\n      // Even if already in active state, re-emit to ensure UI sync\n      this.logger.log('Already in active state, but re-emitting to ensure UI sync');\n      this.eventEmitter.emit('callStateChanged', 'active');\n      if (this.callbacks && this.callbacks.onCallStarted) {\n        this.callbacks.onCallStarted();\n      }\n    }\n  }\n\n  // Force state update without debouncing\n  forceStateUpdate(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Forcing call state from ${this.callState} to ${newState}`);\n      this.callState = newState;\n      this.lastStateChangeTime = Date.now();\n      this.eventEmitter.emit('callStateChanged', newState);\n\n      // Trigger appropriate callbacks\n      if (this.callbacks) {\n        if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n        if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n      }\n    }\n  }\n  logCallState() {\n    this.logger.log(`Current call state: ${this.callState}`);\n    this.logger.log(`Is call active according to isCallActive(): ${this.isCallActive()}`);\n    this.logger.log(`Is call connected according to isCallConnected(): ${this.isCallConnected()}`);\n    if (this.connectionManager) {\n      this.logger.log(`Connection manager remote stream: ${!!this.connectionManager.remoteStream}`);\n      if (this.connectionManager.remoteStream) {\n        this.logger.log(`Remote stream tracks: ${this.connectionManager.remoteStream.getTracks().length}`);\n      }\n      this.logger.log(`ICE Connection state: ${this.connectionManager.iceConnectionState}`);\n    }\n\n    // Forced re-emission of state\n    this.eventEmitter.emit('callStateChanged', this.callState);\n  }\n\n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n\n    // Detect demo account or doctor account\n    this._isDemoAccount = userId === 'demo@healthsync.com' || userId.includes('demo');\n    this._isDoctorAccount = userId.startsWith('doctor-') || localStorage.getItem('is_doctor') === 'true';\n    this.logger.log(`Account type: ${this._isDemoAccount ? 'Demo' : 'Regular'}, ${this._isDoctorAccount ? 'Doctor' : 'Patient'}`);\n\n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n\n    // Create signaling service - ONLY ONCE\n    this.signalingService = createSignalingService(serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001', userId, this.handleSignalingEvents.bind(this));\n\n    // Configure socket settings for better reliability\n    if (this.signalingService && this.signalingService.socket) {\n      // Prevent disconnections\n      this.signalingService.socket.io.reconnection(true);\n      this.signalingService.socket.io.reconnectionAttempts(10);\n      this.signalingService.socket.io.reconnectionDelay(1000);\n      this.signalingService.socket.io.timeout(10000);\n\n      // Debug connection issues\n      this.signalingService.socket.on('connect', () => {\n        this.logger.log('Socket connected successfully!');\n        // Immediately register user ID again after reconnection\n        this.signalingService.send('register', userId);\n      });\n      this.signalingService.socket.on('disconnect', reason => {\n        this.logger.log('Socket disconnected, reason:', reason);\n      });\n    }\n\n    // Create connection manager with enhanced track handling\n    this.connectionManager = new WebRTCConnectionManager(this.signalingService, this.mediaManager, this.eventEmitter, this.logger, this.updateCallState.bind(this));\n\n    // Set up enhanced track detection\n    if (this.connectionManager) {\n      // Original handleTrackEvent had issues; patch it to ensure it emits events\n      const originalTrackHandler = this.connectionManager.handleTrackEvent;\n      this.connectionManager.handleTrackEvent = event => {\n        // Call the original handler\n        originalTrackHandler.call(this.connectionManager, event);\n\n        // Additional logging\n        this.logger.log(`Track received: ${event.track.kind}`);\n\n        // Emit track added event\n        this.eventEmitter.emit('remoteTrackAdded', {\n          kind: event.track.kind,\n          enabled: event.track.enabled,\n          id: event.track.id\n        });\n\n        // Force call to active state when tracks are received\n        this.updateCallState('active');\n      };\n    }\n\n    // Set up periodic state check\n    this.startStateCheck();\n\n    // Set up connection monitoring with less aggressive timeouts\n    this.startConnectionStateMonitoring();\n\n    // Mark media as not released so we know to clean it up later\n    this._mediaReleased = false;\n    this.isInitialized = true;\n  }\n\n  // Start periodic state check\n  startStateCheck() {\n    if (this.stateCheckInterval) {\n      clearInterval(this.stateCheckInterval);\n    }\n    this.stateCheckInterval = setInterval(() => {\n      // Check if we should be in active state but aren't\n      if (this.connectionManager && this.connectionManager.remoteStream && this.connectionManager.remoteStream.getTracks().length > 0 && this.callState !== 'active') {\n        this.logger.log('State check: Remote tracks detected but state is not active, forcing update');\n        this.forceStateUpdate('active');\n      }\n\n      // Check ICE connection state\n      if (this.connectionManager && this.connectionManager.peerConnection && ['connected', 'completed'].includes(this.connectionManager.peerConnection.iceConnectionState) && this.callState !== 'active') {\n        this.logger.log('State check: ICE connected but state is not active, forcing update');\n        this.forceStateUpdate('active');\n      }\n    }, 1000);\n  }\n\n  /**\n   * Start monitoring connection state with LESS AGGRESSIVE timeouts\n   * This adds an extra layer of reliability for detecting disconnections\n   */\n  startConnectionStateMonitoring() {\n    // Clear any existing interval\n    if (this.connectionMonitorInterval) {\n      clearInterval(this.connectionMonitorInterval);\n    }\n    this.connectionMonitorInterval = setInterval(() => {\n      // Only check when in an active call\n      if (this.callState !== 'active' && this.callState !== 'connecting') {\n        return;\n      }\n\n      // Check peer connection state\n      if (this.connectionManager && this.connectionManager.peerConnection) {\n        const connection = this.connectionManager.peerConnection;\n        const iceState = connection.iceConnectionState;\n        const connState = connection.connectionState;\n\n        // Less frequent logging to reduce noise\n        if (Math.random() < 0.2) {\n          // Log only ~20% of the time\n          this.logger.log(`Connection monitor - ICE: ${iceState}, Connection: ${connState}`);\n        }\n\n        // Detect disconnected or failed states\n        if ((iceState === 'disconnected' || iceState === 'failed' || connState === 'disconnected' || connState === 'failed') && this._disconnectionStartTime === undefined) {\n          // Start tracking disconnection time\n          this._disconnectionStartTime = Date.now();\n          this.logger.log('Detected potential disconnection, starting timer');\n        } else if ((iceState === 'disconnected' || iceState === 'failed' || connState === 'disconnected' || connState === 'failed') && this._disconnectionStartTime !== undefined) {\n          // LESS AGGRESSIVE: Check if disconnection has lasted too long (15 seconds instead of 8)\n          const disconnectionDuration = Date.now() - this._disconnectionStartTime;\n\n          // For demo/doctor accounts, be even more lenient\n          const disconnectionThreshold = this._isDemoAccount || this._isDoctorAccount ? 20000 : 15000;\n          if (disconnectionDuration > disconnectionThreshold) {\n            this.logger.log(`Disconnection lasted ${disconnectionDuration}ms, ending call`);\n            this._disconnectionStartTime = undefined;\n\n            // Force end the call\n            this.handleCallEnded();\n          }\n        } else if ((iceState === 'connected' || iceState === 'completed' || connState === 'connected') && this._disconnectionStartTime !== undefined) {\n          // Connection restored\n          this.logger.log('Connection restored after temporary disconnection');\n          this._disconnectionStartTime = undefined;\n        }\n\n        // Also check if we have any media flowing\n        if (this.connectionManager.remoteStream) {\n          const hasActiveTracks = this.connectionManager.remoteStream.getTracks().some(track => track.readyState === 'live');\n          if (!hasActiveTracks && this._noMediaStartTime === undefined) {\n            this._noMediaStartTime = Date.now();\n            this.logger.log('No active media tracks detected, starting timer');\n          } else if (!hasActiveTracks && this._noMediaStartTime !== undefined) {\n            const noMediaDuration = Date.now() - this._noMediaStartTime;\n\n            // LESS AGGRESSIVE: Longer timeout for no media (15 seconds instead of 10)\n            const noMediaThreshold = this._isDemoAccount || this._isDoctorAccount ? 20000 : 15000;\n            if (noMediaDuration > noMediaThreshold) {\n              this.logger.log(`No media for ${noMediaDuration}ms, ending call`);\n              this._noMediaStartTime = undefined;\n              this.handleCallEnded();\n            }\n          } else if (hasActiveTracks && this._noMediaStartTime !== undefined) {\n            this.logger.log('Media tracks restored');\n            this._noMediaStartTime = undefined;\n          }\n        }\n      }\n    }, 3000); // Check every 3 seconds instead of 2 to reduce processing overhead\n  }\n\n  /**\n   * End call with improved resource cleanup\n   * @param {boolean} notifyOther - Whether to notify the other party that the call is ending\n   */\n  endCall(notifyOther = true) {\n    const wasActive = this.callState !== 'idle' && this.callState !== 'ended';\n\n    // First set call state to ended\n    this.callState = 'ended';\n\n    // Update UI state immediately\n    this.eventEmitter.emit('callStateChanged', 'ended');\n\n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n\n    // Make sure we notify the other user about call ending\n    if (notifyOther && wasActive && this.signalingService && this.targetUserId) {\n      this.logger.log('Sending end-call signal to:', this.targetUserId);\n\n      // Send the end call signal - retry up to 3 times\n      let attempts = 0;\n      const sendEndCall = () => {\n        attempts++;\n        this.signalingService.send('end-call', {\n          targetUserId: this.targetUserId\n        });\n\n        // Also send direct-call-ended as backup\n        this.signalingService.send('direct-call-ended', {\n          targetUserId: this.targetUserId\n        });\n        if (attempts < 3) {\n          setTimeout(sendEndCall, 500); // Retry after 500ms\n        }\n      };\n      sendEndCall();\n    }\n\n    // IMPROVED: Stop the camera and microphone to release resources with better error handling\n    this.ensureCameraReleased();\n\n    // Reset state\n    this.pendingOffer = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n  }\n\n  /**\n   * CRITICAL: Ensure camera is released properly in all scenarios\n   */\n  ensureCameraReleased() {\n    if (!this._mediaReleased) {\n      this.logger.log('Ensuring camera and microphone resources are properly released');\n      try {\n        if (this.mediaManager) {\n          this.mediaManager.stopLocalStream();\n          this.logger.log('Successfully stopped local media stream');\n        }\n\n        // Also try to stop any tracks we might have in the connection manager\n        if (this.connectionManager && this.connectionManager.localStream) {\n          try {\n            const tracks = this.connectionManager.localStream.getTracks();\n            for (const track of tracks) {\n              track.stop();\n              this.logger.log(`Stopped connection manager track: ${track.kind}`);\n            }\n          } catch (err) {\n            this.logger.error('Error stopping connection manager tracks:', err.message);\n          }\n        }\n\n        // Double check with direct access to navigator.mediaDevices\n        try {\n          // This is a brute force approach to make absolutely sure all tracks are stopped\n          if (navigator.mediaDevices && navigator.mediaDevices.getTracks) {\n            const allTracks = navigator.mediaDevices.getTracks();\n            for (const track of allTracks) {\n              track.stop();\n              this.logger.log(`Stopped system track: ${track.kind}`);\n            }\n          }\n        } catch (e) {\n          this.logger.log('Navigator media devices direct access not available');\n        }\n\n        // For demo/doctor accounts, add a special alert if available\n        if ((this._isDemoAccount || this._isDoctorAccount) && typeof window !== 'undefined') {\n          try {\n            if (window.electronAPI && window.electronAPI.forceReleaseCamera) {\n              window.electronAPI.forceReleaseCamera();\n              this.logger.log('Forced camera release via electron API');\n            }\n          } catch (e) {\n            this.logger.log('Electron API not available for forced camera release');\n          }\n        }\n        this._mediaReleased = true;\n      } catch (error) {\n        this.logger.error('Error during camera cleanup:', error.message);\n\n        // Last resort: Try to access tracks directly from window object if they're stored there\n        try {\n          if (window.myLocalStream) {\n            const tracks = window.myLocalStream.getTracks();\n            for (const track of tracks) {\n              track.stop();\n              this.logger.log(`Stopped window-level track: ${track.kind}`);\n            }\n            window.myLocalStream = null;\n          }\n        } catch (e) {\n          this.logger.error('Error during last-resort camera cleanup:', e.message);\n        }\n      }\n    } else {\n      this.logger.log('Media already released, skipping cleanup');\n    }\n  }\n\n  /**\n   * Handle call ended event with improved connection management\n   */\n  handleCallEnded() {\n    this.logger.log('Call ended remotely');\n\n    // Set a flag to prevent multiple handlers\n    if (this._handlingCallEnd) {\n      this.logger.log('Already handling call end, ignoring duplicate event');\n      return;\n    }\n    this._handlingCallEnd = true;\n\n    // Immediately update UI state\n    this.forceStateUpdate('ended');\n\n    // IMPROVED: Make absolutely sure camera resources are released\n    this.ensureCameraReleased();\n\n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n      this.logger.log('Connection closed after remote end');\n    }\n\n    // Broadcast end event to UI with guaranteed delivery\n    this.eventEmitter.emit('callStateChanged', 'ended');\n    this.eventEmitter.emit('call-ended');\n\n    // Multiple attempts to ensure UI updates\n    [100, 500, 1000].forEach(delay => {\n      setTimeout(() => {\n        this.eventEmitter.emit('callStateChanged', 'ended');\n      }, delay);\n    });\n\n    // IMPORTANT: Add reconnection to signaling server if disconnected\n    setTimeout(() => {\n      if (this.signalingService && !this.signalingService.isConnected()) {\n        this.logger.log('Reconnecting to signaling server after call ended');\n\n        // Attempt to reconnect the socket\n        if (this.signalingService.socket && this.signalingService.socket.connect) {\n          this.signalingService.socket.connect();\n\n          // Re-register user ID after reconnection\n          setTimeout(() => {\n            if (this.signalingService.isConnected() && this.userId) {\n              this.signalingService.send('register', this.userId);\n              this.logger.log('Re-registered with signaling server');\n            }\n          }, 1000);\n        }\n      }\n\n      // Reset the handling flag after delay\n      this._handlingCallEnd = false;\n    }, 1500);\n\n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n\n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    this.logger.log(`Received signaling event: ${event}`, data);\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined();\n        break;\n      case 'call-in-progress':\n        this.updateCallState('ended');\n        if (this.callbacks && this.callbacks.onCallInProgress) {\n          this.callbacks.onCallInProgress(data.callerUserId, data.message);\n        }\n        break;\n      case 'direct-call-ended':\n        this.logger.log('Received direct call ended signal');\n        this.handleCallEnded();\n        break;\n      case 'ice-candidate':\n        if (this.connectionManager) {\n          this.connectionManager.addRemoteIceCandidate(data.candidate);\n        }\n        break;\n      case 'media-connected':\n        this.logger.log('Remote peer reports media connected');\n        this.forceStateUpdate('active'); // Use force update to bypass debouncing\n\n        // Force update UI regardless of previous state\n        if (this.callbacks && this.callbacks.onCallStarted) {\n          this.callbacks.onCallStarted();\n        }\n\n        // Ensure connection manager is also updated\n        if (this.connectionManager && this.connectionManager.remoteStream) {\n          this.logger.log('We have remote media and received media-connected signal, enforcing active state');\n          this.forceStateUpdate('active');\n        }\n        break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n\n  /**\n   * Handle incoming call event\n   */\n  handleIncomingCall(data) {\n    const {\n      callerUserId,\n      offerSDP\n    } = data;\n    this.logger.log('Incoming call from:', callerUserId);\n\n    // If there's already an active call, ignore this one\n    if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n      this.logger.log('Already in a call, ignoring incoming call');\n      // Explicitly decline the call so the caller knows\n      this.signalingService.send('call-declined', {\n        targetUserId: callerUserId\n      });\n      return;\n    }\n    this.targetUserId = callerUserId;\n\n    // Store the offer to use when call is accepted\n    if (this.connectionManager) {\n      this.connectionManager.setPendingOffer(offerSDP);\n    }\n\n    // Update call state\n    this.updateCallState('connecting');\n\n    // Notify the application of the incoming call\n    if (this.callbacks && this.callbacks.onIncomingCall) {\n      this.callbacks.onIncomingCall(callerUserId);\n    }\n  }\n\n  /**\n   * Handle call answered event\n   */\n  handleCallAnswered(data) {\n    const {\n      answerSDP\n    } = data;\n    this.logger.log('Call was answered, setting remote description');\n    if (this.connectionManager) {\n      this.connectionManager.setRemoteDescription(answerSDP);\n    }\n\n    // Start connection status checker\n    this.checkConnectionStatus();\n  }\n\n  /**\n   * Handle call declined event\n   */\n  handleCallDeclined() {\n    this.logger.log('Call was declined by the recipient');\n    this.updateCallState('ended');\n\n    // IMPROVED: Make sure camera is released when call is declined\n    this.ensureCameraReleased();\n\n    // Notify the application\n    if (this.callbacks && this.callbacks.onCallDeclined) {\n      this.callbacks.onCallDeclined();\n    }\n\n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n  checkConnectionStatus() {\n    let checkCount = 0;\n    const maxChecks = 10;\n    const interval = setInterval(() => {\n      checkCount++;\n\n      // If we have a remote stream but UI still shows connecting\n      if (this.connectionManager && this.connectionManager.remoteStream && this.connectionManager.remoteStream.getTracks().length > 0 && this.callState === 'connecting') {\n        this.logger.log('Media detected but call not active, forcing state update');\n        this.forceStateUpdate('active');\n      }\n      if (checkCount >= maxChecks || this.callState === 'active' || this.callState === 'ended') {\n        clearInterval(interval);\n      }\n    }, 1000);\n  }\n\n  /**\n   * Handle call failed event\n   */\n  handleCallFailed(data) {\n    const {\n      message,\n      targetUserId\n    } = data;\n    this.logger.log('Call failed:', message);\n\n    // Handle user not online case\n    if (message === 'User is not online') {\n      if (this.callbacks && this.callbacks.onUserNotOnline) {\n        this.callbacks.onUserNotOnline(targetUserId);\n      } else {\n        this.updateCallState('ended');\n      }\n    } else {\n      this.updateCallState('ended');\n    }\n\n    // IMPROVED: Ensure camera is released on call failure\n    this.ensureCameraReleased();\n\n    // Reset call state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n\n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n\n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n\n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: stream => {\n          // Ensure we update state to active when stream is received\n          this.forceStateUpdate('active');\n          this.callbacks.onRemoteStream(stream);\n        },\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n\n  /**\n   * Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    if (this.connectionManager) {\n      return this.connectionManager.attemptReconnection(aggressive);\n    }\n    return false;\n  }\n\n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Mark media as not released since we're starting a call\n      this._mediaReleased = false;\n\n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      if (!isOnline) {\n        this.logger.log('Cannot make call - user is not online:', targetUserId);\n        if (this.callbacks && this.callbacks.onUserNotOnline) {\n          this.callbacks.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        return;\n      }\n\n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.logger.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      this.logger.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n\n      // Initialize the call\n      if (this.connectionManager) {\n        await this.connectionManager.initiateCall(this.userId, targetUserId);\n      }\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to accept');\n      return;\n    }\n    try {\n      // Mark media as not released since we're accepting a call\n      this._mediaReleased = false;\n      this.logger.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n\n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n\n      // Accept the call\n      if (this.connectionManager) {\n        await this.connectionManager.acceptCall(this.targetUserId);\n      }\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n\n  /**\n   * Decline an incoming call\n   */\n  declineCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to decline');\n      return;\n    }\n    this.logger.log('Declining call from:', this.targetUserId);\n    if (this.signalingService) {\n      this.signalingService.send('call-declined', {\n        targetUserId: this.targetUserId\n      });\n    }\n\n    // Ensure camera resources are released on decline\n    this.ensureCameraReleased();\n\n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.callState = 'idle';\n  }\n\n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // Reset media released flag since we're getting new media\n      this._mediaReleased = false;\n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n\n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      return stream;\n    } catch (error) {\n      this.handleError('accessing media devices', error, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.mediaManager) {\n      this.mediaManager.toggleAudio(muted);\n    }\n  }\n\n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.mediaManager) {\n      this.mediaManager.toggleVideo(videoOff);\n    }\n  }\n\n  /**\n   * Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.logger.error(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n\n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n\n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n\n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n\n    // End any active call\n    this.endCall(true);\n\n    // Clear state check interval\n    if (this.stateCheckInterval) {\n      clearInterval(this.stateCheckInterval);\n      this.stateCheckInterval = null;\n    }\n\n    // Clear connection monitor interval\n    if (this.connectionMonitorInterval) {\n      clearInterval(this.connectionMonitorInterval);\n      this.connectionMonitorInterval = null;\n    }\n\n    // Ensure camera is released before disconnecting\n    this.ensureCameraReleased();\n\n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n\n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n\n    // Reset initialization status\n    this.isInitialized = false;\n\n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;","map":{"version":3,"names":["WebRTCEventEmitter","WebRTCConnectionManager","WebRTCMediaManager","WebRTCLogger","createSignalingService","WebRTCService","constructor","isCallActive","includes","callState","isCallConnected","hasRemoteStream","connectionManager","remoteStream","logger","eventEmitter","mediaManager","userId","targetUserId","signalingService","isInitialized","lastStateChangeTime","stateChangeDebounceMs","stateCheckInterval","connectionMonitorInterval","_disconnectionStartTime","undefined","_noMediaStartTime","_handlingCallEnd","_mediaReleased","_isDemoAccount","_isDoctorAccount","on","event","callback","updateCallState","newState","now","Date","log","setTimeout","forceStateUpdate","emit","callbacks","onCallStarted","onCallEnded","onCallConnecting","logCallState","getTracks","length","iceConnectionState","initialize","serverUrl","updateCallbacks","disconnect","startsWith","localStorage","getItem","process","env","REACT_APP_SIGNALING_SERVER","handleSignalingEvents","bind","socket","io","reconnection","reconnectionAttempts","reconnectionDelay","timeout","send","reason","originalTrackHandler","handleTrackEvent","call","track","kind","enabled","id","startStateCheck","startConnectionStateMonitoring","clearInterval","setInterval","peerConnection","connection","iceState","connState","connectionState","Math","random","disconnectionDuration","disconnectionThreshold","handleCallEnded","hasActiveTracks","some","readyState","noMediaDuration","noMediaThreshold","endCall","notifyOther","wasActive","closeConnection","attempts","sendEndCall","ensureCameraReleased","pendingOffer","isCallInitiator","stopLocalStream","localStream","tracks","stop","err","error","message","navigator","mediaDevices","allTracks","e","window","electronAPI","forceReleaseCamera","myLocalStream","forEach","delay","isConnected","connect","data","handleIncomingCall","handleCallAnswered","handleCallDeclined","onCallInProgress","callerUserId","addRemoteIceCandidate","candidate","handleCallFailed","offerSDP","setPendingOffer","onIncomingCall","answerSDP","setRemoteDescription","checkConnectionStatus","onCallDeclined","checkCount","maxChecks","interval","onUserNotOnline","onLocalStream","onRemoteStream","onICEConnectionStateChange","setCallbacks","stream","checkUserOnline","attemptReconnection","aggressive","makeCall","isOnline","hasLocalStream","getLocalMedia","initiateCall","handleError","acceptCall","declineCall","videoConstraints","audioConstraints","setLocalStream","toggleAudio","muted","toggleVideo","videoOff","context","fatal","console","cleanup","webRTCService"],"sources":["/Users/ang/V_Hack_Ver3/frontend2/src/components/services/WebRTCService.js"],"sourcesContent":["// WebRTCService.js - Fixed version with improved call stability and proper resource cleanup\nimport WebRTCEventEmitter from './WebRTCEventEmitter';\nimport WebRTCConnectionManager from './WebRTCConnectionManager';\nimport WebRTCMediaManager from './WebRTCMediaManager';\nimport WebRTCLogger from './WebRTCLogger';\nimport { createSignalingService } from './SignalingService';\n\n/**\n * Service that handles WebRTC connections for video calling\n * Enhanced with better state management, error handling, and resource cleanup\n */\nclass WebRTCService {\n  constructor() {\n    // Create logger\n    this.logger = new WebRTCLogger();\n    \n    // Create event emitter\n    this.eventEmitter = new WebRTCEventEmitter();\n    \n    // Create media manager\n    this.mediaManager = new WebRTCMediaManager(this.logger);\n    \n    // User identifiers\n    this.userId = null;\n    this.targetUserId = null;\n    \n    // Call state\n    this.callState = 'idle'; // idle, connecting, active, ended\n    \n    // Initialize subsystems\n    this.connectionManager = null;\n    this.signalingService = null;\n    \n    // Initialization state\n    this.isInitialized = false;\n    \n    // Track state change timestamps to prevent rapid transitions\n    this.lastStateChangeTime = 0;\n    this.stateChangeDebounceMs = 300; // Minimum time between state changes\n    \n    // Periodic state check\n    this.stateCheckInterval = null;\n    \n    // Connection monitoring\n    this.connectionMonitorInterval = null;\n    this._disconnectionStartTime = undefined;\n    this._noMediaStartTime = undefined;\n    \n    // Call end handling flag\n    this._handlingCallEnd = false;\n    \n    // IMPORTANT: Add a flag to track if media has been properly released\n    this._mediaReleased = true;\n    \n    // Track if we're a demo account for special handling\n    this._isDemoAccount = false;\n    this._isDoctorAccount = false;\n  }\n  \n  // Public API: State Checking Methods\n  isCallActive = () => ['connecting', 'active'].includes(this.callState);\n  isCallConnected = () => this.callState === 'active';\n  hasRemoteStream = () => this.connectionManager && !!this.connectionManager.remoteStream;\n  \n  // Public API: Event Management\n  on(event, callback) {\n    return this.eventEmitter.on(event, callback);\n  }\n  \n  // Public API: Call State Management with debouncing\n  updateCallState(newState) {\n    const now = Date.now();\n    \n    // Always log state change requests\n    this.logger.log(`Call state change requested from ${this.callState} to ${newState}`);\n    \n    // Prevent rapid state changes (except for 'ended' which should always happen)\n    if (newState !== 'ended' && now - this.lastStateChangeTime < this.stateChangeDebounceMs) {\n      this.logger.log(`Call state change debounced (${now - this.lastStateChangeTime}ms < ${this.stateChangeDebounceMs}ms)`);\n      \n      // For 'active' state, schedule a delayed check to ensure it happens\n      if (newState === 'active' && this.callState !== 'active') {\n        setTimeout(() => {\n          if (this.callState !== 'active') {\n            this.logger.log('Delayed active state check - forcing state update');\n            this.forceStateUpdate('active');\n          }\n        }, this.stateChangeDebounceMs);\n      }\n      return;\n    }\n    \n    // Prevent going backwards from active to connecting\n    if (this.callState === 'active' && newState === 'connecting') {\n      this.logger.log('Preventing state regression from active to connecting');\n      return;\n    }\n    \n    if (this.callState !== newState) {\n      this.logger.log(`Call state changing from ${this.callState} to ${newState}`);\n      \n      // Set the state immediately\n      this.callState = newState;\n      this.lastStateChangeTime = now;\n      \n      // Sync the UI immediately\n      this.eventEmitter.emit('callStateChanged', newState);\n      \n      // For 'active' state, make extra sure all UI components know about it\n      if (newState === 'active') {\n        // Send additional update after short delay to ensure UI catches it\n        setTimeout(() => {\n          this.logger.log('Re-emitting active state after delay');\n          this.eventEmitter.emit('callStateChanged', 'active');\n          \n          // Notify all callbacks\n          if (this.callbacks && this.callbacks.onCallStarted) {\n            this.callbacks.onCallStarted();\n          }\n        }, 500);\n        \n        // Also notify after longer delay as backup\n        setTimeout(() => {\n          this.eventEmitter.emit('callStateChanged', 'active');\n        }, 2000);\n      }\n      \n      // Trigger appropriate callbacks\n      if (this.callbacks) {\n        if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n        if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n        if (newState === 'connecting' && this.callbacks.onCallConnecting) this.callbacks.onCallConnecting();\n      }\n    } else if (newState === 'active') {\n      // Even if already in active state, re-emit to ensure UI sync\n      this.logger.log('Already in active state, but re-emitting to ensure UI sync');\n      this.eventEmitter.emit('callStateChanged', 'active');\n      \n      if (this.callbacks && this.callbacks.onCallStarted) {\n        this.callbacks.onCallStarted();\n      }\n    }\n  }\n\n  // Force state update without debouncing\n  forceStateUpdate(newState) {\n    if (this.callState !== newState) {\n      this.logger.log(`Forcing call state from ${this.callState} to ${newState}`);\n      this.callState = newState;\n      this.lastStateChangeTime = Date.now();\n      this.eventEmitter.emit('callStateChanged', newState);\n      \n      // Trigger appropriate callbacks\n      if (this.callbacks) {\n        if (newState === 'active' && this.callbacks.onCallStarted) this.callbacks.onCallStarted();\n        if (newState === 'ended' && this.callbacks.onCallEnded) this.callbacks.onCallEnded();\n      }\n    }\n  }\n\n  logCallState() {\n    this.logger.log(`Current call state: ${this.callState}`);\n    this.logger.log(`Is call active according to isCallActive(): ${this.isCallActive()}`);\n    this.logger.log(`Is call connected according to isCallConnected(): ${this.isCallConnected()}`);\n    \n    if (this.connectionManager) {\n      this.logger.log(`Connection manager remote stream: ${!!this.connectionManager.remoteStream}`);\n      if (this.connectionManager.remoteStream) {\n        this.logger.log(`Remote stream tracks: ${this.connectionManager.remoteStream.getTracks().length}`);\n      }\n      this.logger.log(`ICE Connection state: ${this.connectionManager.iceConnectionState}`);\n    }\n    \n    // Forced re-emission of state\n    this.eventEmitter.emit('callStateChanged', this.callState);\n  }\n  \n  /**\n   * Initialize the WebRTC service with user information and callbacks\n   * @param {string} userId - The current user's ID\n   * @param {object} callbacks - Callback functions to handle events\n   * @param {string} serverUrl - The URL of the signaling server (optional)\n   */\n  initialize(userId, callbacks = {}, serverUrl = null) {\n    // If already initialized with the same ID, just update callbacks\n    if (this.isInitialized && this.userId === userId) {\n      this.logger.log('WebRTC service already initialized for user:', userId, '- updating callbacks only');\n      this.updateCallbacks(callbacks);\n      return;\n    }\n\n    // If initialized with a different ID, disconnect first\n    if (this.isInitialized && this.userId !== userId) {\n      this.logger.log('Reinitializing with new user ID - disconnecting first');\n      this.disconnect();\n    }\n    \n    this.logger.log('Initializing WebRTC service for user:', userId);\n    this.userId = userId;\n    \n    // Detect demo account or doctor account\n    this._isDemoAccount = userId === 'demo@healthsync.com' || userId.includes('demo');\n    this._isDoctorAccount = userId.startsWith('doctor-') || localStorage.getItem('is_doctor') === 'true';\n    \n    this.logger.log(`Account type: ${this._isDemoAccount ? 'Demo' : 'Regular'}, ${this._isDoctorAccount ? 'Doctor' : 'Patient'}`);\n    \n    // Set up callbacks\n    this.callbacks = {};\n    this.updateCallbacks(callbacks);\n    \n    // Create signaling service - ONLY ONCE\n    this.signalingService = createSignalingService(\n      serverUrl || process.env.REACT_APP_SIGNALING_SERVER || 'http://localhost:3001',\n      userId,\n      this.handleSignalingEvents.bind(this)\n    );\n    \n    // Configure socket settings for better reliability\n    if (this.signalingService && this.signalingService.socket) {\n      // Prevent disconnections\n      this.signalingService.socket.io.reconnection(true);\n      this.signalingService.socket.io.reconnectionAttempts(10);\n      this.signalingService.socket.io.reconnectionDelay(1000);\n      this.signalingService.socket.io.timeout(10000);\n      \n      // Debug connection issues\n      this.signalingService.socket.on('connect', () => {\n        this.logger.log('Socket connected successfully!');\n        // Immediately register user ID again after reconnection\n        this.signalingService.send('register', userId);\n      });\n      \n      this.signalingService.socket.on('disconnect', (reason) => {\n        this.logger.log('Socket disconnected, reason:', reason);\n      });\n    }\n    \n    // Create connection manager with enhanced track handling\n    this.connectionManager = new WebRTCConnectionManager(\n      this.signalingService,\n      this.mediaManager,\n      this.eventEmitter,\n      this.logger,\n      this.updateCallState.bind(this)\n    );\n    \n    // Set up enhanced track detection\n    if (this.connectionManager) {\n      // Original handleTrackEvent had issues; patch it to ensure it emits events\n      const originalTrackHandler = this.connectionManager.handleTrackEvent;\n      this.connectionManager.handleTrackEvent = (event) => {\n        // Call the original handler\n        originalTrackHandler.call(this.connectionManager, event);\n        \n        // Additional logging\n        this.logger.log(`Track received: ${event.track.kind}`);\n        \n        // Emit track added event\n        this.eventEmitter.emit('remoteTrackAdded', {\n          kind: event.track.kind,\n          enabled: event.track.enabled,\n          id: event.track.id\n        });\n        \n        // Force call to active state when tracks are received\n        this.updateCallState('active');\n      };\n    }\n    \n    // Set up periodic state check\n    this.startStateCheck();\n    \n    // Set up connection monitoring with less aggressive timeouts\n    this.startConnectionStateMonitoring();\n    \n    // Mark media as not released so we know to clean it up later\n    this._mediaReleased = false;\n    \n    this.isInitialized = true;\n  }\n\n  // Start periodic state check\n  startStateCheck() {\n    if (this.stateCheckInterval) {\n      clearInterval(this.stateCheckInterval);\n    }\n    \n    this.stateCheckInterval = setInterval(() => {\n      // Check if we should be in active state but aren't\n      if (this.connectionManager && \n          this.connectionManager.remoteStream && \n          this.connectionManager.remoteStream.getTracks().length > 0 && \n          this.callState !== 'active') {\n        this.logger.log('State check: Remote tracks detected but state is not active, forcing update');\n        this.forceStateUpdate('active');\n      }\n      \n      // Check ICE connection state\n      if (this.connectionManager && \n          this.connectionManager.peerConnection &&\n          ['connected', 'completed'].includes(this.connectionManager.peerConnection.iceConnectionState) &&\n          this.callState !== 'active') {\n        this.logger.log('State check: ICE connected but state is not active, forcing update');\n        this.forceStateUpdate('active');\n      }\n    }, 1000);\n  }\n\n  /**\n   * Start monitoring connection state with LESS AGGRESSIVE timeouts\n   * This adds an extra layer of reliability for detecting disconnections\n   */\n  startConnectionStateMonitoring() {\n    // Clear any existing interval\n    if (this.connectionMonitorInterval) {\n      clearInterval(this.connectionMonitorInterval);\n    }\n    \n    this.connectionMonitorInterval = setInterval(() => {\n      // Only check when in an active call\n      if (this.callState !== 'active' && this.callState !== 'connecting') {\n        return;\n      }\n      \n      // Check peer connection state\n      if (this.connectionManager && this.connectionManager.peerConnection) {\n        const connection = this.connectionManager.peerConnection;\n        const iceState = connection.iceConnectionState;\n        const connState = connection.connectionState;\n        \n        // Less frequent logging to reduce noise\n        if (Math.random() < 0.2) { // Log only ~20% of the time\n          this.logger.log(`Connection monitor - ICE: ${iceState}, Connection: ${connState}`);\n        }\n        \n        // Detect disconnected or failed states\n        if ((iceState === 'disconnected' || iceState === 'failed' || \n             connState === 'disconnected' || connState === 'failed') && \n            this._disconnectionStartTime === undefined) {\n          \n          // Start tracking disconnection time\n          this._disconnectionStartTime = Date.now();\n          this.logger.log('Detected potential disconnection, starting timer');\n          \n        } else if ((iceState === 'disconnected' || iceState === 'failed' || \n                   connState === 'disconnected' || connState === 'failed') && \n                  this._disconnectionStartTime !== undefined) {\n          \n          // LESS AGGRESSIVE: Check if disconnection has lasted too long (15 seconds instead of 8)\n          const disconnectionDuration = Date.now() - this._disconnectionStartTime;\n          \n          // For demo/doctor accounts, be even more lenient\n          const disconnectionThreshold = (this._isDemoAccount || this._isDoctorAccount) ? 20000 : 15000;\n          \n          if (disconnectionDuration > disconnectionThreshold) {\n            this.logger.log(`Disconnection lasted ${disconnectionDuration}ms, ending call`);\n            this._disconnectionStartTime = undefined;\n            \n            // Force end the call\n            this.handleCallEnded();\n          }\n          \n        } else if ((iceState === 'connected' || iceState === 'completed' || \n                   connState === 'connected') && \n                  this._disconnectionStartTime !== undefined) {\n          \n          // Connection restored\n          this.logger.log('Connection restored after temporary disconnection');\n          this._disconnectionStartTime = undefined;\n        }\n        \n        // Also check if we have any media flowing\n        if (this.connectionManager.remoteStream) {\n          const hasActiveTracks = this.connectionManager.remoteStream.getTracks().some(\n            track => track.readyState === 'live'\n          );\n          \n          if (!hasActiveTracks && this._noMediaStartTime === undefined) {\n            this._noMediaStartTime = Date.now();\n            this.logger.log('No active media tracks detected, starting timer');\n          } else if (!hasActiveTracks && this._noMediaStartTime !== undefined) {\n            const noMediaDuration = Date.now() - this._noMediaStartTime;\n            \n            // LESS AGGRESSIVE: Longer timeout for no media (15 seconds instead of 10)\n            const noMediaThreshold = (this._isDemoAccount || this._isDoctorAccount) ? 20000 : 15000;\n            \n            if (noMediaDuration > noMediaThreshold) {\n              this.logger.log(`No media for ${noMediaDuration}ms, ending call`);\n              this._noMediaStartTime = undefined;\n              this.handleCallEnded();\n            }\n          } else if (hasActiveTracks && this._noMediaStartTime !== undefined) {\n            this.logger.log('Media tracks restored');\n            this._noMediaStartTime = undefined;\n          }\n        }\n      }\n    }, 3000); // Check every 3 seconds instead of 2 to reduce processing overhead\n  }\n\n  /**\n   * End call with improved resource cleanup\n   * @param {boolean} notifyOther - Whether to notify the other party that the call is ending\n   */\n  endCall(notifyOther = true) {\n    const wasActive = this.callState !== 'idle' && this.callState !== 'ended';\n    \n    // First set call state to ended\n    this.callState = 'ended';\n    \n    // Update UI state immediately\n    this.eventEmitter.emit('callStateChanged', 'ended');\n    \n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n    }\n    \n    // Make sure we notify the other user about call ending\n    if (notifyOther && wasActive && this.signalingService && this.targetUserId) {\n      this.logger.log('Sending end-call signal to:', this.targetUserId);\n      \n      // Send the end call signal - retry up to 3 times\n      let attempts = 0;\n      const sendEndCall = () => {\n        attempts++;\n        this.signalingService.send('end-call', {\n          targetUserId: this.targetUserId\n        });\n        \n        // Also send direct-call-ended as backup\n        this.signalingService.send('direct-call-ended', {\n          targetUserId: this.targetUserId\n        });\n        \n        if (attempts < 3) {\n          setTimeout(sendEndCall, 500); // Retry after 500ms\n        }\n      };\n      \n      sendEndCall();\n    }\n    \n    // IMPROVED: Stop the camera and microphone to release resources with better error handling\n    this.ensureCameraReleased();\n    \n    // Reset state\n    this.pendingOffer = null;\n    this.targetUserId = null;\n    this.isCallInitiator = false;\n  }\n\n  /**\n   * CRITICAL: Ensure camera is released properly in all scenarios\n   */\n  ensureCameraReleased() {\n    if (!this._mediaReleased) {\n      this.logger.log('Ensuring camera and microphone resources are properly released');\n      \n      try {\n        if (this.mediaManager) {\n          this.mediaManager.stopLocalStream();\n          this.logger.log('Successfully stopped local media stream');\n        }\n        \n        // Also try to stop any tracks we might have in the connection manager\n        if (this.connectionManager && this.connectionManager.localStream) {\n          try {\n            const tracks = this.connectionManager.localStream.getTracks();\n            for (const track of tracks) {\n              track.stop();\n              this.logger.log(`Stopped connection manager track: ${track.kind}`);\n            }\n          } catch (err) {\n            this.logger.error('Error stopping connection manager tracks:', err.message);\n          }\n        }\n        \n        // Double check with direct access to navigator.mediaDevices\n        try {\n          // This is a brute force approach to make absolutely sure all tracks are stopped\n          if (navigator.mediaDevices && navigator.mediaDevices.getTracks) {\n            const allTracks = navigator.mediaDevices.getTracks();\n            for (const track of allTracks) {\n              track.stop();\n              this.logger.log(`Stopped system track: ${track.kind}`);\n            }\n          }\n        } catch (e) {\n          this.logger.log('Navigator media devices direct access not available');\n        }\n        \n        // For demo/doctor accounts, add a special alert if available\n        if ((this._isDemoAccount || this._isDoctorAccount) && typeof window !== 'undefined') {\n          try {\n            if (window.electronAPI && window.electronAPI.forceReleaseCamera) {\n              window.electronAPI.forceReleaseCamera();\n              this.logger.log('Forced camera release via electron API');\n            }\n          } catch (e) {\n            this.logger.log('Electron API not available for forced camera release');\n          }\n        }\n        \n        this._mediaReleased = true;\n      } catch (error) {\n        this.logger.error('Error during camera cleanup:', error.message);\n        \n        // Last resort: Try to access tracks directly from window object if they're stored there\n        try {\n          if (window.myLocalStream) {\n            const tracks = window.myLocalStream.getTracks();\n            for (const track of tracks) {\n              track.stop();\n              this.logger.log(`Stopped window-level track: ${track.kind}`);\n            }\n            window.myLocalStream = null;\n          }\n        } catch (e) {\n          this.logger.error('Error during last-resort camera cleanup:', e.message);\n        }\n      }\n    } else {\n      this.logger.log('Media already released, skipping cleanup');\n    }\n  }\n\n  /**\n   * Handle call ended event with improved connection management\n   */\n  handleCallEnded() {\n    this.logger.log('Call ended remotely');\n    \n    // Set a flag to prevent multiple handlers\n    if (this._handlingCallEnd) {\n      this.logger.log('Already handling call end, ignoring duplicate event');\n      return;\n    }\n    this._handlingCallEnd = true;\n    \n    // Immediately update UI state\n    this.forceStateUpdate('ended');\n    \n    // IMPROVED: Make absolutely sure camera resources are released\n    this.ensureCameraReleased();\n    \n    // Clean up connection\n    if (this.connectionManager) {\n      this.connectionManager.closeConnection();\n      this.logger.log('Connection closed after remote end');\n    }\n    \n    // Broadcast end event to UI with guaranteed delivery\n    this.eventEmitter.emit('callStateChanged', 'ended');\n    this.eventEmitter.emit('call-ended');\n    \n    // Multiple attempts to ensure UI updates\n    [100, 500, 1000].forEach(delay => {\n      setTimeout(() => {\n        this.eventEmitter.emit('callStateChanged', 'ended');\n      }, delay);\n    });\n    \n    // IMPORTANT: Add reconnection to signaling server if disconnected\n    setTimeout(() => {\n      if (this.signalingService && !this.signalingService.isConnected()) {\n        this.logger.log('Reconnecting to signaling server after call ended');\n        \n        // Attempt to reconnect the socket\n        if (this.signalingService.socket && this.signalingService.socket.connect) {\n          this.signalingService.socket.connect();\n          \n          // Re-register user ID after reconnection\n          setTimeout(() => {\n            if (this.signalingService.isConnected() && this.userId) {\n              this.signalingService.send('register', this.userId);\n              this.logger.log('Re-registered with signaling server');\n            }\n          }, 1000);\n        }\n      }\n      \n      // Reset the handling flag after delay\n      this._handlingCallEnd = false;\n    }, 1500);\n    \n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n  \n  /**\n   * Handle all signaling events\n   */\n  handleSignalingEvents(event, data) {\n    this.logger.log(`Received signaling event: ${event}`, data);\n    switch (event) {\n      case 'incoming-call':\n        this.handleIncomingCall(data);\n        break;\n      case 'call-answered':\n        this.handleCallAnswered(data);\n        break;\n      case 'call-declined':\n        this.handleCallDeclined();\n        break;\n      case 'call-in-progress':\n        this.updateCallState('ended'); \n        if (this.callbacks && this.callbacks.onCallInProgress) {\n          this.callbacks.onCallInProgress(data.callerUserId, data.message);\n        }\n        break;\n      case 'direct-call-ended':\n        this.logger.log('Received direct call ended signal');\n        this.handleCallEnded();\n        break;\n      case 'ice-candidate':\n        if (this.connectionManager) {\n          this.connectionManager.addRemoteIceCandidate(data.candidate);\n        }\n        break;\n      case 'media-connected':\n        this.logger.log('Remote peer reports media connected');\n        this.forceStateUpdate('active'); // Use force update to bypass debouncing\n        \n        // Force update UI regardless of previous state\n        if (this.callbacks && this.callbacks.onCallStarted) {\n          this.callbacks.onCallStarted();\n        }\n        \n        // Ensure connection manager is also updated\n        if (this.connectionManager && this.connectionManager.remoteStream) {\n          this.logger.log('We have remote media and received media-connected signal, enforcing active state');\n          this.forceStateUpdate('active');\n        }\n        break;\n      case 'call-ended':\n        this.handleCallEnded();\n        break;\n      case 'call-failed':\n        this.handleCallFailed(data);\n        break;\n      default:\n        this.logger.log('Unknown signaling event:', event, data);\n    }\n  }\n  \n  /**\n   * Handle incoming call event\n   */\n  handleIncomingCall(data) {\n    const { callerUserId, offerSDP } = data;\n    this.logger.log('Incoming call from:', callerUserId);\n    \n    // If there's already an active call, ignore this one\n    if (this.isCallActive() || this.callState === 'active' || this.callState === 'connecting') {\n      this.logger.log('Already in a call, ignoring incoming call');\n      // Explicitly decline the call so the caller knows\n      this.signalingService.send('call-declined', { targetUserId: callerUserId });\n      return;\n    }\n    \n    this.targetUserId = callerUserId;\n    \n    // Store the offer to use when call is accepted\n    if (this.connectionManager) {\n      this.connectionManager.setPendingOffer(offerSDP);\n    }\n    \n    // Update call state\n    this.updateCallState('connecting');\n    \n    // Notify the application of the incoming call\n    if (this.callbacks && this.callbacks.onIncomingCall) {\n      this.callbacks.onIncomingCall(callerUserId);\n    }\n  }\n  \n  /**\n   * Handle call answered event\n   */\n  handleCallAnswered(data) {\n    const { answerSDP } = data;\n    this.logger.log('Call was answered, setting remote description');\n    \n    if (this.connectionManager) {\n      this.connectionManager.setRemoteDescription(answerSDP);\n    }\n    \n    // Start connection status checker\n    this.checkConnectionStatus();\n  }\n  \n  /**\n   * Handle call declined event\n   */\n  handleCallDeclined() {\n    this.logger.log('Call was declined by the recipient');\n    this.updateCallState('ended');\n    \n    // IMPROVED: Make sure camera is released when call is declined\n    this.ensureCameraReleased();\n    \n    // Notify the application\n    if (this.callbacks && this.callbacks.onCallDeclined) {\n      this.callbacks.onCallDeclined();\n    }\n    \n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n\n  checkConnectionStatus() {\n    let checkCount = 0;\n    const maxChecks = 10;\n    \n    const interval = setInterval(() => {\n      checkCount++;\n      \n      // If we have a remote stream but UI still shows connecting\n      if (this.connectionManager && \n          this.connectionManager.remoteStream &&\n          this.connectionManager.remoteStream.getTracks().length > 0 &&\n          this.callState === 'connecting') {\n        \n        this.logger.log('Media detected but call not active, forcing state update');\n        this.forceStateUpdate('active');\n      }\n      \n      if (checkCount >= maxChecks || this.callState === 'active' || this.callState === 'ended') {\n        clearInterval(interval);\n      }\n    }, 1000);\n  }\n  \n  /**\n   * Handle call failed event\n   */\n  handleCallFailed(data) {\n    const { message, targetUserId } = data;\n    this.logger.log('Call failed:', message);\n    \n    // Handle user not online case\n    if (message === 'User is not online') {\n      if (this.callbacks && this.callbacks.onUserNotOnline) {\n        this.callbacks.onUserNotOnline(targetUserId);\n      } else {\n        this.updateCallState('ended');\n      }\n    } else {\n      this.updateCallState('ended');\n    }\n    \n    // IMPROVED: Ensure camera is released on call failure\n    this.ensureCameraReleased();\n    \n    // Reset call state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.isCallInitiator = false;\n  }\n  \n  /**\n   * Update callback functions\n   * @param {object} callbacks - Callback functions to update\n   */\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = {\n      ...this.callbacks,\n      ...callbacks\n    };\n    \n    // Initialize default callback functions if not already set\n    this.callbacks.onLocalStream = this.callbacks.onLocalStream || (() => {});\n    this.callbacks.onRemoteStream = this.callbacks.onRemoteStream || (() => {});\n    this.callbacks.onCallStarted = this.callbacks.onCallStarted || (() => {});\n    this.callbacks.onCallEnded = this.callbacks.onCallEnded || (() => {});\n    this.callbacks.onCallConnecting = this.callbacks.onCallConnecting || (() => {});\n    this.callbacks.onIncomingCall = this.callbacks.onIncomingCall || (() => {});\n    this.callbacks.onICEConnectionStateChange = this.callbacks.onICEConnectionStateChange || (() => {});\n    this.callbacks.onUserNotOnline = this.callbacks.onUserNotOnline || (() => {});\n    this.callbacks.onCallDeclined = this.callbacks.onCallDeclined || (() => {});\n    this.callbacks.onCallInProgress = this.callbacks.onCallInProgress || (() => {});\n    \n    // Pass appropriate callbacks to managers\n    if (this.connectionManager) {\n      this.connectionManager.setCallbacks({\n        onRemoteStream: stream => {\n          // Ensure we update state to active when stream is received\n          this.forceStateUpdate('active');\n          this.callbacks.onRemoteStream(stream);\n        },\n        onICEConnectionStateChange: this.callbacks.onICEConnectionStateChange\n      });\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.setCallbacks({\n        onLocalStream: this.callbacks.onLocalStream\n      });\n    }\n  }\n  \n  /**\n   * Check if a user is online with request ID for reliable responses\n   * @param {string} userId - ID of the user to check\n   * @returns {Promise<boolean>} - Whether the user is online\n   */\n  async checkUserOnline(userId) {\n    if (!this.signalingService || !this.signalingService.isConnected()) {\n      this.logger.log('Socket not connected, user is offline');\n      return false;\n    }\n    \n    try {\n      return await this.signalingService.checkUserOnline(userId);\n    } catch (error) {\n      this.logger.log('Error checking if user is online:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Attempt to reconnect during call problems\n   * @param {boolean} aggressive - Whether to use more aggressive reconnection tactics\n   */\n  async attemptReconnection(aggressive = false) {\n    if (this.connectionManager) {\n      return this.connectionManager.attemptReconnection(aggressive);\n    }\n    return false;\n  }\n  \n  /**\n   * Initiate a call to another user\n   * @param {string} targetUserId - ID of the user to call\n   */\n  async makeCall(targetUserId) {\n    try {\n      // Mark media as not released since we're starting a call\n      this._mediaReleased = false;\n      \n      // Check if the user is online first\n      const isOnline = await this.checkUserOnline(targetUserId);\n      \n      if (!isOnline) {\n        this.logger.log('Cannot make call - user is not online:', targetUserId);\n        \n        if (this.callbacks && this.callbacks.onUserNotOnline) {\n          this.callbacks.onUserNotOnline(targetUserId);\n        } else {\n          this.updateCallState('ended');\n        }\n        \n        return;\n      }\n      \n      // If there's already an active call, end it first\n      if (this.isCallActive()) {\n        this.logger.log('Ending current call before starting a new one');\n        this.endCall(true);\n      }\n      \n      this.logger.log('Making call to user:', targetUserId);\n      this.targetUserId = targetUserId;\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n      \n      // Initialize the call\n      if (this.connectionManager) {\n        await this.connectionManager.initiateCall(this.userId, targetUserId);\n      }\n    } catch (error) {\n      this.handleError('making call', error, true);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   */\n  async acceptCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to accept');\n      return;\n    }\n    \n    try {\n      // Mark media as not released since we're accepting a call\n      this._mediaReleased = false;\n      \n      this.logger.log('Accepting incoming call from:', this.targetUserId);\n      this.updateCallState('connecting');\n      \n      // Make sure we have camera and microphone access\n      if (!this.mediaManager.hasLocalStream()) {\n        await this.getLocalMedia();\n      }\n      \n      // Accept the call\n      if (this.connectionManager) {\n        await this.connectionManager.acceptCall(this.targetUserId);\n      }\n    } catch (error) {\n      this.handleError('accepting call', error, true);\n    }\n  }\n  \n  /**\n   * Decline an incoming call\n   */\n  declineCall() {\n    if (!this.targetUserId) {\n      this.logger.log('No incoming call to decline');\n      return;\n    }\n    \n    this.logger.log('Declining call from:', this.targetUserId);\n    if (this.signalingService) {\n      this.signalingService.send('call-declined', { targetUserId: this.targetUserId });\n    }\n    \n    // Ensure camera resources are released on decline\n    this.ensureCameraReleased();\n    \n    // Reset state\n    this.targetUserId = null;\n    this.pendingOffer = null;\n    this.callState = 'idle';\n  }\n  \n  /**\n   * Get access to local camera and microphone\n   * @param {boolean|object} videoConstraints - Constraints for video\n   * @param {boolean|object} audioConstraints - Constraints for audio\n   * @returns {Promise<MediaStream>} - Local media stream\n   */\n  async getLocalMedia(videoConstraints = true, audioConstraints = true) {\n    try {\n      // Reset media released flag since we're getting new media\n      this._mediaReleased = false;\n      \n      const stream = await this.mediaManager.getLocalMedia(videoConstraints, audioConstraints);\n      \n      // Add local stream to connection manager if it exists\n      if (this.connectionManager) {\n        this.connectionManager.setLocalStream(stream);\n      }\n      \n      return stream;\n    } catch (error) {\n      this.handleError('accessing media devices', error, true);\n      throw error;\n    }\n  }\n  \n  /**\n   * Toggle audio mute state\n   * @param {boolean} muted - Whether to mute audio\n   */\n  toggleAudio(muted) {\n    if (this.mediaManager) {\n      this.mediaManager.toggleAudio(muted);\n    }\n  }\n  \n  /**\n   * Toggle video on/off\n   * @param {boolean} videoOff - Whether to turn off video\n   */\n  toggleVideo(videoOff) {\n    if (this.mediaManager) {\n      this.mediaManager.toggleVideo(videoOff);\n    }\n  }\n  \n  /**\n   * Unified error handling method\n   */\n  handleError(context, error, fatal = false) {\n    this.logger.error(`Error in ${context}:`, error.message);\n    console.error(`Error in ${context}:`, error);\n    \n    // Emit error event for UI components to handle\n    this.eventEmitter.emit('error', {\n      context,\n      message: error.message,\n      fatal\n    });\n    \n    // If it's a fatal error, end the call\n    if (fatal) {\n      this.updateCallState('ended');\n      this.endCall(true);\n    }\n  }\n  \n  /**\n   * Disconnect from signaling server and clean up resources\n   */\n  disconnect() {\n    this.logger.log('Disconnecting WebRTC service');\n    \n    // End any active call\n    this.endCall(true);\n    \n    // Clear state check interval\n    if (this.stateCheckInterval) {\n      clearInterval(this.stateCheckInterval);\n      this.stateCheckInterval = null;\n    }\n    \n    // Clear connection monitor interval\n    if (this.connectionMonitorInterval) {\n      clearInterval(this.connectionMonitorInterval);\n      this.connectionMonitorInterval = null;\n    }\n    \n    // Ensure camera is released before disconnecting\n    this.ensureCameraReleased();\n    \n    // Disconnect from signaling server\n    if (this.signalingService) {\n      this.signalingService.disconnect();\n    }\n    \n    // Clean up managers\n    if (this.connectionManager) {\n      this.connectionManager.cleanup();\n    }\n    \n    if (this.mediaManager) {\n      this.mediaManager.cleanup();\n    }\n    \n    // Reset initialization status\n    this.isInitialized = false;\n    \n    // Clear user ID\n    this.userId = null;\n  }\n}\n\n// Create a singleton instance\nconst webRTCService = new WebRTCService();\nexport default webRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}